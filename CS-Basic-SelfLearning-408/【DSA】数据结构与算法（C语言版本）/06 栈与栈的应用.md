#数据结构 
# [21] 栈的基本概念
栈（Stack）是**只允许在一端进行插入或删除**操作的线性表。

- 逻辑结构：与普通线性表相同 
- 数据的运算：插入、删除操作有区别

重要术语：**栈顶、栈底、空栈**。
- **栈顶**：允许插入 和删除的一端
- **栈底**：不允许插 入和删除的一端

![](img/03_stack_queue/01%20栈.JPG)
特点：后进先出 / Last In First Out （**LIFO**）

```cpp
// 初始化栈。构造一个空栈 S，分配内存空间。
InitStack(&S);
// 销毁栈。销毁并释放栈 S 所占用的内存空间。 
DestroyStack(&S);

// 进栈，若栈S未满，则将x加入使之成为新栈顶。 
Push(&S,x);
// 出栈，若栈S非空，则弹出栈顶元素，并用x返回。 
元素的进栈和出栈，只能再栈顶进行操作。
Pop(&S,&x);

// 读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素 
GetTop(S, &x);

其他常用操作： 
// 判断一个栈 S 是否为空。若S为空，则返回true，否则返回false
StackEmpty(S);
```

问：如果有n个不同元素进栈，出栈元素不同排列的个数为:
$$\frac{1}{n+1}C_{2n}^{n}$$
上述公式称为**卡特兰（Catalan）数**，可采用数学归纳法证明（不要求掌握）。  
这里可以涉及一道算法题目：  
[946. 验证栈序列 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-stack-sequences/description/)

# [22] 栈的顺序存储结构
对于栈的定义，首先使用顺序表存储栈结构，使用结构体变量，包含数据部分和栈顶指针（**永远指向栈的栈顶位置**）。
## 1. 顺序栈定义
```c
#define MaxSize 10              // 定义栈元素中的最大个数
typedef struct {
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top;                    // 栈顶指针
} SqStack;

void testStack()
{
    SqStack S;                  // 声明一个顺序栈（分配空间）
    /* ...后续操作... */
}
```

![](img/03_stack_queue/02%20顺序栈.JPG)

## 2. 初始化栈
指定栈顶指针为-1，一个没有实际意义的数字，用来表示是一个空栈。
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top;                    // 栈顶指针
} SqStack;

// 初始化栈
void InitStack(SqStack &S)
{
    S.top = -1;                 // 初始化栈顶指针
}

void testStack(SqStack &S)
{
    SqStack S;
    InitStact(S);
    /* 后续操作 */
}
```

## 3. 如何判断栈是空？
同理，判断栈顶指针是否是 -1 即可。
```c
// 对栈判空
bool StackEmpty(SqStack S)
{
    if (S.top = -1) {
        return true;
    } else {
        return false;    
    }
}
```

## 4. 进栈操作，在栈顶添加数据

![](img/03_stack_queue/03%20入栈.JPG)

```c
// 进栈
bool Push(SqStack &S, ElemType x)
{
    if (S.top == MaxSize - 1) {    // 栈满，报错
        return false;
    }
    S.top++;                    // 栈顶指针自增1
    S.data[S.top] = x;          // 新元素入栈
    /*  上面两句可以等价写成:
        S.data[++S.top] = x 
        注意先移动指针，再赋值的顺序 */
    return true;
}
```

## 5. 出栈操作

![](img/03_stack_queue/04%20出栈.JPG)

```c
// 出栈
bool Pop(SqStack &S, ElemType &x)
{
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top];          // 栈顶元素先出栈
    S.top--;                    // 栈顶指针自减1
    /*  上面两句可以等价写成:
    x == S.data[S.top--] 
    注意先传递数值，再移动指针 */
    return true;
}
```

## 6. 读取栈顶元素操作
直接根据索引，查询索引值。
```c
// 读取栈顶元素
bool Pop(SqStack &S, ElemType &x)
{
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top];          // 用x记录栈顶元素
    return true;
}
```

## 7. 共享栈
共享栈是一种特殊的栈，使用相同的一片内存空间，使用两个栈共存。内存空间的两个边界分别作为两个栈的栈底，同时，因此也有两个栈顶指针。而共享栈数据的生长，沿着彼此相对的方向。
```c
// 共享栈的由一块内存的首位各定义了一个栈顶
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
    ElemType data[MaxSize];     // 静态数组中存放栈
    int top_0;                   // 0号栈顶指针
    int top_1;                   // 1号栈顶指针
} SqStack;

void InitStack(ShStack &S)
{
    S.top_0 = -1;
    S.top_1 = MaxSize;           // 两栈从两头分别进行存储
}

// 栈满的条件： top_1 == top_0 + 1
```

![](img/03_stack_queue/05%20共享栈，双向生长.JPG)

# [23] 栈的链式存储结构 
用链式存储的方式实现的栈称之为链栈（LinkedList Stack）。
如果规定**对只能在单链表表头一侧**进行操作，那么用头插法建立单链表，实质上就是进栈操作; 

![](img/03_stack_queue/06%20链栈-入栈.jpg)

用头插法删除单链表，实质上就是出栈操作。

![](img/03_stack_queue/07%20链栈-出栈.jpg)

原来的链头，即是栈的栈顶。

```c
// 定义链栈
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
} *LiStack;
```
由于链式存储的栈实际的操作跟链表类似。具体情况不再做过多讨论。

#数据结构 #C 
# [24] 栈在括号匹配中的应用
括号匹配问题，要求根据一对字符串，判断是否匹配。  
核心特点：**最后出现的左括号，最先被匹配**。（LIFO）  
可以转化成为一个“栈”问题：
每出现一个左括号，就把他填到栈内，每出现一个右括号，就把他从栈中取出。检查是否匹配。

## 1. 匹配与非匹配情况穷举

![](img/03_stack_queue/08%20括号匹配的场景.jpg)

## 2. 算法程序设计：

![](img/03_stack_queue/09%20括号匹配算法演示.jpg)

程序伪代码实现：
```txt
while (下一个字符char非空) {
    如果 (字符char是左括号) {
        把这个字符压入栈顶;
    }
    
    否则{
        /* 对栈判空 弹出的前提是非空栈 */
        如果(栈空)
            return false;
        
        弹出栈顶元素;
        如果(栈顶元素和char配对)
            continue;
        否则
            return false;
    }
}

/* 所有字符已经检索完毕 */
如果(栈空) {
    return true;
} 否则 {
    return false;
}
```

## 3. C语言实现
以上算法使用C语言实现：
```c
// 这里的入参相当于是 char *str，因为：数组入参会退化成指针
bool IsPairBracket(char str[],int length)
{
    /* 初始化栈 */
    SqStack S;
    InitStack S;
    /* 括号的序号 */
    int i = 0;
    
    while (i < length) {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{'){
            Push(S,str[i]);
        } else {
            // 右括号压入时，发展栈内已经空了
            if (StackEmpty(S)) {
                return false;
            }
            
            // 栈顶元素
            char TopElem;
            Pop(S, TopElem);
            if (str[i] == ')' && TopElem != '('){
                return false;
            }
            if (str[i] == ']' && TopElem != '['){
                return false;
            }
            if (str[i] == '}' && TopElem != '{'){
                return false;
            }            
        }
        i++;
    }
    // 判定循环后的栈是否是空
    return StackEmpty(S);
}
```

# [25] 栈在表达式求值中的应用（上）
## 1. 前缀、中缀和后缀表达式
 中缀表达式，是**一般的通常写法**。  
 **后缀表达式，即波兰表达式**（Polish notation）  
运算符在两个操作数后面：  
- $a+b$ 可以表示为 $ab+$  
- $a+b-c$ 可以表示为 $ab+c-$    
- $a+b-c×d$ 可以表示为 $ab+cd×-$  

 **前缀表达式，即逆波兰表达式**（Reverse Polish notation）  
运算符在两个两个操作数前面，例如：    
- $a+b$ 可以表示为 $+ab$  
- $a+b-c$ 可以表示为 $-+abc$  
- $a+b-c×d$ 可以表示为 $-+ab×cd$

## 2. 中缀表达式转后缀表达式
- 中缀转后缀的手算方法：  
1. 确定中缀表达式中各个运算符的运算顺序  
2. 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数  
3.  如果还有运算符没被处理，就继续 `2`步骤

![](img/03_stack_queue/10%20中缀表达式转后缀表达式.JPG)

由于表达式运算顺序不唯一，因此对应后缀表达式也不唯一。
- ★ **“左优先”原则，不要FreeStyle，保证手算和机算结果相同**  
- “左优先”原则：**只要左边的运算符能先计算，就优先算左边的，可保证运算顺序唯一**

![](img/03_stack_queue/11%20左优先%20保证算法的唯一性.JPG)

- 后缀表达式的**手算方法**：
从左往右扫描，每遇到一个运算符，就让运算符**前面最近的两个操作数**执行对应运算，合体为一个操作数。这就意味着，**越最后出现的操作数，优先被运算**。这与栈的数据结构十分类似（LIFO）。  
后缀表达式适用于基于栈的编程语言（stack-oriented programming language），如：Forth、PostScript

## 3. 中缀表达式转前缀表达式
- 中缀转前缀的手算方法：  
1.  确定中缀表达式中各个运算符的运算顺序  
2. 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数  
3. 如果还有运算符没被处理，就继续 `2`

![](img/03_stack_queue/12%20中缀表达式转前缀表达式.jpg)

- ★ **“右优先”原则**：只要右边的运算符能先计算，就**优先算右边的**

![](img/03_stack_queue/12%20中缀表达式转前缀表达式.jpg)

# [26] 栈在表达式求值中的应用（下）
## 1. 中缀表达式转后缀表达式（机算）
初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。  
从左到右处理各个元素，直到末尾。可能遇到三种情况：  
1. 遇到**操作数**。直接加入后缀表达式。  
2.  遇到**界限符**。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。  
3. 遇到**运算符**。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

## 2. 中缀表达式计算（栈实现）
用栈实现中缀表达式的计算：
- 初始化两个栈，操作数栈和运算符栈
- 若扫描到操作数，压入操作数栈
- 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）

用栈实现后缀表达式的计算：  
1. 从左往右扫描下一个元素，直到处理完所有元素  
2. 若扫描到操作数则压入栈，并回到`1`；否则执行`3` 
3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到`1`

# [27] 栈在递归中的应用
函数调用的特点：最后一个被调用的函数最先执行结束（LIFO）
函数调用过程中，计算机会建立一个**栈存储**：
1.  调用返回地址；
2. 实参；
3. 局部变量。

![](img/03_stack_queue/14%20函数调用栈.jpg)

适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题
以斐波那契数列为例子：
```c
int Fib(unsigned int n)
{
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    } else {
        return Fib(n - 1) + Fib(n - 2);
    }
}

int main(void){
    /* 其他代码 */
    int x = Fib(4);
    printf("%d",x);
    return 0;
}
```

逐级调用过程分解如下：
**调用时正序，返回时逆序**。

![](img/03_stack_queue/15%20斐波拉契数列递归.jpg)

递归调用时，函数调用栈可称为“**递归工作栈**”
- 每进入一层递归，就将递归调用所需信息**压入栈顶**
- 每退出一层递归，就从栈顶**弹出相应信息**    

缺点：太多层递归可能会导致栈溢出，可能包含很多重复计算。

关于函数调用栈：
[Call Stack（调用栈）是什么？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/71168084)
