#数据结构 #算法 #C 
# [89] 堆排序
## 1. 什么是“堆”数据结构
若$n$个关键字序列$L[1…n]$满⾜下⾯某⼀条性质，则称为堆（Heap）：
1. 若满⾜：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$ $(1 ≤ i ≤n/2 )$—— 大根堆（大顶堆）
2. 若满⾜：$L(i)≤L(2i)$且$L(i)≤L(2i+1) (1 ≤ i ≤n/2)$—— 小根堆（小顶堆）
## 2. 算法思想
思路：把所有⾮终端结点都检查⼀遍，是否满⾜⼤根堆的要求，如果不满足，则进⾏调整⼤根堆，若元素互换破坏了下⼀级的堆，则采⽤相同的⽅法继续往下调整（小元素不断“下坠”）。
## 3. 算法实现
```c
// 建立大根堆
void BuildMaxHeap(int A[], int len){
    // 从后往前调整所有非终端结点
    for (int i = len / 2; i > 0; i--){
        HeadAdjust(A, i, len);
    }
}

// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len){
    // A[0] 暂存子树的根结点
    A[0] = A[k];
    // 沿key较大的子结点向下筛选
    for (int i = 2 * k; i < len; i *= 2){
        // 取key较大的子结点的下标
        if (i < len && A[i] < A[i + 1]){
            i++;
        }
        // 筛选结束
        if (A[0] >= A[i]) {
            break;
        }
        // 将A[i] 调整到双亲结点上
        // 修改k值, 以便继续向下筛选
        else {
            A[k] = A[i];
            k = i;
        }
    }
    A[k] = A[0];
}
```
## 4. 算法性能

# [90]  堆的插入删除
对于小根堆，新元素放到表尾，与父结点对比，若新元素比父结点更小，则将二者互换。新元素就这样一路"上升"，直到无法继续上升为止。

被删除的元素用堆底元素替代，然后让该元素不断"下坠"，直到无法下坠为止。

