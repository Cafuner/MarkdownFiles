#操作系统 
# [15] 调度的概念、层次
当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来**决定**处理**这些任务的顺序**，这就是“**调度**”（schedule，dispatcher）研究的问题。

![](img/02_process_mngmnt/22%20调度的例子.jpg)

使用CPU调度机制**可以解决以下问题**：
1. 如果进程正在等待执行，请尽可能使 CPU 保持繁忙状态。
2. 缩短关键流程的执行时间。
3. 智能地确定执行流程的优先级。
4. 将响应时间保持在最低限度。

广义的调度分为三级调度——高级、中级、低级，又叫长周期、中周期、短周期调度。

![](img/02_process_mngmnt/23%20三级调度.jpg)

## 1.高级调度（long-term scheduling）
高级调度又叫作业调度（Job Scheduler），作业的含义是指**一个具体的任务**。例如，作业是一次完成数据统计，实行一次打印输出等。
高级调度，按一定的原则从**外存的作业后备队列**（后备队列是位于外存中）中挑选一个作业调入**内存**，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

![](img/02_process_mngmnt/24%20高级调度.jpg)

## 2.低级调度（short-term scheduling）
低级调度又称之为进程调度、处理机调度（CPU scheduling），其注意按照某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

![](img/02_process_mngmnt/25%20低级调度.jpg)

## 3.中级调度（middle-term scheduling）
内存不够时，可将某些**进程的数据调出外存**。等内存空闲或者进程需要运行时再**重新调入内存**。暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程PCB会被组织成**挂起队列**。

![](img/02_process_mngmnt/26%20中级调度.jpg)

因此，中级调度又称之为内存调度（swapping out），即按照某种策略决定将哪个处于**挂起状态**的进程**重新调入内存**。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要**比高级调度更高**。
## 4.进程的挂起态与七状态模型
暂时调到外存等待的进程状态为**挂起状态**（挂起态，suspend），挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态。这里，我们使用了七状态模型。

![](img/02_process_mngmnt/07%20进程七状态模型.jpg)

★注意“挂起”和“阻塞”的区别：
两种状态都是暂时不能获得CPU的服务，但**挂起态**是将**进程映像调到外存**去了，而阻塞态下**进程映像还在内存**中。
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。
## 5.总结

| 调度类型                 | 做的任务                                                             | 调度发生在哪里         | 发生频率 | 对进程状态的影响                 |
| ------------------------ | -------------------------------------------------------------------- | ---------------------- | -------- | -------------------------------- |
| 高级调度（**作业调度**） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存（面向作业） | 最低     | 无->创建态->就绪态               |
| 中级调度（**内存调度**） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存             | 外存->内存（面向进程） | 中等     | 挂起态->就绪态（阻塞挂->阻塞态） |
| 低级调度（**进程调度**） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机                 | 内存->CPU              | 最高     | 就绪态->运行态                   |

# [16] 进程调度的时机、切换与过程、方式
进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。
## 1. 进程调度的时机
什么时候需要进行进程调度与切换的情况？
### 当前运行的进程主动放弃处理机：
1. 进程正常终止;
2. 运行过程中发生异常而终止;
3. 进程主动**请求阻塞**（如 等待I/O）;
### 当前运行进程被动放弃处理机：
4. 分给进程的时间片用完;
5. 有更紧急的事需要处理（如 **I/O中断**）;
6. 有更高优先级的进程进入就绪队列.

![](img/02_process_mngmnt/27%20进程调度发生场景.jpg)

### 不能进行进程调度与切换的情况
1. 在**处理中断的过程**中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）。

![](img/02_process_mngmnt/28%20进程调度不会发生场景.jpg)

错误辨析：
- √ 进程在操作系统**内核程序临界区**中不能进行调度与切换。----- 正确
- × 进程处于**临界区**时不能进行处理机调度。----- 错误

### 临界资源
- **临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要**互斥**地访问临界资源。 
- 临界区：访问临界资源的那段代码。
    **内核程序临界区**一般是用来**访问某种内核数据结构**的，比如进程的就绪队列（由各就绪进程的PCB组成）

![](img/02_process_mngmnt/29%20临界区.jpg)

## 2. 进程调度的方式
1. 非剥夺调度方式，又称非抢占方式（Non-Preemptive Scheduling）。
只**允许进程主动放弃处理机**。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。   
实现简单，系统开销小但是**无法及时处理紧急任务**，适合于早期的**批处理系统**。
2. 剥夺调度方式，又称抢占方式（Preemptive Scheduling）。
当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给**更重要紧迫**的那个进程。    
可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于**分时操作系统、实时操作系统**。

![](img/02_process_mngmnt/30%20抢占式和非抢占式.jpg)

## 3. 进程调度的切换与过程
狭义的“进程调度（process scheduling）”与“进程切换（process switch）”的区别：
- **狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被**暂停执行**的进程，也可能是**另一个进程**，后一种情况就需要进程切换）。
- **进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。
- **广义的进程调度**包含了**选择一个进程和进程切换**两个步骤。

- 进程切换的过程实际上完成了：
1. 对原来运行进程各种数据的保存；
2. 对新的进程各种数据的恢复。
（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

![](img/02_process_mngmnt/31%20上下文切换.jpg)

★注意：
**进程切换是有代价**的，因此如果**过于频繁**的进行进程调度、切换，必然会使**整个系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

# [17] 调度算法的评价指标
## 1.CPU利用率（utilization）
CPU利用率：指CPU “忙碌”的时间占总时间的比例。
$$利用率 = \frac{忙碌的时间}{总时间}$$
## 2.系统吞吐量（throughput）
系统吞吐量：单位时间内完成作业的数量。
$$系统吞吐量= \frac{总共完成了多少道作业}{总共花了多少时间}$$
## 3.周转时间（turnarouad time）
周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。它包括四个部分：
1. 作业在外存后备队列上**等待作业调度**（高级调度）的时间；
2. 进程在就绪队列上**等待进程调度**（低级调度）的时间；
3. **进程在CPU上执行的时间**；
4. **进程等待I/O**操作完成的时间。  

![](img/02_process_mngmnt/32%20周转时间.jpg)

后三项在一个作业的整个处理过程中，可能发生多次（**作业调度**只发生一次）。
$$周转时间 = 作业完成时间 – 作业提交时间$$
$$平均周转时间= \frac{各作业周转时间之和}{作业数}$$
对于用户来说，更关心自己的单个作业的周转时间。但是对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值。因此提出**带权周转时间**（weighted turnarouad time）和**平均带权周转时间**。
$$带权周转时间 = \frac{作业周转时间}{作业实际运行的时间} = \frac{作业完成时间 – 作业提交时间}{作业实际运行的时间} $$
带权周转时间与周转时间都是越小越好。
$$平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}$$
对于周转时间相同的两个作业，**实际运行时间长**的作业在相同时间内被服务的时间更多，带**权周转时间更小**，用户满意度更高。对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。

## 4.等待时间（Waiting time）
计算机的用户希望自己的作业尽可能少的等待处理机等待时间，指进程/作业**处于等待处理机状态时间之和**，**等待时间越长，用户满意度越低**。

![](img/02_process_mngmnt/33%20等待时间.jpg)

- 对于**进程**来说，等待时间就是指进程建立后**等待被服务的时间之和**，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
- 对于**作业**来说，不仅要考虑建立进程后的等待时间，还要加上**作业在外存后备队列**中等待的时间。   
一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“**平均等待时间**”来评价整体性能。

## 5.响应时间（Response time）
对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。**响应时间**，指从**用户提交请求**到首次**产生响应**所用的时间。

# [18] FCFS、SJF、HRRN调度算法

## ★ 调度算法的关注重点
1. 算法思想
2. 算法规则
3. 这种调度算法是用于作业调度还是进程调度？
4. 算法属于抢占式？非抢占式？
5. 算法的优点和缺点
6. 是否会导致饥饿（某进程/作业长期得不到服务）？

## 1. FCFS 先来先服务算法（First Come First Serve）
1. **算法思想**
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。
2. **算法规则**
按照作业/进程到达的先后顺序进行服务。
3. **用于作业/进程调度**
用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
4. **是否可抢占**？
**非抢占式**的算法。
以如下的例子，四个进程按照顺序进入处理机计算，其周转时间、带权周转时间和等待时间如图。

![](img/02_process_mngmnt/34%20FCFS%20先来先服务算法.jpg)

注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有I/O操作的进程，其**等待时间**就是**周转时间 — 运行时间 —I/O操作的时间**

5. **优缺点**
优点：公平、算法实现简单
缺点：排在长作业（进程）后面的短作业需要等待很长时间，**带权周转时间很大**，对短作业来说用户体验不好。即FCFS算法对**长作业有利**，对**短作业不利**。
6. **是否会导致饥饿** ？
不会。

## 2. SJF/ SPF 短作业/短进程优先（Shortest Job/Process First）
1. **算法思想**
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间。
2. **算法规则**
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）
3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。
用于作业调度，称为“短作业优先（`SJF`，`Shortest Job First`）算法”
用于进程调度，称为“短进程优先（`SPF`，`Shortest Process First`）算法”
4. **是否可抢占**？
`SJF`和`SPF`均为非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（`SRTN`, `Shortest Remaining Time Next`）
5. **优缺点**
- 优点：“最短的”平均等待时间、平均周转时间。
- 缺点：不公平。对短作业有利，对长作业不利。作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。
6. **是否会导致饥饿** ？
可能产生饥饿现象。另外，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“**饥饿**”现象。如果一直得不到服务，则称为“**饿死**”。

以如下的例子，四个进程按照顺序进入处理机计算，使用非抢占式的短进程优先调度算法（`SPF`，`Shortest Process First`），其周转时间、带权周转时间和等待时间如图。

![](img/02_process_mngmnt/35%20短进程优先算法.jpg)

对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低。

**最短剩余时间优先算法**：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个**进程完成时**也需要**调度**。

![](img/02_process_mngmnt/36%20最短剩余时间优先.jpg)

对比**非抢占式**的短作业优先算法，显然**抢占式**的这几个指标又要更低。
虽然严格来说，`SJF`的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 `FCFS`），
`SJF`依然可以获得较少的平均等待时间、平均周转时间。

## 3. HRRN 高响应比优先（Highest Response Ratio Next）

1. **算法思想**
要综合考虑作业/进程的等待时间和要求服务的时间。
2. **算法规则**
在每次调度时先计算各个作业/进程的**响应比**，选择响应比最高的作业/进程为其服务。
$$响应比 = \frac{等待时间+要求服务时间}{要求服务时间}$$

3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。

![](img/02_process_mngmnt/37%20高响应比优先.jpg)

4. **是否可抢占**？
非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。
5. **优缺点**
- 综合考虑了等待时间和运行时间（要求服务时间）
- 等待时间相同时，要求服务时间短的优先（SJF 的优点）
- 要求服务时间相同时，等待时间长的优先（FCFS 的优点）
- 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。
6. **是否会导致饥饿** ？
不会。

## 总结
| 算法    | 是否可抢占 | 优点 | 缺点 | 是否考虑等待时间和运行时间 | 是否会导致饥饿 |
| ------- | ---------- | ---- | ---- | -------------------------- | -------------- |
| FCFS    | 非抢占式   | 公平；实现简单  |对短作业不利 | 等待时间√ 运行时间×      |   **不会**             |
| SJF/SPF |默认为非抢占式，也有抢占式版本（SRTN算法）|“最短的”平均等待/周转时间| 对长作业不利，难以做到真正的短作业优先| 等待时间× 运行时间√  |**会** |
| HRRN   | 非抢占式   |上述两种算法的权衡折中，综合考虑的等待时间和运行时间  ||等待时间√ 运行时间√ |**不会**|

以上这三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。
因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

# [19] 调度算法：时间片轮转、优先级、多级反馈队列
## 1. 时间片轮转（RR, Round-Robin）
1. **算法思想**
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。
2. **算法规则**
按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
3. **用于作业/进程调度**
用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。
4. **是否可抢占**？
抢占式的算法。
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此**时间片轮转调度**算法属于抢占式的算法。由**时钟装置发出时钟中断**来通知CPU时间片已到。
5. **优缺点**
- 优点：公平；响应快，适用于分时操作系统；
- 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。
6. **是否会导致饥饿** ？
不会。

![](img/02_process_mngmnt/38%20时间片轮转算法.jpg)
![](img/02_process_mngmnt/39%20时间片轮转算法.jpg)
![](img/02_process_mngmnt/40%20时间片轮转算法.jpg)

如上图，如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法**退化为先来先服务**调度算法，并且会增大进程响应时间。因此时间片不能太大。

切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。
比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应。
因此，一般而言，**设计时间片时要让切换进程的开销占比不要超过1%**。

## 2. 优先级调度算法（Priority Scheduling）
1. **算法思想**
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据**任务的紧急程度**来决定处理顺序。
2. **算法规则**
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。
3. **用于作业/进程调度**
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的**I/O调度**中。
4. **是否可抢占**？
抢占式、非抢占式都有。
区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。
## ★ 补充
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。
- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。

![](img/02_process_mngmnt/41%20优先级调度算法.jpg)
![](img/02_process_mngmnt/43%20优先级调度算法.jpg)

- **优先级设定**：
1. 系统进程优先级 高于 用户进程
2. 前台进程优先级 高于 后台进程
3. 操作系统更偏好 **I/O型进程**（或称 I/O繁忙型进程）
    注：与I/O型进程相对的是**计算型进程**（或称 CPU繁忙型进程）
I/O设备和CPU可以并行工作。
如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。

- **采用的是动态优先级，什么时候应该调整**？
可以从追求公平、提升资源利用率等角度考虑：
1. 如果某进程在**就绪队列中等待了很长时间**，则可以适当提升其优先级。
2. 如果某进程占用处理机**运行了很长时间**，则可适当降低其优先级。
3. 如果**发现一个进程频繁地进行I/O操作**，则可适当提升其优先级。

5. **优缺点**
- 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
- 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
6. **是否会导致饥饿** ？
会。

## 3. 多级反馈队列调度算法
1. **算法思想**
对其他调度算法的**折中权衡**。
2. **算法规则**
    1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。
    3. 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片
3. **用于作业/进程调度**
用于进程调度。
4. **是否可抢占**？
**抢占式**的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。

![](img/02_process_mngmnt/44%20多级反馈队列算法.jpg)

5. **优缺点**
    - 对各类型进程**相对公平**（FCFS的优点）；
    - 每个新到达的进程都可以**很快就得到响应**（RR的优点）；
    - 短进程只用**较少的时间**就可完成（SPF的优点）；
    - 不必实现**估计进程的运行时间**（避免用户作假）；
    - 可**灵活地调整**对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
6. **是否会导致饥饿** ？
会。
## 调度算法总结
| 算法       | 思想 | 是否可抢占                       | 优点                       | 缺点                         | 是否会饥饿 | 补充                                                        |
| ---------- | ---- | -------------------------------- | -------------------------- | ---------------------------- | ---------- | ----------------------------------------------------------- |
| 时间片轮转 |      | 抢占式                           | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级 | 不会       | 时间片太大或太小有重要影响？                                |
| 优先级调度 |      | **有抢占式的，也有非抢占式的**。 | 区分优先级，适用于实时系统 | 可能导致饥饿                 | 会         | 动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？ |
|多级反馈队列 |较复杂| 抢占式   |  平衡优秀 |一般不说它有缺点，不过可能导致饥饿 | 会|   |

比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的**交互式操作系统**（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）。


