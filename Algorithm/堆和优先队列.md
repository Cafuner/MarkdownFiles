# 堆和优先队列

堆是一颗完全二叉树，堆中每个节点的值总是不大于或不小于其父节点的值。堆使用数组高效实现。

如果已知一个结点的下标index,那么：

+ 父节点下标parent = (index-1)/2
+ 左孩子的下标 left =2*index+1
+ 右孩子的下标 right = left+1

注：根的下标为0，最后一个元素的下标为size-1

```c++
class Heap
{
    int* arr;
    int size;
    int capacity;
public:
    Heap(int n)
    {
        size=0;
        capacity = n;
        arr = new int[n];
    }
    
    ~Heap()
    {
        delete[] arr;
    }
    
    int getSize()
    {
        return size;
    }
    
    int top()
    {
        return arr[0];
    }
    
    void insert(int value)
    {
        if(size == capacity)
            return;
        size++;
        int index = size-1;
        while(index>0)
        {
            if(arr[(index-1)/2]<=value)
            {
               break;
            }
            else
            {
                arr[index] = arr[(index-1)/2];
                index = (index-1)/2;
            }
        }
        arr[index] = value;
    }
    
    void pop()
    {
        if(size==0)
            return;
        int value = arr[size-1];
        size--;
        int index=0;
        while(index*2+1<=size-1)
        {
            int child = index*2+1;
            if((child+1<=size-1) && (arr[child]>arr[child+1]))
            {
                child = child+1;
            }
            if(arr[child]>=value)
            {
                break;
            }
            else
            {
                arr[index] = arr[child];
                index = child;
            }
                
        }
        arr[index] = value;
    }

};


```





C++STL中的优先队列：

优先队列容器和队列一样，只能从队尾插入元素，从队首删除元素。

优先队列有一个特性，就是默认队列中最大的元素总是位于队首，所以出队时，并不是完全一样的遵循先进先出的原则来进行的，而是将队列中最大的元素出队。这点有点儿类似于给队列里元素先进行一个排序，再按照顺序出队。元素的比较规则默认按照元素值由大到小排序，我们可以重载 "<" 操作符来重新定义比较规则。

```c++
#include <cstdio>
#include <queue>
using namespace std;

struct node {
    int x, y;
    node() {}
    node(int x, int y): x(x), y(y) {}

    //a.x<b.x时，a<b
    bool operator<(const node &a)const {
        if(x != a.x)
             return x < a.x;
        else return y < a.y;
    }
};

int main(int argc, const char* argv[])
{
    node a(0,0);
    node b(1,0);

    priority_queue<node> que;
    que.push(a);
    que.push(b); // a<b
    printf("%d", que.top().x); // 1
}
//int que.size();
//bool que.empty();
//void que.pop();



struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

struct cmp
{
    bool operator()(const ListNode* a, const ListNode* b) const 
    {
        if(a->val > b->val)
            return true;
        return false;
    }
};
//优先队列中根节点的val最小
priority_queue<ListNode*, vector<ListNode*>, cmp> que;
```

