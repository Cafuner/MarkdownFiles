# 线索二叉树 Threaded Binary Tree

参考：https://zhuanlan.zhihu.com/p/600665635

## 线索二叉树的概念

二叉树的三种经典遍历方式会将树结构线性化，按照遍历的顺序，每一个节点（除了最先和最后访问到的节点）都有一个（直接）前驱和（直接）后继。加入我们有一个节点的指针，想要知道这个节点再某种遍历方式下的前驱和后继，除非是特殊位置的节点（例如要求节点P在先序遍历下的后继，且P的左子节点不为空，那么其后继就是左子节点），否则我们就需要从根节点来遍历（例如，要求节点P在中序遍历下的前驱且其左子节点为空）。

观察上面的情况，我们发现不能直接求出前驱和后继的很大一部分原因是当访问到叶子节点时，不知道需要下一个需要访问的节点的位置。因此，我们可以利用叶子树中的空链域，即那些为null的指针，让他们指向前驱或者后继。具体的：

+ 如果一个节点的左子节点为空，那么就让它指向其前驱；
+ 如果一个节点的右子节点为空，那么就让它指向其后继。

为了区分指针是指向的是左子节点还是前驱，我们给每个节点加入两个tag域，左tag和右tag。当tag为0时，对应的指针指向子节点，当tag为1时，对应的指针指向前驱/后继。

```c++
struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
};
```

综上，这样的二叉树即称为线索二叉树。按照线索化的遍历顺序，线索二叉树可以分为3类：

- **中序线索二叉树** —— 线索指向**中序前驱**、**中序后继**；
- **先序线索二叉树** —— 线索指向**先序前驱**、**先序后继**；
- **后序线索二叉树** —— 线索指向**后序前驱**、**后序后继**。

注意，虽然加上了线索，但从某一个节点出发找前驱和后继也并不一定能够在 $O(1)$ 时间内做到。具体见后文。



## 二叉树的线索化

要得到一个线索二叉树的话，需要对原二叉树进行线索化。

### 中序线索化

中序遍历二叉树每一个结点，遍历（`visit`）一个结点时，对该结点添加前驱线索，并对前驱添加后继线索。

```c++
ThreadNode *pre = NULL;     // 全局变量，指向当前访问结点的前驱

typedef struct ThreadNode {
    ElemType data;
    ThreadNode *lchild, *rchild;
    int ltag, rtag;        // 左、右线索标志
} ThreadNode, *ThreadTree;

// 中序遍历二叉树，一边遍历一边线索化
void InOrderThread(ThreadTree T) 
{
    if (T != NULL) {
        InTread(T->lchild);        // 中序遍历左子树
        visit(T);                  // 访问根节点
        InTread(T->rchild);        // 中序遍历右子树
    }
}

// 线索化 Threading
void visit(ThreadNode *tmp) 
{
    // 左子树是空
    if (tmp->lchild == NULL) {
        tmp->lchild = pre;
        tmp->ltag = 1;          // tag == 1，表示指针指向线索。
    }

    // 前驱不为空，且前驱的右孩子为空，例如二叉树的 B 结点
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = tmp;      // 建立前驱结点的后继线索
        pre->rtag = 1;          // tag == 1，表示指针指向线索。
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = tmp;
}
```

中序线索化的过程，上层调用`InOrderThread`函数： 注意在调用该中序遍历的函数的时候，最后要继续检查`pre`的`rchild`是否是`NULL`，如果是的话，令`rtag` = 1。

```c++
// 中序线索化二叉树
void CreateInOrderThread(ThreadNode root) 
{
    pre = NULL;                 // pre初始化为NULL
    if (root != NULL) {         // 非空二叉树才能线索化
        InOrderThread(root);    // 中序线索化二叉树
        if (pre->rchild == NULL) {
            pre->rtag = 1;      // 处理遍历的最后一个结点
        }
    }
}
```



### 先序线索化

先序线索化与中序线索化相似，唯一一点注意，遍历时对`ltag` 一定要作判定。如果不采取`if (T-> ltag == 0)`判定的话，对其指向结点访问，有可能访问前驱结点，造成死循环问题。

```c++
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 先序遍历二叉树，一边遍历一边线索化
void PreOrderThread(ThreadTree T)
{
    if (T != NULL) {
        visit(T);            // 先处理根节点
        if (T-> ltag == 0)   // lchild 不是前驱线索
        {
            PreOrderThread(T->lchild);
        }
        PreOrderThread(T->rchild);
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}

// 先序线索化二叉树
void CreatePreOrderThread(ThreadNode T) 
{
    pre = NULL;             // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PreOrderThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}
```



### 后序线索化

后序线索化并不会出现类似先序线索化的“死循环”问题。 

```c++
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 后序遍历二叉树，一边遍历一边线索化
void PostOrderThread(ThreadTree T) 
{
    if (T != NULL) {
        PostOrderThread(T->lchild);         // 后序遍历左子树
        PostOrderThread(T->rchild);         // 后序遍历右子树
        visit(T);                           // 访问根节点
    }
}

// 线索化
void visit(ThreadNode *q) 
{
    // 左子树是空，建立前驱线索
    if (q->lchild == NULL) {
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = q;    // 建立前驱结点的后继线索
        pre->rtag = 1;
    }
    // 把pre指状指向下一个结点，依次遍历
    pre = q;
}

// 后序线索化二叉树T
void CreatePostOrderThread(ThreadNode T) 
{
    pre = NULL;                // pre初始化为NULL
    if (T != NULL) {        // 非空二叉树才能线索化
        PostOrderThread(T);        // 中序线索化二叉树
        if (pre->rchild == NULL){
            pre->rtag = 1;    // 处理遍历的最后一个结点
        }
    }
}
```



## 在线索二叉树中找前驱后继

### 1.中序线索二叉树找中序后继

中序线索二叉树，如何找到指定结点 `*p` 的中序后继 `next`？

- 1. 若 `p->rtag == 1`，则`next = p->rchild`; 

- - 因为中序遍历：左-->根--> 右， 
    - 如果`rtag`值表示1，即表示该叶子结点有后继线索，直接赋值即可; 

- 2. 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，那么后继`next` 指向 `p`的右子树中最左下的结点。



### 2.中序线索二叉树找中序前驱

中序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？

- 1. 若 `p->ltag == 1`，则`pre = p->lchild`; 

- - 中序遍历：左-->根--> 右， 
    - 如果`ltag`值表示1，即表示该叶子结点有前驱线索，直接赋值即可; 

- 2. 若 `p->ltag == 0`，表示这个结点一定是有左孩子的，前驱`pre` 指向 `p` 的左子树中最右下的结点。



### 3.先序线索二叉树找先序后继

先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序后继 `next`？

- 1. 若 `p->rtag == 1`，同理，则`next = p->rchild`; 

- 2. 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，这个时候，需要对这个结点的左孩子情况进行讨论。

- - 如果有左孩子，那么先序后继为左孩子； 
    - 如果有没有左孩子，那么先序后继为右孩子。



### 4.先序线索二叉树找先序前驱

先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序前驱 `pre`？

在先序遍历中，某一个结点的左右子树只可能是它的后继，均不可能是它的前驱，所以，如果要求其前驱，有两种方法： 

1. 可以使用最原始的方式从根节点依次遍历，但是浪费时间，时间复杂度 O(N) 。 
2. 采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，就需要对具体情况进行分类**逐个讨论**了：

- 情形1: 
    如果能找到`p`的父节点，且`p`是左孩子。父结点是前驱。
- 情形2：
    如果能找到`p`的父节点，且`p`是右孩子，其左兄弟为空。父结点是前驱。
- 情形3：
    如果能找到`p`的父节点，且`p`是右孩子且左孩子不为空。**左兄弟子树最后一个被先序遍历的结点**是前驱。
- 情形4：
    没有父节点。没有前驱。



### 5.后序线索二叉树找后序前驱

后序线索二叉树（左孩子 --> 右孩子-->根节点 ），如何找到指定结点 `*p` 的后序前驱 `pre`？

- 1. 若 `p->ltag == 1`，则`pre = p->lchild`（同理）; 

- 2. 若 `p->ltag == 0`，表示这个结点一定是有左孩子的。这个时候，需要对这个结点的左孩子情况进行讨论。 

- - 如果有右孩子，那么后序前驱为右孩子； 
    - 如果没有右孩子，那么后序前驱为左孩子；



### 6.后序线索二叉树找后序后继

后序线索二叉树（左孩子 --> 右孩子-->根节点 ），如何找到指定结点 `*p` 的后序后继 `pre`？

后序遍历中，某一个结点的左右子树只可能是它的前驱，均不可能是它的后继，所以，如果要求其后继，有两种方法： 

1. 使用最原始的方式从根节点依次遍历，时间复杂度 O(N) 。 
2. 或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，同样需要对具体情况进行分类**逐个讨论**了：

- 情形1：
    如果能找到p的父节点，且p是右孩子。父结点是后继。
- 情形2：
    如果能找到p的父节点，且p是左孩子，其右兄弟为空。父结点是后继。

- 情形3：
    如果能找到p的父节点，且p是左孩子且右孩子不为空。**右兄弟子树第一个被后序遍历的结点**是后继。
- 情形4：
    没有父节点。没有后继。