# 矩阵快速幂

```c++

typedef long long int ll;
class Matrix
{
public:
    static const int N=2;
    ll data[N][N];
    ll mod;

    Matrix(ll data, ll mod)
    {
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                this->data[i][j] = data;
            }
        }
    }

    Matrix mul(Matrix& a, Matrix& b)
    {
        Matrix ret(0, mod);
        for(int i=0; i<N; i++)
        {
            for(int j=0; j<N; j++)
            {
                for(int k=0; k<N; k++)
                {
                    ll res = ret.data[i][j];
                    res += (a.data[i][k]*b.data[k][j])%mod;
                    ret.data[i][j] = res%mod;
                }
            }
        }
        return ret;
    }

    Matrix pow(ll exp)
    {
        Matrix ret(0, mod);
        for(int i=0; i<N; i++)
            ret.data[i][i] = 1;
        Matrix tmp=*this;
        while(exp)
        {
            if(exp&1)
                ret = mul(ret, tmp);
            tmp = mul(tmp, tmp);
            exp = exp>>1;
        }
        return ret;
    }
};
```



如何想到使用矩阵快速幂？

+ 如果一个问题可与转化为求解一个矩阵的 n 次方的形式，那么可以用快速幂来加速计算。

+ 如果一个递推式形如 $f(n)=\Sigma_{i=1}^ma_if(n-i)$ ，那么我们可以构造对应的矩阵如下：
    $$
    \begin{equation*}
    \begin{bmatrix}
    a_1 & a_2 & a_3 & \cdots &a_m \\
    1 & 0 & 0 & \cdots & 0 \\
    0 & 1 & 0 & \cdots & 0 \\
    0 & 0 & 1 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & \cdots & 1
    \end{bmatrix}
    \end{equation*}
    $$
