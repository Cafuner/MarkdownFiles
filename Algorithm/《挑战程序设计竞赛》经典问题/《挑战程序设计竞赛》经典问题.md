# 《挑战程序设计竞赛》

[TOC]



## 最长公共子序列问题LCS

> 《挑战程序设计竞赛》第二版 2.3.1节
>
> LCS (Longest Common Subsequence)
>
> 给定两个宇符串$s_1,s_2,…,s_n$ 和 $t_1,t_2,...,t_m$。求出这两个字符串最长的公共子序列的长度。宇符串$s_1,s_2,…,s_n$的子序列指可以表示为$s_{i_1},s_{i_2},…,s_{i_n}$（$i_1<i_2<…<i_n$）的序列。

`dp[i][j]`表示字符串s长度为i+1的前缀和字符串t的长度为j+1的前缀的LCS长度。

于是有递推式：
$$
\begin{equation*}
dp[i][j]=
\left\{
\begin{aligned}
 & dp[i-1][j-1]+1 & ,&\ s[i]==t[j] \\
 & max(dp[i-1][j], dp[i][j-1]) & ,&\ 其他
\end{aligned}
\right.
\end{equation*}
$$
时间复杂度O(n)



## 多重集部分和问题

> 《挑战程序设计竞赛》第二版 2.3.2节
>
> 有n种不同大小的数字 $a_i$ ，每种各 $m_i$ 个。判断是否可以从这些数字之中选出若干使它们的和
> 恰好为K。

### 方法一

首先我们看一下如下定义：dp\[i+1\]\[j\]:=用前i种数字是否能加和成j

为了用前i种数字加和成，也就需要能用前i-1种数字加和成$j,j-a_i,⋯,j-m_i*a_i$中的某一种。由此我们可以定义如下递推关系：

$$
\begin{equation*}
dp[i+1][j]=(0≤k≤m_i且k×a_i≤j时存在使dp[i][j-k×a_i]为真的k)
\end{equation*}
$$

核心代码如下：

```c
int solve()
{
    dp[0][0] = true;
    for(int i=0; i<n; i++)
        for(int j=0; j<=k; j++)
            for(int k=0; k<=m[i] && k*a[i] <=j; k++)
                dp[i+1][j] |= dp[i][j-k*a[i]];
    return dp[n][k]   
}

```

该算法的复杂度为 $O(K\Sigma_im_i)$ 。

### 方法二

上述dp方法的复杂度还不够好。在这个问题中，我们不光求出能否得到目标的和数 ，同时把得到时$a_i$这个数还剩下多少个计算出来 ，这样就可以减少复杂度。
$$
\begin{equation*}
dp[i+1][j]:=用前i种数加和得到j时第i种数最多能剩余多少个(不能得到时为-1)
\end{equation*}
$$
按照如上所述定义递推关系，这样如果前i-1个数加和能得到j的话，第i个数就可以留下$m_i$个。此外，前i种数加和出$j-a_i$时第i种数还剩下k(k>0)个的话，用前i种数加和j时第i种数就能剩下k-1个。由此我们能得出如下递推式。
$$
\begin{equation*}
dp[i+1][j]=
\left\{
\begin{aligned}
& m_i &&(dp[i][j]≥0)\\
& -1  &&(j<a_i或dp[i+1][j-a_i]≤0) \\
& dp[i+1][j-a_i]-1 &&(其他)
\end{aligned}
\right.
\end{equation*}
$$
这样，只要看最终是否满足$dp[n][K]≥0$就可以知道答案了。

该算法的时间复杂度是$O(nK)$

将dp数组重复利用的核心代码如下：

```c
bool solve()
{
	memset(dp, -1, sizeof(dp));
    dp[0] = 0;
    for(int i=0; i<n; i++)
        for(int j=0; j<=K; j++)
        {
            if(dp[j]>=0)
                dp[j] = m[i];
            else if(j<a[i] || dp[j-a[i]]<=0)
                dp[j] = -1;
            else
                dp[j] = dp[j-a[i]]-1;
        }
    return dp[K]>=0; 
}
```



## 最长上升子序列问题LIS

>LIS (Longest Increasing Subsequence)
>
>有一个长度为n的数列 $a_0, a_1, \cdots, a_{n-1}$ 。请求出这个序列中最长的上升子序列的长度。



### 方法一

首先定义递推关系：
$$
\begin{equation*}
dp[i]:=以a_i为末尾的最长上升子序列的长度
\end{equation*}
$$
以$a_i$为结尾的上升子序列是只包含$a_i$子序列或者在$a_i$之前存在的序列尾部追加$a_i$之后得到的子序列。于是有：
$$
\begin{equation*}
dp[i]=max\{1, dp[j]+1|j<i且a_j<a_i\}
\end{equation*}
$$
使用该算法的时间复杂度为$O(n^2)$。

核心代码如下：

```c
void solve()
{
    int res = 0;
    for(int i=0; i<n; i++)
    {
        dp[i] = 1;
        for(int j=0; j<i; j++)
        {
            if(a[j]<a[i])
                dp[i] = max(dp[i], dp[j]+1);
        }
        res = max(res, dp[i]);
    }
	return res;
}
```

### 方法二

仔细思考我们就能发现，在dp时我们不需要维护每个元素结尾的最长子序列的长度。因为如果有两个长度相同的上升子序列，那么只有末尾元素更小的序列才有被后续元素扩展的价值。因此，我们可以维护每个长度的上升子序列的末尾元素的最小值，定义：
$$
\begin{equation*}
dp[i]:=长度为i+1的上升子序列的末尾元素的最小值（不存在的话就是INF）
\end{equation*}
$$
 我们来看看如何更新这个数组。最开始全部dp数组的值都初始化为INF。然后由前到后逐个考虑数列a的元素，对于每个$a_i$，找到dp数组中第一个大于等于 $a_i$的数字进行更新。最终找出使得 $dp[i]<INF$ 的最大的 $i$ 就是结果了。

这个DP直接实现的话，能够与前面的方法一样在 $O(n^2)$ 的时间内给出结果。但这一算法还可以更高效的实现。首先dp数列中除INF之外是单调递增的，所以可以知道对于每个 $a_i$ 最多只需要1次更新。对于这次更新究竟应该在什么位置，不必逐个遍历，可以利用二分搜素，这样就可以在 $O(nlogn)$ 时间内求出结果。

核心代码如下：

```c
void solve()
{
    fill(dp, dp+n, INF);
    for(int i=0; i<n; i++)
    {
        *lower_bound(dp, dp+n, a[i]) = a[i];
    }
    return lower_bound(dp, dp+n, INF)-dp;
}
```

>上面的源代码中使用了 lower_bound 这个 STL 函数。这个函数从已排好序的序列a中利用二分搜索找出指向满足 $a_i≥k$ 的 $a_i$ 的最小的指针。类似的函数还有 upper_bound，指向满足 $a_i>k$ 的 $a_i$ 的最小的指针。有了它们，比如长度为n的有序数组a中的k的个数，可以用下面的代码求出
>```c
>upper_bound(a, a+n, k) - lower_bound(a, a+n, k)
>```





## 划分数问题

>《挑战程序设计竞赛》第二版 2.3.3节
>
>有n个无区别的物品，将它们划分为不超过m组，求划分方法数模M的余数。
>
>+   $1≤m≤n≤1000$ 
>+   $2≤M≤10000$ 

这样的划分被称作n的m划分，特别地，m=n时称作n的划分数。


很容易想到的DP数组定义是：$dp[i][j]=j的i划分数$ 。将j划分为i份可以先取出k个，然后将剩下的j-k个分成i-1份。这样就有递推式 $dp[i][j]=\Sigma^j_{k=0}dp[i-1][j-k]$ 。遗憾的是这个递推式不对，因为它把1+2划分和2+1划分当作了两种划分计数，但其实是一种。 

考虑n的m划分，因为是要分成不超过m组，所以有的组可以是空的。于是我们可以把所有的划分方法分成两类，一类是其中没有空组，一类是有空组。现在假设要求j的i划分数：

1. 考虑第一类没有空组的划分方法，可以知道这i个组中元素数量大于等于1。如果我们将每个组都取出一个元素，那这些划分方法恰好与将j-i个元素划分为不超过i个组的划分方法一一对应。于是此类划分方法的数量为 $dp[i][j-i]$ 。
2. 考虑第二类至少有一个空组的划分方法。显然，至少有一个空组的划分方法与将j个元素划分为不超过i-1个组的划分方法一一对应。于是此类划分方法的数量为 $dp[i-1][j]$ 。

综上，有递推关系：
$$
\begin{equation*}
dp[i][j] = dp[i][j-i]+dp[i-1][j]
\end{equation*}
$$
该算法的时间复杂度是 $O(nm)$ 。

### Bell数与Stirling数

本题中求的划分数问题引出了组合数学中的几个概念。

+ Bell数：基数为n的集合划分数目。用本题中的dp数组表示即为 $Bell[n]=dp[n][n]$ 。
+ 第一类Stirling数：将 n 个不同元素构成m个圆排列的数目。
+ 第二类Stirling数：将n个不同的元素拆分成m个集合的方案数，要求集合非空。





## 多重集组合数问题

>《挑战程序设计竞赛》第二版 2.3.3节
>
>POJ 3046 Ant Counting
>
>有n种物品，第i种物品有 $a_i$ 个。不同种类的物品可以互相区分但相同种类的无法区分。从
>这些物品中取出m个的话，有多少种取法？求出方案数模 M 的余数。
>
>+   $1≤n≤1000$ 
>+   $1≤m≤1000$ 
>+   $1≤a_i≤1000$
>+   $2≤M≤10000$

### 方法一

这道题目的本质就是把m划分成不超过n组，但是每一组都有个数限制。与划分数问题相同，我们如下定义DP数组：
$$
\begin{equation*}
dp[i][j]:=从前i(i≥0)种物品中取出j个的方法数
\end{equation*}
$$
直观来看，在考虑 $dp[i][j]$ 时，我们可以从第i种物品中取 $k(0≤k≤min(j,a_i))$ 个，不够的从前i-1种物品中取。由此有递推式：
$$
\begin{equation*}
dp[i][j] = \Sigma_{k=0}^{min(j, a_i)}dp[i-1][j-k]
\end{equation*}
$$
直接实现该算法的话，遍历dp数组的复杂度是nm，计算dp数组的每个元素的复杂度是m，所以总共的时间复杂度是 $O(nm^2)$ 。

### 方法二

上面的方法枚举从第i种物品中取k个，这个操作很费时间，而且有很多冗余计算。与划分数问题的思路相同，我们考虑把k分类。

1. 考虑第一类从第i种物品中取了0个的方案，即 $k=0$ 。这些方法与从前i-1种物品中取j个的方案一一对应，所以其数量为 $dp[i-1][j]$ 。

2. 考虑第二类从第i种物品中取了至少1个的方案，即 $1≤k≤min(j,a_i)$ 。假设我们提前预留一个物品的位置，用来取第i种物品，那么就可以保证第i种物品至少取了1个。因此我们先找出以下方案：从前i种物品中取j-1个物品。这些方案的数量为 $dp[i][j-1]$ 。对每一个方案，我们再添加一个第i种物品，就可以将这些方案变成符合第二类条件的方案。但这道题多了限制条件，第i种物品有数量限制。因此发现：

    + 当 $j-1≥a_i$ 时， $dp[i][j-1]$ 这些方案中，有一些方案已经从第i类里取了 $a_i$ 个了，我们无法再给它们添加一个第i类的物品，因此需要去掉一部分满足条件如下条件的方案：在前i种物品中取j-1个物品，且第i种物品取了 $a_i$ 个。显然，这部分方案的数量为 $dp[i-1][j-1-a_i]$ 。因此，第二类方案的数量为 $dp[i][j-1]-dp[i-1][j-1-a_i]$ 。

    + 当 $j-1<a_i$ 时， $dp[i][j-1]$ 中的方案在第i类最多能取 $a_i-1$ 个，因此可以向其中再加一个第i种物品。

综上，有递推式：
$$
\begin{equation*}
dp[i][j]=
\left\{
\begin{aligned}
 & dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1-a_i] & &(\ j-1≥a_i\ ) \\
 & dp[i-1][j]+dp[i][j-1] & &(\ j-1<a_i\ )
\end{aligned}
\right.
\end{equation*}
$$
这样时间复杂度就降到了 $O(nm)$ 。

```c++
void solve()
{
	memset(dp, 0, sizeof(dp));
    for(int j=0; j<=a[0]; j++)
    {
        dp[0][j] = 1;
    }
    for(int i=1; i<n; i++)
    {
        dp[i][0] = 1;
        for(int j=1; j<=m; j++)
        {
            if(j-1>=a[i])
                dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1-a[i]];
            else
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[n-1][m];
}
```

最后从数学角度推理出递推式：
$$
\small\begin{equation*}
\begin{aligned}
dp[i][j] 
& = {\large \Sigma_{k=0}^{min(j, a_i)}}
\\
\\
& =\left\{
	\begin{aligned}
 	& dp[i-1][j]+dp[i-1][j-1]+\cdots+dp[i-1][j-a_i] & &(\ j-1≥a_i\ ) \\
 	& dp[i-1][j]+dp[i-1][j-1]+\cdots+dp[i-1][0] & &(\ j-1<a_i\ )
	\end{aligned}
	\right.
\\
\\
& =\left\{
	\begin{aligned}
 	& dp[i-1][j]+(dp[i-1][j-1]+\cdots+dp[i-1][j-a_i]+dp[i-1][j-a_i-1])-dp[i-1][j-a_i-1] & &(\ j-1≥a_i\ ) \\
 	& dp[i-1][j]+(dp[i-1][j-1]+\cdots+dp[i-1][0]) & &(\ j-1<a_i\ )
	\end{aligned}
	\right.
\\
\\
& =\left\{
	\begin{aligned}
 	& dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1-a_i] & &(\ j-1≥a_i\ ) \\
 	& dp[i-1][j]+dp[i][j-1] & &(\ j-1<a_i\ )
	\end{aligned}
	\right.
\end{aligned}
\end{equation*}
$$



---



## 二分图判定

>给定一个具有n个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是
>否能最多用2种颜色进行染色？题目保证没有重边和自环。
>
>+ $1≤n≤1000$

### 解题算法：图论DFS

如果只用2种颜色，那么确定一个顶点的颜色之后，和它相邻的顶点的颜色也就确定了。因此，选择任意一个顶点出发，依次确定相邻顶点的颜色，就可以判断是否可以被2种颜色染色了。可以用深度优先搜素简单地实现。

```c++
vector<int> G[MAX_V];
int V;
int color[MAX_V];

bool dfs(int v, int c)
{
    color[v] = c;
    for(int i=0; i<G[v].size(); i++)
    {
        if(color[G[v][i]]==c)
            return false;
        if(color[G[v][i]]==0 && !dfs(G[v][i], -c))
            return false;
    }
    return true;
}

bool solve()
{
    for(int i=0; i<V; i++)
    {
        if(color[i]==0)
        {
            if(!dfs(i, 1))
                return false;
        }
    }
    return true;
}
```



## 最短路问题

最短路问题是图论中最基础的问题，在程序设计竞赛试题中也经常出现。最短路是给定两个顶点， 在以这两个点为起点和终点的路径中，边的权值和最小的路径。

### 单源最短路问题

单源最短路问题是固定一个起点，求它到其他所有点的最短路的问题。终点也固定的问题叫做两点之间最短路问题。但是因为解决单源最短路问题的复杂度也是一样的，因此通常当作单源最短路问题来求解。

#### Bellman-Ford算法

记从起点s出发到顶点f的最短距离为$d[i]$。则下述等式成立：
$$
\begin{equation*}
d[i] = min\{d[j]+(从j到i的边的权值)|e=(j,i)\in E \}
\end{equation*}
$$

可以不断使用这条递推关系更新数组d的值，只要图中不存在负圈，这样的更新操作就是有限的。

```c++
struct edge
{
    int from;
    int to;
    int cost;
}

edge es[MAX_E];
int d[MAX_V];
int V, E;

void bellman_ford(int s)
{
    for(int i=0; i<V; i++)
        d[i] = INF;
    d[s] = 0;
    while(true)
    {
        bool update = false;
        for(int i=0; i<E; i++)
        {
            edge e = es[i];
            if(d[e.from]!=INF && d[e.from]+e.cost<d[e.to])
            {
                d[e.to] = d[e.from]+e.cost;
           		update = true;
            }
        }
        if(update==false)
            break;
    }
}
```



#### Dijkstra 算法

在BellmanFord算法中，其中有很多无效更新操作。如果d[i]还不是最短距离的话，那么基于d[i]进行的更新都不会是最短距离。因此，可以对算法做如下改进：

1. 找到最短距离已经确定的点，从它出发更新所有与之相邻的节点的最短距离。
2. 此后不再需要关心1中的“最短距离已经确定的节点”。

在最开始，只有起点的最短距离是确定的，而在尚未使用过的顶点中，d[i]最小的顶点就是新的最小距离已经确定的顶点。这是由于不存在负边，所以d[i]不会在之后的更新中变小。因此，我们只需要维护一个集合，就是当前最短距离已经确定的顶点构成的集合，更新这个集合直到所有顶点放入该集合，所有顶点到指定顶点的最短距离就确定了。

在更新顶点时，我们首先要找出从当前集合中的顶点经过一条边可以到达的顶点集合，称为备选集合。于是我们每一轮从备选集合中选择一个d[i]最小的顶点，因为这个顶点到起点的距离以后不可能会更小，所以它的距离已经确定，可以加入确定集合。在将它加入确定集合后，我们需要更新备选集合，也就是将选择的顶点的邻居的d[i]更新并放入备选集合。

为了快速的从备选集合中选出d[i]最小的顶点，我们可以使用最小堆来维护该集合。

```c++
struct edge
{
	int to;
	int cost;
}
typedef pair<int, int> P;

int V;
vector<edge> G[MAX_V];
int d[MAX_V];

void dijkstra(int s)
{
	priority_queue<P, vector<P>, greater<P> > que;
	fill(d, d+V, INF);
	d[s] = 0;
	que.push(P(0, s));
	while(!que.emtpy())
	{
		P p = que.top();
		que.pop();
		if(p.first>d[p.second])
			continue;
		int from = p.second;
		int size = G[from].size();
		for(int i=0; i<size; i++)
		{
			edge e = G[from][i];
			if(d[from]+e.cost<d[e.to])
			{
				d[e.to] = d[from]+e.cost;
				que.push(P(d[e.to], e.to));
			}
		}
	}
}
```
相对于Bellman-Ford的O(VE)的复杂度，Dijkstra算法的复杂度是O(ElogV)，可以更加高效地计算最短路的长度。但是，在图中存在负边的情况下，Dijkstra算法就无法正确求解问题，还是需要使用Bellman-Ford算法。

>其实，Dijkstra无法处理负边的原因是传统的Dijkstra算法在确定一个节点的最短距离后就不在修改，而存在负边的图中可能未来会发现更短的距离。因此，实际上只要不存在负环，那么堆优化的Dijksra是可以计算出最短距离的，因为使用堆优化的版本中同一个节点可能多次入队列。我们只需要记录每个节点的入队次数，如果大于n，那么说明存在负环，则不存在最短路。



### 任意两点间的最短路问题

#### Floyed-Warshell算法

求解所有两点间的最短路的问题叫做任意两点间的最短路问题。让我们试着用DP来求解任意两点间的最短路问题。只使用顶点0~k和i，j的情况下，记i到j的最短路长度为d\[k+1\]\[i\]\[j\]。K=-1时，认为只使用i和j，所以d\[0\]\[i\]\[j\]=cost\[i\]\[j\]。接下来让我们把只使用顶点0~k的问题归约到只使用0~k-1的问题上。

只使用0~k时，我们分i到j的最短路正好经过顶点k一次和完全不经过顶点k两种情况来讨论。不经过顶点k的情况下，d\[k\]\[i\]\[j\]=d\[k-1\]\[i\]\[j\]。通过顶点k的情况下，d\[k\]\[i\]\[j\]=d\[k-1\]\[i\]\[k\]+d\[k-1\]\[k\]\[j\]。合起来，就得到了d\[k\]\[i\]\[j\]=min(d\[k-1\]\[i\]\[j\],d\[k-1\]\[i\]\[k\]+d\[k-1\]\[k\]\[j\])。

其实，上面的DP过程可以节省一维空间。因为在更新过程中，d的值都是在不断变小的，因此如果我们在k更新时在原数组上操作，也是不影响结果的。

这就是Floyed-Warshell算法，可以在O(V^3)的时间里求的所有两点间的最短路长度。要判断图中是否有负圈，只需要检查是否存在d\[i\]\[i\]是负数即可。

```c++
int d[MAX_V][MAX_V];
int v;

void floyed_warshell()
{
	for(int k=0; k<V; k++)
	{
		for(int i=0; i<V; i++)
		{
			for(int j=0; j<V; j++)
			{
				d[i][j] = min(d[i][j], d[i][k]+d[k][j]);
			}
		}
	}
}
```





### 最小生成树 Minimum Spanning Tree

给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫做生成树（Spanning Tree)。如果边上有权值，那么使得边权和最小的生成树叫做最小生成树(MST, Minimum Spanning Tree)。

#### Prim 算法

首先我们介绍Prim算法。Prim算法和Dijkstra算法十分相似，都是从某个顶点出发，不断添加边的算法。

首先，我们假设有一棵只包含一个顶点v的树T。然后贪心地选取T和其他顶点之间相连的最小权值的边，并把它加到T中。不断进行这个操作，就可以得到一棵生成树了。


```c++
typedef pair<int, int> P;
static const int MAX_V = 101;
static const int INF = INT_MAX;

int cost[MAX_V][MAX_V];
int d[MAX_V];
int V;

int prim()
{
    priority_queue<P, vector<P>, greater<P> > que;
    fill(d, d+V, INF);
    d[0] = 0;
    int res = 0;
    que.push(P(0, 0));
    while(!que.empty())
    {
        P p = que.top();
        que.pop();
        int dis = p.first;
        int from = p.second;
        if(d[from]<dis)
            continue;
        d[from] = 0;
        res += dis;
        for(int i=0; i<V; i++)
        {
            if(d[i]>cost[from][i])
            {
                d[i] = cost[from][i];
                que.push(P(d[i], i));
            }
        }
    }
    return res;
}
```



#### Kruskal算法

下面我们介绍Kruskal算法。Kruskal算法按照边的权值的顺序从小到大查看一遍，如果不产生圈(重边等也算在内),就把当前这条边加入到生成树中。可以使用并查集高效判断两个顶点是否属于一个连通分量。

Kruskal算法在边的排序上最费时，算法的复杂度是O(ElogV)。

```c++
struct edge
{
    int from;
    int to;
    int cost;
};
vector<edge> es;
int V;
int par[N];

int Find(int x) {
    if(par[x] == x)
        return x;
    return par[x] = Find(par[x]);
}

int Union(int a, int b){
    int apar = Find(a);
    int bpar = Find(b);
    par[apar] = bpar;
}

bool Same(int a, int b){
    return Find(a) == Find(b);
}

static bool cmp(const edge&a , const edge&b){
    return a.cost < b.cost;
}

int kruskal(){
    for(int i=0; i<V; i++){
        par[i] = i;
    }
    sort(es.begin(), es.end(), cmp);
    int n = 1;
    int size = es.size();
    int res = 0;
    for(int i = 0; i < size; i++) {
        if(Same(es[i].from, es[i].to) == false)
        {
            Union(es[i].from, es[i].to);
            res += es[i].cost;
            n++;
        }
    }
    if(n < V)
        return -1;
    return res;
}
```



### 最大权值森林问题

需要征募女兵 N人，男兵 M人。每征慕一个人需要花费10000美元。但是如果已经征慕的人中有一些关系亲密的人，那么可以少花一些钱。给出若干的男女之间的 1~9999 之间的亲密度关系，征慕某个人的费用是10000-（已经征慕的人中和自己的亲密度的最大值)。要求通过适当的征募顺序使得征募所有人所需费用最小。

让我们设想一下这样一个无向图：在征募某个人a时，如果使用了a和b之间的关系，那么就连一条a到b的边。假设这个图中存在圈，那么无论以什么顺序征募这个圈上的所有人，都会产生矛盾。因此可以知道这个图是一片森林。反之，如果给了一片森林那么就可以使用对应的关系确定征募的顺序。

因此，把人看作顶点，关系看作边，这个问题就可以转化为求解无向图中的最大权森林问题。最大权森林问题可以通过把所有边权取反之后用最小生成树的算法求解。

总结一下，最大权值森林问题，就是在一个图中，存在若干边，我们要选择一些边，在不造成环的前提下，使得边的权值的和最大。因此，在图中的每个联通分量，如果有n个顶点，我们最多选择n-1条边。实际上，只要不存在权值为负的边，我们一定会选择n-1条边，因为如果选择了少于n-1条边，说明我们可以再添加边，而不构成环，使得权值总和变大。于是，最终答案就是每个联通分量的最大生成树的权值总和。

在求联通分量的最大生成树时，可以将最小生成树算法修改为每次选取权值最大的边。也可以直接将所有权值取相反数，然后利用最小生成树算法。另外需要注意，kruskal算法在图不连通的情况下，会将每个联通分量构建各自的最小生成树。





## 差分约束系统

如果一个系统由n个变量和m个约束条件组成，形成m个形如$a_i-a_j≤k$的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。

求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。

我们把每个变量想像成一个顶点，除此之外，再构造一个超级源点，超级源点到每个顶点都有一条长度未知的边，每个变量的值就是对应顶点到超级源点的最短距离。因此，随着每个顶点到超级源点的边长度的变化，变量的值也会变化。

考虑约束条件$a_i-a_j≤k$，变形为$a_i≤a_j+k$。这意味着在我们构造的图中，顶点i到超级源点的距离小于等于顶点j到超级源点的距离+k。为了满足这个约束条件，我们可以从顶点i向顶点j连一条长度为k的有向边，那么顶点i到超级源点的距离一定小于等于从i到j再到源点的长度。

添加约束条件后，如果我们要求$a_i-a_j$的最大值，那么就是要根据已有的约束条件推导出$a_i-a_j<=x$，也就是$a_i≤a_j+x$。显然，x就是从顶点i到顶点j的最短距离（在没有超级源点的图上）。这可以使用最短路算法求解。注意，如果约束条件中的x是负值，那么边权就也是负值，此时在计算最短路时就需要判断图中是否存在负环，如果存在，则没有符合条件的解。

如果要求的是$a_i-a_j$的最小值，也就是$a_i+(-x)≥a_j$，那么-x就是从j到i的最短距离。

最终，如果图中有负环，则说明不等式自相矛盾，无解。如果不可达，则说明没有该限制。



















