# Leetcode 300-399

[TOC]



## 300.最长递增子序列

>给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
>**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
>
>- `1 <= nums.length <= 2500`
>- `-10^4 <= nums[i] <= 10^4`

方法一：动态规划

定义 $dp[i]:=以nums[i]结尾的最长上升子序列的长度$ 。则有 $dp[i]=max\{1, dp[j]+1|j<i且nums[j]<nums[i\}$ 。

时间复杂度 $O(n^2)$ 。

方法二：贪心+二分查找

仔细思考我们就能发现，在dp时我们不需要维护每个元素结尾的最长子序列的长度。因为如果有两个长度相同的上升子序列，那么只有末尾元素更小的序列才有被后续元素扩展的价值。因此，我们可以维护每个长度的上升子序列的末尾元素的最小值，定义：
$$
\begin{equation*}
dp[i]:=长度为i+1的上升子序列的末尾元素的最小值
\end{equation*}
$$
们来看看如何更新这个数组。最开始全部dp数组的值都初始化为INF。然后由前到后逐个考虑数列a的元素，对于每个$a_i$，找到dp数组中第一个大于等于 $a_i$的数字进行更新。最终找出使得 $dp[i]<INF$ 的最大的 $i$ 就是结果了。

这个DP直接实现的话，能够与前面的方法一样在 $O(n^2)$ 的时间内给出结果。但这一算法还可以更高效的实现。首先dp数列中除INF之外是单调递增的，所以可以知道对于每个 $a_i$ 最多只需要1次更新。对于这次更新究竟应该在什么位置，不必逐个遍历，可以利用二分搜素，这样就可以在 $O(nlogn)$ 时间内求出结果。

时间复杂度 $O(nlogn)$ 。

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> increasingSub(nums.size());
        for(int i=0; i<nums.size(); i++)
            increasingSub[i] = INT_MAX;
        for(int i=0; i<nums.size(); i++)
        {
            *lower_bound(increasingSub.begin(), increasingSub.end(), nums[i]) = nums[i];
        }
        return lower_bound(increasingSub.begin(), increasingSub.end(), INT_MAX)-increasingSub.begin();
    }
};
```



## 310.最小高度树

>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，任何一个没有简单环路的连通图都是一棵树。
>
>给你一棵包含 `n` 个节点的树，标记为 `0` 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条无向边。
>
>可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为 **最小高度树** 。
>
>请你找到所有的 **最小高度树** 并按 **任意顺序** 返回它们的根节点标签列表。
>
>树的 **高度** 是指根节点和叶子节点之间最长向下路径上边的数量。
>
>- `1 <= n <= 2 * 104`
>- `edges.length == n - 1`
>- `0 <= ai, bi < n`
>- `ai != bi`
>- 所有 `(ai, bi)` 互不相同
>- 给定的输入 **保证** 是一棵树，并且 **不会有重复的边**

BFS。两次BFS找到一条直径的两个端点和直径长度，则最小高度树的根节点就是直径的中点。参考树的直径。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    struct Edge {
        int to;
    };

    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        vector<vector<Edge>> G(n, vector<Edge>());
        for(int i=0; i<n-1; i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            G[from].push_back({to});
            G[to].push_back({from});
        }
        int node = 0;
        queue<int> que;
        vector<bool> visit(n, false);
        visit[0] = true;
        que.push(node);
        int cnt = 0;
        while(cnt+que.size()<n) {
            cnt += que.size();
            int layer = que.size();
            for(int i=0; i<layer; i++) {
                int cur = que.front();
                que.pop();
                visit[cur] = true;
                for(int j=0; j<G[cur].size(); j++) {
                    if(visit[G[cur][j].to]) {
                        continue;
                    }
                    que.push(G[cur][j].to);
                }
            }
        }
        int root = que.front();
        vector<int> par(n, 0);
        for(int i=0; i<n; i++) {
            visit[i] = false;
        }
        while(!que.empty()) {
            que.pop();
        }
        que.push(root);
        visit[root] = true;
        cnt = 0;
        int height = 0;
        while(cnt+que.size()<n) {
            ++height;
            cnt += que.size();
            int layer = que.size();
            for(int i=0; i<layer; i++) {
                int cur = que.front();
                que.pop();
                visit[cur] = true;
                for(int j=0; j<G[cur].size(); j++) {
                    if(visit[G[cur][j].to]) {
                        continue;
                    }
                    que.push(G[cur][j].to);
                    par[G[cur][j].to] = cur;
                }
            }
        }
        node = que.front();
        for(int i=0; i<height/2; i++) {
            node = par[node];
        }
        if(height%2==0) {
            return {node};
        } else {
            return {node, par[node]};
        }
    }
};
```





## 313.超级丑数

>**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。
>
>给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数** 。
>
>题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内。
>
>- `1 <= n <= 10^5`
>- `1 <= primes.length <= 100`
>- `2 <= primes[i] <= 1000`
>- 题目数据 **保证** `primes[i]` 是一个质数
>- `primes` 中的所有值都 **互不相同** ，且按 **递增顺序** 排列

动态规划。此题是和264题的推广，只需要把指数数组换成给定的primes即可。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        int k = primes.size();
        vector<int> pointer(k, 0);
        vector<ll> nxt(k);
        vector<ll> uglyNumbers(n);
        
        uglyNumbers[0] = 1;
        for(int i=1; i<n; i++)
        {
            ll num=LONG_LONG_MAX;
            for(int j=0; j<k; j++)
            {
                nxt[j] = uglyNumbers[pointer[j]]*primes[j];
            }
            uglyNumbers[i] = *min_element(nxt.begin(), nxt.end());
            for(int j=0; j<k; j++)
            {
                if(uglyNumbers[i]==nxt[j])
                    pointer[j]++;
            }
        }
        return uglyNumbers[n-1];
    }
};
```







## 316.去除重复字母

>给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。
>
>- `1 <= s.length <= 10^4`
>- `s` 由小写英文字母组成

使用一个单调栈维护保留下来的字母。当遇到一个新的字符s[i]：

+ 如果s[i]已经在栈中出现了，那么直接舍弃该s[i]；
+ 如果s[i]不在栈中，那么s[i]在本回合中是一定要加到栈中的。但是如果栈顶的元素比s[i]大，而且在字符串s[i+1:]中还有该元素，那么就可以将栈顶弹出。反复操作直到栈为空或者栈顶小于s[i]，然后将s[i]入栈。





## 321.拼接最大数

>给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。
>
>求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。
>
>**说明:** 请尽可能地优化你算法的时间和空间复杂度。

为了找到长度为 k 的最大数，需要从两个数组中分别选出最大的子序列，这两个子序列的长度之和为 k，然后将这两个子序列合并得到最大数。

枚举从第一个数组中取出x个数，从第二个数组中取出k-x个数的所有情况。于是有：
$$
\begin{equation*}
max(0,k-nums2.size())≤x≤min(num1.size(),k)
\end{equation*}
$$
在枚举过程中维护使得最终结果最大的串即可，该层枚举循环复杂度为k。

对于每种情况，需要两步得到结果：

1. 用单调栈实现。从一个数组中取出x个数，保持它们的相对顺序，使得字典序最大。分别从nums1中取x个，从nums2中取k-x个，得到两个子序列。该步骤的复杂度为m+n。
2. 将两个子序列合并为长度为k的数组，但来自相同数组的元素之间的相对位置不变。由于该步骤中每次从两个序列取一个数都要进行一次串比较，每次串比较复杂度为k，总共进行k次，所以该步骤复杂度为k^2。

综上，复杂度为 $O(k(m+n+k^2))$ 。



## 322.零钱兑换

>给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
>计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
>你可以认为每种硬币的数量是无限的。
>
>- `1 <= coins.length <= 12`
>- `1 <= coins[i] <= 231 - 1`
>- `0 <= amount <= 104`

动态规划。

时间复杂度 $O(Sn)$ 。

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<int> dp(amount+1, -1);
        dp[0] = 0;
        for(int i=1; i<=amount; i++) {
            for(int j=0; j<n; j++) {
                if(i-coins[j]>=0 && dp[i-coins[j]]!=-1) {
                    if(dp[i]==-1) {
                        dp[i] = dp[i-coins[j]]+1;
                    } else {
                        dp[i] = min(dp[i], dp[i-coins[j]]+1);
                    }
                }
            }
        }
        return dp[amount];
    }
};
```





## 329.矩阵中的最长递增路径

>给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。
>
>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（不允许环绕）。
>
>- `m == matrix.length`
>- `n == matrix[i].length`
>- `1 <= m, n <= 200`
>- `0 <= matrix[i][j] <= 2^31 - 1`

方法一：记忆化DFS

定义 $dp[i][j]:=以matrix[i][j]作为结束节点的最长递增路径的长度$ 。我们遍历矩阵，对于节点 $matrix[i][j]$ ，先对它的4个邻居中小于 $matrix[i][j]$ 的节点进行DFS搜索，得到它们的 $dp$ 值，然后更新当前节点的 $dp[i][j]$ 。在搜索过程中，使用 $bool$ 数组 $visited[i][j]$ 记录该节点是否完成DFS搜索。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    typedef pair<int,int> P;
    static const int N=210;
    bool visited[N][N];
    int dp[N][N];
    P directions[4]={P(-1,0),P(0,-1),P(0,1),P(1,0)};
    int m, n;
    void dfs(vector<vector<int>>& matrix, int x, int y)
    {
        if(visited[x][y])
            return;
        dp[x][y] = 1;
        for(int i=0; i<4; i++)
        {
            P pair = directions[i];
            int nx, ny;
            nx = x+pair.first;
            ny = y+pair.second;
            if(nx>=0 && nx<m && ny>=0 && ny<n && matrix[nx][ny]<matrix[x][y])
            {
                if(visited[nx][ny])
                    dp[x][y] = max(dp[x][y], dp[nx][ny]+1);
                else
                {
                    dfs(matrix, nx, ny);
                    dp[x][y] = max(dp[x][y], dp[nx][ny]+1);
                }
            }
        }
        visited[x][y] = true;
    }

    int longestIncreasingPath(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(visited[i][j]==false)
                    dfs(matrix, i, j);
            }
        }
        int ret=0;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                ret = max(ret, dp[i][j]);
            }
        }
        return ret;
    }
};
```

方法二：拓扑排序

将矩阵看成一个有向图，计算每个单元格对应的出度，即有多少条边从该单元格出发。对于作为边界条件的单元格，该单元格的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都是 0。

基于出度的概念，可以使用拓扑排序求解。从所有出度为 0 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，去掉该单元格，更新其余单元格的出度，并将出度变为 0 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    static const int N=210;
    typedef pair<int, int> P;
    P directions[4]={P(-1,0),P(0,-1),P(0,1),P(1,0)};
    int outdegree[N][N];
    int longestIncreasingPath(vector< vector<int> > &matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                for(int k=0; k<4; k++)
                {
                    P direction = directions[k];
                    int nx = i+direction.first;
                    int ny = j+direction.second;
                    if(nx>=0 && nx<m && ny>=0 && ny<n)
                    {
                        if(matrix[nx][ny]>matrix[i][j])
                            outdegree[i][j]++;
                    }
                }
            }
        }
        queue<P> que;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(outdegree[i][j]==0)
                    que.push(P(i,j));
            }
        }
        int ret=0;
        while(!que.empty())
        {
            ret++;
            int sz = que.size();
            while(sz--)
            {
                P pos = que.front();
                que.pop();
                int x = pos.first;
                int y = pos.second;
                for(int k=0; k<4; k++)
                {
                    P direction = directions[k];
                    int nx = x+direction.first;
                    int ny = y+direction.second;
                    if(nx>=0 && nx<m && ny>=0 && ny<n)
                    {
                        if(matrix[nx][ny]<matrix[x][y])
                        {
                            outdegree[nx][ny]--;
                            if(outdegree[nx][ny]==0)
                                que.push(P(nx,ny));
                        }                                                        
                    }
                }
            }
        }
        return ret;
    }
};
```







## 330.按要求补齐数组

>给定一个已排序的正整数数组 `nums` *，*和一个正整数 `n` *。*从 `[1, n]` 区间内选取任意个数字补充到 nums 中，使得 `[1, n]` 区间内的任何数字都可以用 nums 中某几个数字的和来表示。
>
>- `1 <= nums.length <= 1000`
>- `1 <= nums[i] <= 10^4`
>- `nums` 按 **升序排列**
>- `1 <= n <= 2^31 - 1`

不断找到序列nums不能表示的最小的数x，则[1,x-1]之间的数都可以表示。此时我们为了表示x，必须添加一个小于等于x的数。下面证明贪心地添加x是最优策略。

> 先澄清一个观点：假设有一个数组A,由A中元素的和可以表示的所有数构成集合 $\{a_1,a_2,\cdots,a_n\}$，那么如果向数组A添加一个元素b，则新的数组可以表示的所有数的集合为 $\{a_1,a_2,\cdots,a_n,a_1+b,a_2+b,\cdots,a_n+b\}$ 去掉重复元素后的集合。

首先，nums中必须要有1，因为1只能由它本身表示。

现在定义数组A={1}，A中元素可以表示的数字的集合称为B。我们逐步将nums中的元素添加到A中。一开始A=B={1}。记B中最大元素为 $B_{max}$ ，B是从1至$B_{max}$的数字构成的集合，即$B=\{1,2,\cdots,B_{max}\}$。记下一个从nums中取出的数字为 $nums_{next}$ 。

+ 当 $nums_{next}≤B_{max}+1$ 时：直接将 $nums_{next}$ 加入A，则B变为 $\{1,2,\cdots,B_{max}+nums_{next}\}$ 。显然B仍然是由从1到最大元素之间所有数字构成的集合。

+ 当 $nums_{next}>B_{max}+1$ 时：由于nums数组是有序的，所以之后从nums取出的数字均大于 $B_{max}+1$ ，所以从nums中取出的数字将永远无法表示 $B_{max}+1$ ，我们必须向nums中添加一个小于等于 $B_{max}+1$ 的元素。此时有两种选择：

    + 添加 $x=B_{max}+1$ 。此时 $B_x=\{1,2,\cdots,B_{max}+1,B_{max}+2,\cdots,B_{max}+B_{max}+1\}$。
    + 添加 $y<B_{max}+1$ 。此时 $B_y=\{1,2,\cdots,B_{max}+1,B_{max}+2,\cdots,B_{max}+y\}$。

    显然，$B_y \subset B_x$ , 且后续向A中添加任何元素，都仍然有$B_y \subset B_x$ 。因此，选择向A中添加x一定是最优策略。添加完成后，集合B仍然是从1至$B_{max}$的数字构成的集合。

复杂度：$O(m+logn)$，其中*m*是数组nums的长度，*n*是给定的正整数。

```c++
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        int sz = nums.size();
        long long int sumMax = 0;
        int idx=0;
        int ret=0;
        while(sumMax<n)
        {
            if(idx<sz && nums[idx]<=sumMax+1)
            {
                sumMax += nums[idx];
                idx++;
            }
            else
            {
                sumMax = sumMax*2+1;
                ret++;
            }
        }
        return ret;
    }
};
```



## 332.重新安排行程

>给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
>
>所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
>
>- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。
>
>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
>
>- `1 <= tickets.length <= 300`
>- `tickets[i].length == 2`
>- `fromi.length == 3`
>- `toi.length == 3`
>- `fromi` 和 `toi` 由大写英文字母组成
>- `fromi != toi`

欧拉路径。可以用Hierholzer算法。

这里需要注意的是，为了保证所得方案是所有可能方案中字典序最小的，那么在dfs遍历时就可以优先选择当前节点的字典序最小的出边即可。因此我们可以用最小堆来维护一个节点的出边。

时间复杂度 $O(mlogm)$ 。m是边的条数。

```c++
class Solution {
public:
    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> edges;
    
    void hierholzer(string cur, vector<string>& stk) {
        while(edges.count(cur) > 0 && edges[cur].size() > 0) {
            string branch = edges[cur].top();
            edges[cur].pop();
            hierholzer(branch, stk);
        }
        stk.push_back(cur);
    }

    vector<string> findItinerary(vector<vector<string>>& tickets) {
        vector<string> stk;
        for(vector<string>& ticket : tickets) {
            string& from = ticket[0];
            string& to = ticket[1];
            edges[from].push(to);
        }

        hierholzer("JFK", stk);

        reverse(stk.begin(), stk.end());
        return stk;
    }
};
```





## 334.递增的三元子序列

>给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。
>
>如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。
>
>- `1 <= nums.length <= 5 * 10^5`
>- `-2^31 <= nums[i] <= 2^31 - 1`

遍历一次数组，维护最小元素和长度为2的递增子序列的末尾的最小值。复杂度 $O(n)$ 。







## 338.比特位计数

>给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。
>
>- `0 <= n <= 10^5`

方法一：Brian Kernighan 算法

Brian Kernighan 算法的原理是：对于任意整数 x，令 x=x & (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。如此一来，反复调用Kernighan算法，调用次数就是x中1的个数。

时间复杂度 $O(nlogn)$ 。

```c++
class Solution {
public:
    int countOnes(int x)
    {
        int ret=0;
        while(x>0)
        {
            x = x&(x-1);
            ret++;
        }
        return ret;
    }

    vector<int> countBits(int n) {
        vector<int> ret(n + 1);
        for (int i = 0; i <= n; i++) {
            ret[i] = countOnes(i);
        }
        return ret;
    }
};
```



方法二：动态规划（最高有效位）

其实，对于x，将它的任意一个1比特位置为0得到的数都小于x，设为y，则显然x的比特数比y多1。因此，我们可以使用动态规划。下面我们通过将最高有效位置为0来得到当前的比特数。

遍历从0到n，对于x，如果 $x\&(x-1)==0$ ，那么说明需要更新最高有效位。设最高有效位表示的数字为 $high$ ，则有 $y=x-high$ 。于是 $dp[x] = dp[y]+1$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ret(n+1);
        int high = 0;
        for(int i=1; i<=n; i++)
        {
            if((i&(i-1))==0)
            {
                high = i;
            }
            ret[i] = ret[i-high]+1;
        }
        return ret;
    }
};
```

方法三：动态规划（最低有效位）

上面的方法二是通过最高位动态规划的，其实也可以通过最低位。使用Brian Kernighan算法直接将最低位的1置为0。则有 $y=x\&(x-1)$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ret(n+1);
        for (int i=1; i<=n; i++) 
        {
            ret[i] = ret[i&(i-1)] + 1;
        }
        return ret;
    }
};
```

方法四：动态规划（最低位）

还有一种不考虑有效位的算法，只需要考虑最低位是否为1。设将x右移一位得到y，那么只需要知道x的最低位是否1，再加上y中1的比特位即可。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ret(n+1);
        for (int i=1; i<=n; i++) 
        {
            ret[i] = ret[i>>1] + (i&1);
        }
        return ret;
    }
};
```





## 343.整数拆分

>给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。
>
>返回 *你可以获得的最大乘积* 。
>
>- `2 <= n <= 58`

数学方法。尽可能的拆分出3，如果最后还剩1，那么就取出一个3，和1凑成两个2。这样的策略可以得到最大乘积。证明略。

时间复杂度 $O(1)$ 。

```c++
class Solution {
public:
    int integerBreak(int n) {
        if(n==2)
            return 1;
        if(n==3)
            return 2;

        int exp = n/3;
        int mod = n%3;
        if(mod==0)
        {
            mod = 1;
        }
        else if(mod==1)
        {
            exp--;
            mod = 4;
        }
        return pow(3, exp)*mod;
    }
};
```



## 347.前K个高频元素

>给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
>
>- `1 <= nums.length <= 10^5`
>- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
>- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

优先队列。

时间复杂度 $O(nlogk)$ 。

```c++
class Solution {
public:
    typedef pair<int, int> P;
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        int n = nums.size();
        for(int i=0; i<n; i++) {
            mp[nums[i]]++;
        }
        priority_queue<P, vector<P>, greater<P> > que;
        
        unordered_map<int, int>::iterator it = mp.begin();
        while(it!=mp.end()) {
            P p;
            p.first = it->second;
            p.second = it->first;
            if(que.size()<k) {
                que.push(p);
            } else if(que.size()==k && que.top().first<p.first) {
                que.pop();
                que.push(p);
            }
            it++;
        }
        vector<int> ret;
        while(!que.empty()) {
            ret.push_back(que.top().second);
            que.pop();
        }
        return ret;
    }
};
```





## 354.俄罗斯套娃信封问题

>给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。
>
>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>
>请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>
>**注意**：不允许旋转信封。
>
>- `1 <= envelopes.length <= 10^5`
>- `envelopes[i].length == 2`
>- `1 <= wi, hi <= 10^5`

排序+动态规划。

首先考虑信封的宽度全都互异的情况。我们先按照宽度将信封排序，然后按顺序取信封，此时宽度一定是满足要求的，即后面的信封的宽度一定大于之前的信封。于是我们只需要求信封高度的严格递增子序列。这就是最长递增子序列(LIS)问题。

现在考虑当两个信封的宽度相同时，后面的信封不能装下前面的信封。显然对于宽度相同的信封，我们最终最多只取其中的一个。即我们要保证不会将宽度相同的信封加入同一个LIS。我们可以将高度作为排序的第二关键字进行降序排序，这样一来，对于每一种宽度，其对应的信封在排序后的数组中是按照高度递减的顺序出现的，那么这些高度值不可能组成长度超过 1 的严格递增序列，这就避免了出现上述的错误。

时间复杂度 $O(nlogn)$ 。

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b)
    {
        if(a[0]==b[0])
            return a[1]>b[1];
        return a[0]<b[0];
    };
    static const int INF=INT_MAX;
    static const int N=1e5+10;
    int dp[N];
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        sort(envelopes.begin(), envelopes.end(), cmp);
        int sz = envelopes.size();
        for(int i=0; i<N; i++)
            dp[i] = INF;

        for(int i=0; i<sz; i++)
        {
            *lower_bound(&dp[0], &dp[N], envelopes[i][1]) = envelopes[i][1];
        }
        return lower_bound(&dp[0], &dp[N], (int)INT_MAX)-&dp[0];
    }
};
```





## 357.统计各位数字都不同的数字个数

>给你一个整数 `n` ，统计并返回各位数字都不同的数字 `x` 的个数，其中 `0 <= x < 10^n` 。
>
>- `0 <= n <= 8`

排列组合。

考虑各位数字都不同的y位数。第一位有1-9共9种选择，剩下的y-1位每一位都有9种选择（即0-9中去掉第一位的数字），但这些y-1位需要互不相同，这就是  $A^9_{y-1}$  。于是我们可以先使用动态规划计算出所有的排列组合数。

时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    static const int N=10;
    ll Comb[N][N];
    ll factorial[N];
    void init()
    {
        for(int i=0; i<N; i++)
        {
            Comb[i][0] = 1;
            for(int j=1; j<=i; j++)
            {
                Comb[i][j] = Comb[i-1][j]+Comb[i-1][j-1];
            }
        }
        factorial[0] = 1;
        for(int i=1; i<N; i++)
            factorial[i] = factorial[i-1]*i;
    }

    int countNumbersWithUniqueDigits(int n) {
        init();
        int ret=1;
        for(int i=1; i<=n; i++)
        {
            ret += 9*Comb[9][i-1]*factorial[i-1];
        }
        return ret;
    }
};
```





## 368.最大整除子集

>给你一个由 **无重复** 正整数组成的集合 `nums` ，请你找出并返回其中最大的整除子集 `answer` ，子集中每一元素对 `(answer[i], answer[j])` 都应当满足：
>
>- `answer[i] % answer[j] == 0` ，或
>- `answer[j] % answer[i] == 0`
>
>如果存在多个有效解子集，返回其中任何一个均可。
>
>- `1 <= nums.length <= 1000`
>- `1 <= nums[i] <= 2 * 10^9`
>- `nums` 中的所有整数 **互不相同**

动态规划。

对于一个整除子集，如果把其中的数字从小到大排列，并将每个数分解质因数，那么排在前面的数的质因数一定是排在后面的数的质因数的子集。很容易想到先将nums从小到大排序，然后遍历nums求解。

定义 $dp[i]:=由排序后的nums[0]到nums[i]的数字组成的集合中，包含nums[i]的最大整除子集的大小$ 。

那么就有：
$$
\begin{equation*}
dp[i]=max\{dp[j]|0≤j<i且nums[i]\%nums[j]=0\}+1
\end{equation*}
$$
由于最终需要返回的是整除子集，而不是它的大小，我们使用另一个数组追踪动态规划的路径。

时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    static const int N=1e3+10;
    int dp[N];
    int trace[N];
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        for(int i=0; i<nums.size(); i++)
        {
            dp[i] = 1;
            for(int j=0; j<i; j++)
            {
                if((nums[i]%nums[j]==0) && (dp[i]<dp[j]+1))
                {
                    dp[i] = dp[j]+1;
                    trace[i] = j;
                }
            }
            if(dp[i]==1)
                trace[i] = -1;
        }
        int idx = max_element(&dp[0], &dp[0]+nums.size())-&dp[0];
        vector<int> ret;
        while(trace[idx]!=-1)
        {
            ret.push_back(nums[idx]);
            idx = trace[idx];
        }
        ret.push_back(nums[idx]);
        return ret;
    }
};
```





## 375.猜数字大小II

>我们正在玩一个猜数游戏，游戏规则如下：
>
>1. 我从 `1` 到 `n` 之间选择一个数字。
>2. 你来猜我选了哪个数字。
>3. 如果你猜到正确的数字，就会 **赢得游戏** 。
>4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
>5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。
>
>给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。
>
>- `1 <= n <= 200`

动态规划。

定义 $dp[i][j]:=从数字i到数字j构成的区间中，确保猜测到数字的最小现金$ 。这样我们需要枚举猜测的第一个数字k，取这些结果中金额最少的情况即可。对于猜测的第一个数字k，我们需要考虑确保猜中的情况下需要的花费，那么显然需要假设k没有猜中，此时有两种选择， 在i到k-1之间继续猜或者在k+1到j之间继续猜，显然为了确保能猜到，我们的花费应该是 $k+max(dp[i][k-1],dp[k+1][j])$ 。

时间复杂度 $O(n^3)$ 。

```c++
class Solution {
public:
    static const int N=210;
    int dp[N][N];
    int getMoneyAmount(int n) {
        for(int length=2; length<=n; length++)
        {
            for(int start=1; start<=n; start++)
            {
                int end=start+length-1;
                if(end>n)
                    break;
                dp[start][end] = min(start+dp[start+1][end], end+dp[start][end-1]);
                for(int k=start+1; k<end; k++)
                {
                    dp[start][end] = min(dp[start][end],k+max(dp[start][k-1],dp[k+1][end]));
                }
            }
        }
        printf("%d", dp[2][5]);
        return dp[1][n];
    }
};
```





## 376.摆动序列

>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
>- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
>- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
>**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
>给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。
>
>- `1 <= nums.length <= 1000`
>- `0 <= nums[i] <= 1000`

遍历一次数组，维护当前序列尾和最后一段的摆动方向。如果新添加元素的摆动方向与最后一段的摆动方向相同，那么就只更新序列尾的大小，如果新添加元素的摆动方向与最后一段的摆动方向相反，就更新序列尾和摆动方向，同时结果长度加一。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int sz = nums.size();
        if(sz<=1)
            return sz;
        if(sz==2)
        {
            if(nums[0]==nums[1])
                return 1;
            else 
                return 2;
        }
        int cnt=1;
        int cur=nums[0];
        int direction=0;
        for(int i=1; i<sz; i++)
        {
            if(nums[i]>cur)
            {
                cur = nums[i];
                if(direction==0 || direction==-1)
                {
                    direction=1;
                    cnt++;
                }
            }
            else if(nums[i]<cur)
            {
                cur = nums[i];
                if(direction==0 || direction==1)
                {
                    direction=-1;
                    cnt++;
                }
            }
        }
        return cnt;
    }
};
```





## 377.组合总和IV

>给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums`中找出并返回总和为 `target` 的元素组合的个数。
>
>题目数据保证答案符合 32 位整数范围。
>
>- `1 <= nums.length <= 200`
>- `1 <= nums[i] <= 1000`
>- `nums` 中的所有元素 **互不相同**
>- `1 <= target <= 1000`

动态规划。

定义状态 $dp[i]:=nums中总和为i的元素组合的个数，结果对INT\_MAX取余$ 。

于是有 $dp[i]=\Sigma \{dp[j]|i-nums[j]>=0\}$ 。

时间复杂度 $O(nm)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    static const int N=1e3+10;
    ll dp[N];
    int combinationSum4(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        memset(dp, 0, sizeof(dp));
        for(int i=1; i<=target; i++)
        {
            for(int j=0; j<nums.size(); j++)
            {
                if(i-nums[j]<0)
                    break;
                else if(i-nums[j]==0)
                    dp[i] = (dp[i]+1)%INT_MAX;
                else
                    dp[i] = (dp[i]+dp[i-nums[j]])%INT_MAX;
            }  
        }
        return dp[target];
    }
};
```



## 380.O(1)时间插入、删除和获取随机元素

>实现`RandomizedSet` 类：
>
>- `RandomizedSet()` 初始化 `RandomizedSet` 对象
>- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
>- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false`。
>- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。
>
>你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。
>
>- `-2^31 <= val <= 2^31 - 1`
>- 最多调用 `insert`、`remove` 和 `getRandom` 函数 `2 * ``10^5` 次
>- 在调用 `getRandom` 方法时，数据结构中 **至少存在一个** 元素。

普通的哈希表可以实现常数时间插入和删除元素，但是无法常数时间随机获取元素。但是变长数组可以常数时间随机获取元素，只需要生成一个随机数当作下标，返回下标位置的值即可。因此，我们可以用一个变长数组和一个哈希表来实现这个数据结构，哈希表的键是元素值，哈希表的值是元素在变长数组中的索引。当我们要删除元素时，将变长数组的最后一个元素覆盖到要删除的元素的位置上即可，同时修改哈希表中该元素的值。

时间复杂度 $O(1)$ 。

```c++
class RandomizedSet {
    vector<int> vec;
    unordered_map<int, int> mp;
public:
    RandomizedSet() {
        srand(time(0));
    }
    
    bool insert(int val) {
        if(mp.count(val)) {
            return false;
        }
        mp[val] = vec.size();
        vec.push_back(val);
        return true;
    }
    
    bool remove(int val) {
        if(mp.count(val)==0) {
            return false;
        }
        int idx = mp[val];
        vec[idx] = vec[vec.size()-1];
        mp[vec[idx]] = idx;
        vec.pop_back();
        mp.erase(val);
        return true;
    }
    
    int getRandom() {
        int idx = rand()%vec.size();
        return vec[idx];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```





## 392.判断子序列

>给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。
>
>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
>
>- `0 <= s.length <= 100`
>- `0 <= t.length <= 10^4`
>- 两个字符串都只由小写字符组成。

双指针。

时间复杂度 $O(m+n)$ 。

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int sidx=0;
        int tidx=0;
        int slen = s.length();
        int tlen = t.length();
        while(sidx<slen)
        {
            while(tidx<tlen && t[tidx]!=s[sidx])
                tidx++;
            if(tidx==tlen)
                break;
            else
            {
                sidx++;
                tidx++;
            }
        }
        return sidx == slen;
    }
};
```



## 394.字符串解码

>给定一个经过编码的字符串，返回它解码后的字符串。
>
>编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。
>
>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
>
>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。
>
>- `1 <= s.length <= 30`
>- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
>- `s` 保证是一个 **有效** 的输入。
>- `s` 中所有整数的取值范围为 `[1, 300]` 

栈。

时间复杂度 $O(S)$， S为解码后的字符串长度。

```c++
class Solution {
public:
    stack<char> stChar;
    stack<int> stInt;

    string decodeString(string s) {
        int length = s.length();
        for(int i=0; i<length; i++)
        {
            if(isdigit(s[i]))
            {
                int num = s[i]-'0';
                while(i+1<length && isdigit(s[i+1]))
                {
                    i++;
                    num = num*10+s[i]-'0';
                }
                stInt.push(num);
            }
            else if(s[i]=='[')
            {
                stChar.push(s[i]);
            }
            else if(s[i]==']')
            {
                string temStr;
                while(stChar.top()!='[')
                {
                    temStr.append(1, stChar.top());
                    stChar.pop();
                }
                stChar.pop();
                int num = stInt.top();
                stInt.pop();
                reverse(temStr.begin(), temStr.end());
                for(int j=0; j<num; j++)
                {
                    int temStrLength = temStr.length();
                    for(int k=0; k<temStrLength; k++)
                    {
                        stChar.push(temStr[k]);
                    }
                }
            }
            else
            {
                stChar.push(s[i]);
            }
        }
        string ret;
        while(!stChar.empty())
        {
            ret.append(1, stChar.top());
            stChar.pop();
        }
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```





## 396.旋转函数

>给定一个长度为 `n` 的整数数组 `nums` 。
>
>假设 `arrk` 是数组 `nums` 顺时针旋转 `k` 个位置后的数组，我们定义 `nums` 的 **旋转函数** `F` 为：
>
>- `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`
>
>返回 *`F(0), F(1), ..., F(n-1)`中的最大值* 。
>
>生成的测试用例让答案符合 **32 位** 整数。
>
>- `n == nums.length`
>- `1 <= n <= 10^5`
>- `-100 <= nums[i] <= 100`

动态规划。

定义 $dp[i]:=F(i)$ 。首先我们可以求出F(0)，然后通过递推关系求出F(1)到F(n-1)。我们发现，$dp[i]与dp[i-1]$ 的区别是，旋转一个位置会导致前n-1个数的系数增1，而最后一个数的系数变为0。因此，只需要在 $dp[i-1]$ 的基础上加上前n-1个数，再减去n个最后一个数即可得到 $dp[i]$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    static const int N=1e5+10;
    ll dp[N];
    int maxRotateFunction(vector<int>& nums) {
        int sz = nums.size();
        for(ll i=0; i<sz; i++)
            dp[0] = (dp[0]+i*nums[i])%INT_MAX;
        int numsSum=0;
        for(int i=0; i<sz; i++)
            numsSum += nums[i];
        int idx=sz-1;
        for(int i=1; i<sz; i++)
        {
            dp[i] = dp[i-1]-nums[idx]*sz+numsSum;
            idx--;
        }
        ll ret=0;
        return *max_element(&dp[0], &dp[sz]);
    }
};
```





## 397.整数替换

>给定一个正整数 `n` ，你可以做如下操作：
>
>1. 如果 `n` 是偶数，则用 `n / 2`替换 `n` 。
>2. 如果 `n` 是奇数，则可以用 `n + 1`或`n - 1`替换 `n` 。
>
>返回 `n` 变为 `1` 所需的 *最小替换次数* 。
>
>- `1 <= n <= 2^31 - 1`

方法一：BFS

BFS即可。需要注意可以用unoreder_set存储已经入队的元素，就不用将元素重复入队，从而完成记忆化搜索。

时间复杂度 $O(logn)$ 。

```c++
class Solution {
public:

    static unsigned int func(unsigned int num, int var)
    {
        if(num&1)
        {
            if(var==1)
                return num+1;
            else
                return num-1;
        }
        return num>>1;
    }

    int integerReplacement(int n) {
        set<unsigned int> visited;
        if(n==1)
            return 0;
        unsigned int s=n;
        queue<unsigned int> que;
        que.push(s);
        visited.insert(s);
        int cnt=0;
        while(!que.empty())
        {
            cnt++;
            int sz = que.size();
            while(sz--)
            {
                unsigned int num = que.front();
                que.pop();
                int num1 = func(num,1);
                int num2 = func(num,-1);
                if(num1==1 || num2==1)
                    return cnt;
                else
                {
                    if(visited.count(num1)==0)
                        que.push(num1);
                    if(visited.count(num2)==0)
                        que.push(num2);
                    visited.insert(num1);
                    visited.insert(num2);
                }
            }
        }
        return cnt;
    }
};
```

方法二：

实际上，得到最小替换次数的方法是固定的。

+ 当n为偶数时，我们只有唯一的方法将 n 替换为 n/2；

+ 当n为奇数时，n除以4 的余数要么为1，要么为3：

    + 如果为1，我们可以断定，应该将 n变成 (n-1)/2。因为如果我们必须将 n变成 (n+1)/2才能得到最优解，而(n+1)/2是奇数，那么：

        + 如果下一步进行 -1 再除以2，得到(n-1)/4， 那么从 (n-1)/2 可以除以2得到同样的结果；
        + 如果下一步进行 +1 再除以2，得到 (n+3)/4， 那么从 (n-1)/2 可以除以2再+1得到同样的结果。

        因此，将n变为(n-1)/2总是不会劣于(n+1)/2。

    + 如果为3，我们可以断定，应该将 n变成 (n+1)/2。因为如果我们必须将 n变成 (n-1)/2才能得到最优解，而(n-1)/2是奇数，那么：

        + 如果下一步进行 -1 再除以2，得到(n-3)/4， 那么从 (n+1)/2 可以除以2再-1得到同样的结果；
        + 如果下一步进行 +1 再除以2，得到 (n+1)/4， 那么从 (n+1)/2 可以除以2得到同样的结果。

        因此，将n变为(n+1)/2总是不会劣于(n-1)/2。

        这里需要注意如果(n-1)/2已经为1，n=3时，后续就无需任何操作，将n变为(n-1)/2才是最优的。

时间复杂度 $O(logn)$ 。
