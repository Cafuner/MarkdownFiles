# Leetcode 200-299

[TOC]

## 200.岛屿数量

>给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
>此外，你可以假设该网格的四条边均被水包围。
>
>- `m == grid.length`
>- `n == grid[i].length`
>- `1 <= m, n <= 300`
>- `grid[i][j]` 的值为 `'0'` 或 `'1'`

BFS。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:

    typedef pair<int, int> P;
    P directions[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};

    void bfs(vector<vector<char>>& grid, int x, int y, int n, int m) {
        grid[x][y] = 0;
        for(int i=0; i<4; i++) {
            P p = directions[i];
            int nx = x+p.first;
            int ny = y+p.second;
            if(nx<0 || nx>n-1 || ny<0 || ny>m-1) {
                continue;
            }
            if(grid[nx][ny]=='1') {
                bfs(grid, nx, ny, n, m);
            }
        }
    }   

    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int ret = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(grid[i][j]=='1') {
                    bfs(grid, i, j, n, m);
                    ret++;
                }
            }
        }
        return ret;
    }
};
```







## 206. 反转链表

>给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
>- 链表中节点的数目范围是 `[0, 5000]`
>- `-5000 <= Node.val <= 5000`

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode* reverse(ListNode* head) {
        if(head->next == NULL) {
            return head;
        }
        ListNode* tail = head->next;
        ListNode* node = reverse(tail);
        tail->next = head;
        head->next = NULL;
        return node;
    }

    ListNode* reverseList(ListNode* head) {
        if(head==NULL || head->next==NULL) {
            return head;
        }
        ListNode* tail = head->next;
        ListNode* node = reverse(head->next);
        tail->next = head;
        head->next = NULL;
        return node;
    }
};
```



## 207.课程表

>你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>
>在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。
>
>- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>
>请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。
>
>- `1 <= numCourses <= 2000`
>- `0 <= prerequisites.length <= 5000`
>- `prerequisites[i].length == 2`
>- `0 <= ai, bi < numCourses`
>- `prerequisites[i]` 中的所有课程对 **互不相同**

图谱排序。

时间复杂度 $O(n+m)$ 。

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> indegree(numCourses, 0);
        vector<vector<int>> edge(numCourses, vector<int>());

        int n = prerequisites.size();
        for(int i=0; i<n; i++) {
            int course = prerequisites[i][0];
            int pre = prerequisites[i][1];
            indegree[course]++;
            edge[pre].push_back(course);
        }

        queue<int> que;
        for(int i=0; i<numCourses; i++) {
            if(indegree[i]==0) {
                que.push(i);
            }
        }

        int cnt = 0;
        while(!que.empty()) {
            int course = que.front();
            que.pop();
            cnt++;
            vector<int>& vec = edge[course];
            for(int i=0; i<vec.size(); i++) {
                indegree[vec[i]]--;
                if(indegree[vec[i]]==0) {
                    que.push(vec[i]);
                }
            }
        }
        return cnt==numCourses;
    }
};
```





## 208.实现Trie(前缀树)

>**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
>
>请你实现 Trie 类：
>
>- `Trie()` 初始化前缀树对象。
>- `void insert(String word)` 向前缀树中插入字符串 `word` 。
>- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
>- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `true` ；否则，返回 `false` 。
>- `1 <= word.length, prefix.length <= 2000`
>- `word` 和 `prefix` 仅由小写英文字母组成
>- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

字典树。

时间复杂度：每次操作均为 $O(|S|)$ 。

```c++
class Trie {
public:
    Trie* nxt[26];
    bool isEnd;
    Trie() {
        isEnd = false;
        for(int i=0; i<26; i++)
            nxt[i] = nullptr;
    }
    
    void insert(string word) {
        Trie* pTrie = this;
        for(int i=0; i<word.size(); i++)
        {
            if(pTrie->nxt[word[i]-'a']==nullptr)
                pTrie->nxt[word[i]-'a'] = new Trie();
            pTrie = pTrie->nxt[word[i]-'a'];
            if(i==word.size()-1)
                pTrie->isEnd = true;
        }
    }
    
    bool search(string word) {
        Trie* pTrie = this;
        for(int i=0; i<word.size(); i++)
        {
            if(pTrie->nxt[word[i]-'a']==nullptr)
                return false;
            pTrie = pTrie->nxt[word[i]-'a'];
        }
        return pTrie->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* pTrie = this;
        for(int i=0; i<prefix.size(); i++)
        {
            if(pTrie->nxt[prefix[i]-'a']==nullptr)
                return false;
            pTrie = pTrie->nxt[prefix[i]-'a'];
        }
        return true;
    }

    ~Trie()
    {
        for(int i=0; i<26; i++)
        {
            if(nxt[i]!=nullptr)
                delete nxt[i];
        }
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```



## 209.长度最小的子数组

>给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
>找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
>- `1 <= target <= 10^9`
>- `1 <= nums.length <= 10^5`
>- `1 <= nums[i] <= 10^5`

双指针。

维护一个满足条件并且长度最小的区间。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left=0;
        int sum=0;
        int ret = INT_MAX;
        for(int i=0; i<nums.size(); i++)
        {
            sum += nums[i];
            while(sum-nums[left]>=target)
            {
                sum -= nums[left];
                left++;
            }
            if(sum>=target)
                ret = min(ret, i-left+1);
        }
        if(ret == INT_MAX)
            return 0;
        return ret;
    }
};
```





## 213.打家劫舍II

>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。
>
>- `1 <= nums.length <= 100`
>- `0 <= nums[i] <= 1000`

动态规划。此题与198题的区别是房屋成环。可以把这道题分成两道198题，即考虑第1间房：

+ 偷第一间房，那么最终的金额为 $nums[0]+rob(1,size-2)$ 。
+ 不偷第一间房，那么最终的金额为 $rob(1,size-1)$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int robHelper(vector<int>& nums)
    {
        if(nums.size()<=2)
            return *max_element(nums.begin(), nums.end());
        int twoDaysBefore = nums[0];
        int oneDayBefore = max(nums[0], nums[1]);
        int sz = nums.size();
        int today;
        for(int i=2; i<sz; i++)
        {
            today = max(oneDayBefore, twoDaysBefore+nums[i]);
            twoDaysBefore = oneDayBefore;
            oneDayBefore = today;
        }
        return today;
    }

    int rob(vector<int>& nums) {
        if(nums.size()<=3)
            return *max_element(nums.begin(), nums.end());
        vector<int> vec1(nums.begin()+1, nums.end());
        vector<int> vec2(nums.begin()+2, nums.end()-1);
        return max(robHelper(vec1), robHelper(vec2)+nums[0]);
    }
};
```



## 215.数组中的第K个最大元素

>给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。
>
>请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
>
>你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
>- `1 <= k <= nums.length <= 10^5`
>- `-10^4 <= nums[i] <= 10^4`

方法一：

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:

    static bool cmp(int a, int b) {
        return a>b;
    }

    int findKthLargest(vector<int>& nums, int k) {
        nth_element(nums.begin(), nums.begin()+k-1, nums.end(), cmp);
        return nums[k-1];
    }
};
```

方法二：

快速选择

首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：

1. 分解： 将数组 a[l⋯r] 划分成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r]中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。
2. 解决： 通过递归调用快速排序，对子数组 a[l⋯q−1]和 a[q+1⋯r] 进行排序。
3. 合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。

上文中提到的 「划分」 过程是：从子数组 a[l⋯r]中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 

```c++
class Solution {
public:
    // int findKthLargest(vector<int>& nums, int k) {
    //     nth_element(nums.begin(), nums.begin()+k-1, nums.end(), greater<int>());
    //     return nums[k-1];
    // }

    int partition(vector<int>& nums, int left, int right)
    {
        srand(time(0));
        int pivot = rand()%(right-left+1)+left;
        swap(nums[pivot], nums[right]);
        for(int i=left; i<right; i++)
        {
            if(nums[i]>=nums[right])
                swap(nums[i], nums[left++]);
        }
        swap(nums[left], nums[right]);
        return left;
    }

    int quickSelect(vector<int>& nums, int left, int right, int k)
    {
        int pivot = partition(nums, left, right);
        if(pivot == k)
            return nums[k];
        else if(pivot<k)
            return quickSelect(nums, pivot+1, right, k);
        else
            return quickSelect(nums, left, pivot-1, k);
    }

    int findKthLargest(vector<int>& nums, int k)
    {
        k--;
        int size = nums.size();
        return quickSelect(nums, 0, size-1, k);
    }
};
```

```c++
class Solution {
public:
    int partition(vector<int>& nums, int start, int end) {
        if(start==end) {
            return start;
        }
        srand(time(0));
        int select = rand()%(end-start+1)+start;
        swap(nums[select], nums[end]);
        int key = nums[end];
        int left = start;
        int right = end-1;
        while(left<right) {
            while(nums[left]>=key && left<right) {
                left++;
            }
            while(nums[right]<=key && left<right) {
                right--;
            }
            swap(nums[left], nums[right]);
        }
        if(nums[right]>nums[end]) {
            swap(nums[right+1], nums[end]);
            return right+1;
        }
        swap(nums[right], nums[end]);
        return right;
    }

    void quickSelect(vector<int>& nums, int start, int end, int k) {
        int pivot = partition(nums, start, end);
        if(pivot==k) {
            return;
        }
        else if(pivot<k) {
            quickSelect(nums, pivot+1, end, k);
        }
        else {
            quickSelect(nums, start, pivot-1, k);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        quickSelect(nums, 0, n-1, k-1);
        return nums[k-1];
    }
};
```





## 221.最大正方形

>在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。
>
>- `m == matrix.length`
>- `n == matrix[i].length`
>- `1 <= m, n <= 300`
>- `matrix[i][j]` 为 `'0'` 或 `'1'`

动态规划。定义状态 $dp[i][j]:=以matrix[i][j]为右下角的最大正方形的边长$ 。

递推式：$dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1])+1$ 。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    static const int N=305;
    int dp[N][N];
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        for(int i=0; i<n; i++)
        {
            if(matrix[0][i]=='1')
                dp[0][i] = 1;
            else
                dp[0][i] = 0;
        }
        for(int i=1; i<m; i++)
        {
            if(matrix[i][0]=='1')
                dp[i][0] = 1;
            else
                dp[i][0] = 0;
            for(int j=1; j<n; j++)
            {
                if(matrix[i][j]=='1')                
                    dp[i][j] = min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]})+1;
                else
                    dp[i][j] = 0;
            }
        }
        int edge=0;
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                edge = max(edge, dp[i][j]);
        return edge*edge;
    }
};
```



## 226.翻转二叉树

>给你一棵二叉树的根节点 `root` ，翻转(以根节点轴对称翻转)这棵二叉树，并返回其根节点。
>
>- 树中节点数目范围在 `[0, 100]` 内
>- `-100 <= Node.val <= 100`

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) {
            return root;
        }
        swap(root->left, root->right);
        if(root->left!=nullptr) {
            invertTree(root->left);
        }
        if(root->right!=nullptr) {
            invertTree(root->right);
        } 
        return root;
    }
};
```



## 230.二叉搜索树中第K小的元素

>给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。
>
>- 树中的节点数为 `n` 。
>- `1 <= k <= n <= 10^4`
>- `0 <= Node.val <= 10^4`

方法一：

中序遍历。对于二叉搜索树，中序遍历的顺序就是从小到大的顺序，因此可以遍历到第k个元素就停止。

时间复杂度 $O(n)$ 。

方法二：

统计每个节点的子树中的节点数，记录在哈希表中。对于此题，其实只要统计每个左子树中的节点数即可。

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    int init(TreeNode* root, unordered_map<TreeNode* , int>& leftMap, unordered_map<TreeNode*, int>& rightMap) {
        if(root==nullptr) {
            return 0;
        }
        int left = init(root->left, leftMap, rightMap);
        leftMap[root] = left;
        int right = init(root->right, leftMap, rightMap);
        rightMap[root] = right;
        return 1+left+right;
    }

    int findkth(TreeNode* root, int k, unordered_map<TreeNode*, int> leftMap) {
        if(leftMap[root] == k-1) {
            return root->val;
        }
        if(leftMap[root] > k-1) {
            return findkth(root->left, k, leftMap);
        }
        return findkth(root->right, k-leftMap[root]-1, leftMap);
    }

    int kthSmallest(TreeNode* root, int k) {
        unordered_map<TreeNode*, int> leftMap, rightMap;
        init(root, leftMap, rightMap);
        return findkth(root, k, leftMap);
    }
};
```







## 233.数字1的个数

> 给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。
>
> - `0 <= n <= 10^9`

根据题目要求，我们需要统计 [0, n] 范围内所有整数中，数字1出现的个数。由于 n 的范围最大为 1e9 ,它是一个 10 位整数，因此我们可以考虑枚举每一个数位，分别统计该数位上数字 1 出现的次数，最后将所有数位统计出的次数进行累加即可得到答案。

考虑代表 $10^k$ 的数位，最后的 $k+1$ 个数位每 $10^{k+1}$ 个数就会循环一次，并且其中包含 $10^k$ 个1。由于n包含 $\lfloor\frac{n}{10^{k+1}}\rfloor$ 个完整的循环，所以这一部分的1的个数为 $\lfloor\frac{n}{10^{k+1}}\rfloor \times 10^k$ 。不在循环中的部分还有 $n\  mod\  10^{k+1}$ 个数，设总共有 $n'$ 个数不在循环中，则有：

+ $n'>=2*10^k$ ，此时可以完成一轮循环，还有 $10^k$ 个1。
+ $n'<10^k$ ，此时这一部分的数不会在该数位产生1。
+ $10^k<=n'<2*10^k$ ，此时有 $n'-10^k+1$ 个1。

时间复杂度 $O(logn)$ 。

```c++
class Solution {
public:
    int countDigitOne(int n) {
        long long int k=1;
        int ret = 0;
        while(k<=n)
        {
            ret += n/(k*10)*k;
            int tmp = n%(k*10);
            if(tmp>=k*2)
                ret += k;
            else if(tmp<k)
                ret += 0;
            else
                ret += tmp-k+1;
            k = k*10;
        }
        return ret;
    }
};
```



## 232.用栈实现队列

>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
>
>实现 `MyQueue` 类：
>
>- `void push(int x)` 将元素 x 推到队列的末尾
>- `int pop()` 从队列的开头移除并返回元素
>- `int peek()` 返回队列开头的元素
>- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`
>
>**说明：**
>
>- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
>- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

双栈。

将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop、peek 操作。

每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。

时间复杂度 $O(n)$ 。

```c++
class MyQueue {
public:
    stack<int> in;
    stack<int> out;
    MyQueue() {

    }
    
    void push(int x) {
        in.push(x);
    }
    
    int pop() {
        if(out.empty()) {
            while(!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        int ret = out.top();
        out.pop();
        return ret;
    }
    
    int peek() {
        if(out.empty()) {
            while(!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.top();
    }
    
    bool empty() {
        return out.empty() && in.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```









## 234.回文链表

>给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
>
>- 链表中节点数目在范围`[1, 10^5]` 内
>- `0 <= Node.val <= 9`

先遍历链表求出长度。然后将前半部分的数字放入栈中，和后半部分比较。

注意，此题如果需要空间复杂度 $O(1)$ 的话，可以反转单链表的后半部分，比较完之后再反转回去。

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* p = head;
        int n = 0;
        while(p!=nullptr) {
            n++;
            p = p->next;
        }
        p = head;
        stack<int> st;
        for(int i=0; i<n/2; i++) {
            st.push(p->val);
            p = p->next;
        }

        if(n&1) {
            p = p->next;
        }
        for(int i=0; i<n/2; i++) {
            if(p->val != st.top()) {
                return false;
            }        
            p = p->next;
            st.pop();
        }
        return true;
    }
};
```



## 236.二叉树的最近公共祖先

>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
>[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
>- 树中节点数目在范围 `[2, 10^5]` 内。
>- `-10^9 <= Node.val <= 10^9`
>- 所有 `Node.val` `互不相同` 。
>- `p != q`
>- `p` 和 `q` 均存在于给定的二叉树中。

用两个数组存储根节点到p和q的路径，然后找到路径上分歧的点即可。

时间复杂度 $O(n)$ 。

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    bool findPath(TreeNode* root, TreeNode* node, vector<TreeNode*>& vec) {
        vec.push_back(root);
        if(root==node) {
            return true;
        }
        if(root->left && findPath(root->left, node, vec)) {
            return true;
        }
        if(root->right && findPath(root->right, node, vec)) {
            return true;
        }
        vec.pop_back();
        return false;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> pvec, qvec;
        findPath(root, p, pvec);
        findPath(root, q, qvec);
        int idx = 0;
        while(idx+1<pvec.size() && idx+1<qvec.size() && pvec[idx+1] == qvec[idx+1]) {
            idx++;
        }
        return pvec[idx];
    }
};
```





## 238.除自身以外数组的乘积

>给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。
>
>题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。
>
>请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。
>
>- `2 <= nums.length <= 105`
>- `-30 <= nums[i] <= 30`
>- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内

求其余各元素的乘积，其实就是求前缀和后缀的乘积。前缀和后缀都可以用递推式在线性时间内求出。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> ret(nums.size(), 1);
        int product = 1;
        for(int i=1; i<nums.size(); i++) {
            product *= nums[i-1];
            ret[i] = product;
        }
        product = 1;
        for(int i=nums.size()-2; i>=0; i--) {
            product *= nums[i+1];
            ret[i] *= product;
        }
        return ret;
    }
};
```





## 239.滑动窗口最大值

>给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
>返回 *滑动窗口中的最大值* 。
>
>- `1 <= nums.length <= 10^5`
>- `-10^4 <= nums[i] <= 10^4`
>- `1 <= k <= nums.length`

方法一：优先队列

很自然的，我们用一个大根堆来维护滑动窗口中的数字，这样每次可以在 $log(k)$ 的时间内获得最大值。为了更新优先队列，我们向其中存储数字的下标，如果堆顶的下标超出了滑动窗口，就弹出堆顶，直到堆顶处在滑动窗口中即可。

时间复杂度 $O(nlogn)$。

```c++
class Solution {
public:
    typedef pair<int, int> Pair;
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        int idx=-1;
        int num=0;
        priority_queue<Pair, vector<Pair>, less<Pair>> que;
        for(int i=0; i<k; i++) {
            que.push(Pair(nums[i], i));
        }

        vector<int> ret;
        ret.push_back(que.top().first);


        for(int i=k; i<n; i++) {
            while(!que.empty() && i - que.top().second + 1 > k) {
                que.pop();
            }
                
            que.push(Pair(nums[i], i));
            ret.push_back(que.top().first);
        }
        return ret;
    }
};
```

方法二：单调栈

考虑当滑动窗口向右移动时，新加入窗口的数字x，它会导致原本在滑动窗口中且小于x的所有数字永远不可能成为最大数，因此可以直接从窗口中排出小于x的所有数。也就是说，我们要维护的窗口中的数字是从大到小排列的。于是，我们可以用单调栈来维护窗口中的数字。由于滑动窗口中的最大值之后会移出窗口，所以我们的单调栈的栈底也要出栈。因此，可以使用双端队列。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int size = nums.size();
        deque<int> que;
        for(int i=0; i<k; i++)
        {
            while(!que.empty() && nums[que.back()]<=nums[i])
                que.pop_back();
            que.push_back(i);
        }
        vector<int> ret;
        ret.push_back(nums[que.front()]);
        for(int i=k; i<size; i++)
        {
            while(!que.empty() && nums[que.back()]<=nums[i])
                que.pop_back();
            que.push_back(i);
            if(que.front()<=i-k)
                que.pop_front();
            ret.push_back(nums[que.front()]);
        }
        return ret;
    }
};
```





## 240.搜索二维矩阵II

>编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：
>
>- 每行的元素从左到右升序排列。
>- 每列的元素从上到下升序排列。
>
>- `m == matrix.length`
>- `n == matrix[i].length`
>- `1 <= n, m <= 300`
>- `-10^9 <= matrix[i][j] <= 10^9`
>- 每行的所有元素从左到右升序排列
>- 每列的所有元素从上到下升序排列
>- `-10^9 <= target <= 10^9`

Z 字形搜索。

我们从矩阵的右上角(0, n-1)开始进行搜索。在位置(x,y)时，未搜索到的区域是当前位置左下角的矩阵，即以 matrix 的左下角为左下角、以 (x,y) 为右上角的矩阵，行的范围为 x 到 m - 1，列的范围为 0 到 y。

+ 如果 $matrix[x][y]=target$ ，搜索完成；
+ 如果 $matrix[x][y]>target$ ，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 y 列的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；
+ 如果 $matrix[x][y]<target$ ，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 x 行的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1；

搜索过程中，如果我们超出了矩阵的边界，说明矩阵中不存在目标元素。

时间复杂度 $O(m+n)$ 。

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int x = 0;
        int y = n-1;
        while(x<m && y>=0) 
        {
            if (matrix[x][y] == target)
                return true;
            if (matrix[x][y] > target)
                --y;
            else
                ++x;
        }
        return false;
    }
};
```



## 241.为运算表达式设计优先级

>给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。
>
>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `10^4` 。
>
>- `1 <= expression.length <= 20`
>- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
>- 输入表达式中的所有整数值在范围 `[0, 99]` 

动态规划。定义 $dp[i][j]:=以expression[i]为起点,长度为j的字符串的所有可能的计算答案(不去重)$。

对于该子串，需要枚举 $j-1$ 个分割位置，分割为左半部分和右半部分，一种可能的计算结果是左半部分和右半部分分别计算完成，然后再将两部分进行计算。

设长度为n的字符串的计算时间复杂度f(n)。由于我们的算法不会重复计算，所以时间复杂度与结果集合的大小相同。于是有 $f(n)=f(1)f(n-1)+f(2)f(n-2)+\cdots+f(n-1)f(1)$ 。所以时间复杂度为卡特兰数(Catalan)，复杂度限制在 $O(2^n)$ 。

```c++
class Solution {
public:
    static const int N=25;
    vector<int> dp[N][N];

    int compute(int a, int b, char op)
    {
        if(op=='+')
            return a+b;
        else if(op=='-')
            return a-b;
        else
            return a*b;
    }

    bool isOperation(char ch)
    {
        if(ch=='+' || ch=='-' || ch=='*')
            return true;
        return false;
    }

    vector<int> diffWaysToCompute(string expression) {
        vector<int> nums;
        vector<char> op;
        string num;
        for(int i=0; i<expression.size(); i++)
        {
            if(isOperation(expression[i]))
            {
                nums.push_back(stoi(num));
                num = "";
                op.push_back(expression[i]);
            }
            else
            {
                num+=expression[i];
            }
        }
        nums.push_back(stoi(num));

        int n = nums.size();
        for(int i=0; i<n; i++)
            dp[i][1].push_back(nums[i]);
        for(int length=2; length<=n; length++)
        {
            for(int start=0; start<n; start++)
            {
                int end=start+length-1;
                if(end>=n)
                    break;
                for(int mid = start; mid<end; mid++)
                {
                    vector<int>& left = dp[start][mid-start+1];
                    vector<int>& right = dp[mid+1][end-mid];
                    for(auto numLeft: left)
                        for(auto numRight: right)
                            dp[start][length].push_back(compute(numLeft, numRight, op[mid]));
                }
            }
        }
        vector<int> ret;
        for(auto res: dp[0][n])
            ret.push_back(res);
        return ret;
    }
};
```

 



## 264.丑数II

>给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。
>
>**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。
>
>- `1 <= n <= 1690`

方法一：最小堆

用一个最小堆维护当前已经获得的丑数。每次弹出堆顶 $x$，则 $2x,3x,5x$ 均是新的丑数，如果他们3个不在堆中就入堆。直到取到第n个丑数即可。

时间复杂度 $O(nlogn)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    int nthUglyNumber(int n) {
        vector<int> primes = {2, 3, 5};
        unordered_set<ll> set;
        priority_queue<ll, vector<ll>, greater<ll>> que;
        set.insert(1);
        que.push(1);
        for(int i=1; i<n; i++) 
        {
            ll num = que.top();
            que.pop();
            for(int j=0; j<3; j++) 
            {
                ll nxt = num*primes[j];
                if(set.count(nxt)==0) 
                {
                    set.insert(nxt);
                    que.push(nxt);
                }
            }
        }
        return que.top();
    }
};
```

方法二：动态规划

由题意，每个新的丑数必然是旧的丑数乘以2，3或5得到的。我们维护3个指针 $pointer[3]$ ，分别指向一个旧的丑数，它们分别乘以2,3,5可以得到一个新丑数，且该新丑数是最小且大于等于当前已经有的丑数。如此一来，下一个丑数就是这3个新丑数中最小的那个。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    typedef long long int ll;

    int nthUglyNumber(int n) {
        vector<ll> uglyNumbers(n);
        uglyNumbers[0] = 1;
        vector<ll> prime={2,3,5};
        vector<ll> pointer={0,0,0};
        for(int i=1; i<n; i++)
        {
            ll nxt[3];
            for(int j=0; j<3; j++)
                nxt[j] = uglyNumbers[pointer[j]]*prime[j];
            uglyNumbers[i] = *min_element(&nxt[0], &nxt[0]+3);
            for(int j=0; j<3; j++)
            {
                if(nxt[j]==uglyNumbers[i])
                    pointer[j]++;
            }
        }
        return uglyNumbers[n-1];
    }
};             
```



## 268.丢失的数字

>给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。
>
>- `n == nums.length`
>- `1 <= n <= 10^4`
>- `0 <= nums[i] <= n`
>- `nums` 中的所有数字都 **独一无二**

方法一：普通排序。

时间复杂度 $O(nlogn)$ 。

方法二：哈希表。

时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。

方法三：位运算。

求数组中所有数再加上0到n的所有数字的异或和。出现两次的数字异或和抵消，最后结果就是只出现一次的数字，就是原数组中缺失的数字。

时间复杂度 $O(n)$ 。

方法四：排序。

在遍历数组过程中，将数字x放在nums[x]的位置处。最后如果数组中有n，那么它的索引就是缺失的数字，如果没有n，那么缺失的数字就是n。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        for(int i=0; i<n; i++)
        {
            if(nums[i]==n)
                continue;
            else if(nums[i]==i)
                continue;
            else
            {
                while(nums[i]!=i && nums[i]!=n)
                    swap(nums[i], nums[nums[i]]);
            }
        }
        for(int i=0; i<n; i++)
        {
            if(nums[i]==n)
                return i;
        }
        return n;
    }
};
```



## 274.H指数

>给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。
>
>根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。
>
>- `n == citations.length`
>- `1 <= n <= 5000`
>- `0 <= citations[i] <= 1000`

方法一：

将citation数组排序，然后从大到小遍历，枚举H指数从n到0，第一个满足条件的H就是最大的H。

时间复杂度 $O(nlogn)$ 。

方法二：

由于H指数最大是n，所以一篇论文被引用次数超过n是没有意义的， 可以认为是n。所以，我们可以用计数排序。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        vector<int> vec(n+1, 0);
        for(int i=0; i<n; i++) {
            if(citations[i]>n) {
                vec[n]++;
            } else {
                vec[citations[i]]++;
            }
        }
        int paper = 0;
        for(int i=n; i>0; i--) {
            paper += vec[i];
            if(paper>=i) {
                return i;
            }
        }
        return 0;
    }
};
```





## 279.完全平方数

>给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
>**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。
>
>- `1 <= n <= 10^4`

方法一：动态规划

定义 $dp[i]:=和为i的完全平方数的最少数量$ 。则有 $dp[i]=1+min({dp[i-j^2]|i-j^2>=0})$ 。

时间复杂度 $O(n\sqrt{n})$ 。

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1);
        dp[0] = 0;
        for(int i=1; i<=n; i++)
        {
            int cnt=dp[i-1]+1;
            for(int j=1; ;j++)
            {
                if(i-j*j<0)
                    break;
                cnt = min(cnt, dp[i-j*j]+1);
            }
            dp[i] = cnt;
        }
        return dp[n];
    }
};
```

方法二：四平方和定理

四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。四平方和定理其实是费马多边形数定理在n=4时的特例。

>费马多边形数定理是一个定律，定义为每一个正整数都可以表示为最多*n*个*n*边形数的和。也就是说，每一个正整数一定可以表示为不超过三个的三角形数之和、不超过四个的平方数之和、不超过五个的五边形数之和，依此类推。

同时四平方和定理包含了一个更强的结论：当且仅当 $n=4^k(8m+7),其中(4^k是小于n的最大的4的幂,k≥0,m≥0)$ 时，n可以被表示为4个四边形数的和。因此，当n满足该条件时，我们可以直接返回4，其余情况答案在1,2,3之中。

+ 答案为1时，n为完全平方数，这很好判断。
+ 答案为2时，我们可以枚举 $a(1≤a≤\sqrt{n})$ ，判断 $n-a^2$ 是否为完全平方数即可。
+ 答案为3时，无法很快解决该问题，但通过排除法可以得到该结果。

时间复杂度 $O(\sqrt{n})$ 。

```c++
class Solution {
public:
    bool isSquaredNumber(int n)
    {
        int root = sqrt(n);
        return root*root==n;
    }

    bool is4k8m7(int n)
    {
        while(n%4==0)
            n = n/4;
        return n%8==7;
    }

    int numSquares(int n) {
        if(is4k8m7(n))
            return 4;
        if(isSquaredNumber(n))
            return 1;
        for(int i=1; i*i<n; i++)
        {
            if(isSquaredNumber(n-i*i))
                return 2;
        }
        return 3;
    }
};
```

 



## 283.移动零

>给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
>**请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
>- `1 <= nums.length <= 10^4`
>- `-2^31 <= nums[i] <= 2^31 - 1`

看似是把0移动到末尾，其实我们可以把非0移动到开头。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int idx=0;
        for(int i=0; i<nums.size(); i++) {
            if(nums[i]!=0) {
                nums[idx++] = nums[i];
            }
        }
        for(int i=idx; i<nums.size(); i++) {
            nums[i] = 0;
        }
        return;
    }
};
```



## 287.寻找重复数

>给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。
>
>假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。
>
>你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。
>
>- `1 <= n <= 105`
>- `nums.length == n + 1`
>- `1 <= nums[i] <= n`
>- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**
>- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

Floyed判圈算法。双指针法。

此题可以用单链表求环算法。

注意到数组中的数都在1至n之间，那么我们就数组中的数看作指针，指向下标为nums[i]的数，则数组中会有许多单链表。由于数组中没有0，所以没有指针指向第一个数。又因为数组中有重复的数，所以数组中一定有环。于是，我们可以从下标为0的点出发， 寻找环的入口，入口即是重复的数。

另外要注意：

1. 之所以从下标为0的点出发，是因为这个点一定不在环上。
2. 数组构成的链表可能有许多环，但一定只有一个环有尾巴，而且可能有多条尾巴，这些尾巴一定相交于重复的那个数字，而节点0一定是某一条尾巴的端点。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0;
        int fast = 0;
        while(slow==0 || slow!=fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        slow = 0;
        while(slow!=fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```





## 295.数据流的中位数

>**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
>- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
>- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。
>
>实现 MedianFinder 类:
>
>- `MedianFinder() `初始化 `MedianFinder` 对象。
>- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
>- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。
>
>- `-10^5 <= num <= 10^5`
>- 在调用 `findMedian` 之前，数据结构中至少有一个元素
>- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

最大堆+最小堆。

维护两个堆，分别存储数据流的数字小的半部分和数字大的半部分。这样中位数就一定是两个堆的堆顶之一或他们的平均值。

时间复杂度 $O(n)$ 。

```c++
class MedianFinder {
    priority_queue<int, vector<int>, less<int>> queMax;
    priority_queue<int, vector<int>, greater<int>> queMin;
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if(queMin.size()==queMax.size()) {
            if(queMax.empty() || queMax.top()<num) {
                queMin.push(num);
            } else {
                queMax.push(num);
            }
        } else if(queMin.size()<queMax.size()) {
            if(num >= queMax.top()) {
                queMin.push(num);
            } else {
                queMax.push(num);
                queMin.push(queMax.top());
                queMax.pop();
            }
        } else {
            // queMin.size() > queMax.size()
            if( num <= queMin.top()) {
                queMax.push(num);
            } else {
                queMin.push(num);
                queMax.push(queMin.top());
                queMin.pop();
            }
        }
    }
    
    double findMedian() {
        if(queMax.size()==queMin.size()) {
            return (queMax.top()+queMin.top())/2.0;
        } else if(queMax.size()>queMin.size()) {
            return queMax.top();
        } else {
            return queMin.top();
        }
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```





## 297.二叉树的序列化与反序列化

>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
>
>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
>
>**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode.cn/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
>
>- 树中结点数在范围 `[0, 104]` 内
>- `-1000 <= Node.val <= 1000`

可以按照Leetcode的序列化方式，层序遍历并序列化。

要注意的是，在反序列化时，队列中存储的要是节点的二级指针，这样才能修改指针的值。

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 #include <cstdlib>
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string ret;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            TreeNode* node = que.front();
            que.pop();
            if(node==NULL) {
                ret.append("NULL,");
            } 
            else {
                ret.append(to_string(node->val)).append(",");
                que.push(node->left);
                que.push(node->right);
            }
        }
        return ret;
    }

    TreeNode* deserializeHelper(vector<string>& vec) {
        int sz = vec.size();

        TreeNode* root;
        queue<TreeNode**> que;
        que.push(&root);
        for(int i=0; i<sz; i++) {
            if(vec[i]=="NULL") {
                TreeNode** node = que.front();
                que.pop();
                *node = NULL;
            }
            else {
                TreeNode** node = que.front();
                que.pop();
                *node = new TreeNode(stoi(vec[i]));
                que.push(&(*node)->left);
                que.push(&(*node)->right);
            }
        }
        cout << serialize(root) << endl;
        return root;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        string cur;
        vector<string> vec;
        int sz = data.size();
        for(int i=0; i<sz; i++) {
            if(data[i]==',') {
                vec.push_back(cur);
                cur.clear();
            } else {
                cur.push_back(data[i]);
            }
        }
        return deserializeHelper(vec);
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```



























