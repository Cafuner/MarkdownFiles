# Leetcode 400-499

[TOC]





## 402.移掉K位数字

>给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。移除K位数字后的结果如果有前导零，返回时应去掉。
>
>- `1 <= k <= num.length <= 10^5`
>- `num` 仅由若干位数字（0 - 9）组成
>- 除了 **0** 本身之外，`num` 不含任何前导零

单调栈。问题相当于从num中选取num.lenth-k个元素并保持相对顺序，使得其字典序最小。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        int sz = num.size();
        if(k==sz)
            return string("0");
        int left = sz-k;
        deque<char> deq;
        for(int i=0; i<sz; i++)
        {
            char ch = num[i];
            while(deq.size()>=1 && deq.back()>ch && deq.size()+sz-i>left)
                deq.pop_back();
            if(deq.size()<left)
                deq.push_back(ch);
        }
        

        while(!deq.empty() && deq.front()=='0')
            deq.pop_front();
        left = deq.size();
        if(left==0)
            return string("0");
        string ret(left, '0');
        for(int i=0; i<left; i++)
        {
            ret[i] = deq.front();
            deq.pop_front();
        }
        return ret;
    }
};
```





## 403.青蛙过河

>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。
>
>给你石子的位置列表 `stones`（用单元格序号 **升序** 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 `1` 个单位（即只能从单元格 1 跳至单元格 2 ）。
>
>如果青蛙上一步跳跃了 `k` 个单位，那么它接下来的跳跃距离只能选择为 `k - 1`、`k` 或 `k + 1` 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。
>
>- `2 <= stones.length <= 2000`
>- `0 <= stones[i] <= 2^31 - 1`
>- `stones[0] == 0`
>- `stones` 按严格升序排列

方法一：DFS+记忆化搜索

由于跳跃单位有限制，所以我们将跳到的石子序号 $start$ 和目前为止最后一步跳跃的距离 $jump$ 构成的二元组作为状态，使用哈希表记录搜索过的状态。另外，为了更加快速的搜索下一步可以跳跃到的石子，使用哈希表预处理石子的位置。

由于最多遍历 $n^2$ 个状态，每个状态需要常数时间，所以时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    typedef unsigned long long int ull;
    unordered_set<ull> visited;
    unordered_map<int, int> mp;

    bool dfs(vector<int>& stones, ull start, ull end, ull jump)
    {
        if(start==end)
            return true;
        if(visited.count((start<<32)+jump))
            return false;
        for(int k=jump-1; k<=jump+1; k++)
        {
            if(k==0)
                continue;
            int nxt = stones[start]+k;
            if(mp.find(nxt)!=mp.end())
            {
                if(dfs(stones, mp[nxt], end, k))
                    return true;
            }
        }
        visited.insert((start<<32)+jump);
        return false;
    }

    bool canCross(vector<int>& stones) {
        if(stones[1]-stones[0]!=1)
            return false;
        for(int i=0; i<stones.size(); i++)
        {
            mp[stones[i]] = i;
        }
        return dfs(stones, 1, stones.size()-1, 1);
    }
};
```

方法二：动态规划。

定义 $dp[i][k]:=青蛙是否能以最后一步跳跃的距离为k，落在编号为i的石子上$ 。

于是有 $dp[i][k]=dp[j][k-1] \or dp[j][k] \or dp[j][k+1]$ ，其中j代表青蛙上一次所在的石子编号，满足 $stones[i]-stones[j]=k$ 。

每次跳跃，落点的石子编号都至少加一，而跳跃的距离则最多加一，所以有现在所处的石子编号为 i 时，上一次跳跃距离 k 必定满足 $k<=i$ 。于是dp数组的第二纬度可以只开到石子数量的规模。

时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    static const int N=2010;
    bool dp[N][N];
    bool canCross(vector<int>& stones) {
        dp[0][0] = true;
        for(int i=1; i<stones.size(); i++)
        {
            for(int j=i-1; j>=0; j--)
            {
                int k=stones[i]-stones[j];
                if(k>j+1)
                    break;
                dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1];
            }
        }
        for(int i=1; i<stones.size(); i++)
            if(dp[stones.size()-1][i])
                return true;
        return false;
    }
};
```









## 406.根据身高重建队列

>假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
>
>请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
>
>- `1 <= people.length <= 2000`
>- `0 <= hi <= 10^6`
>- `0 <= ki < people.length`
>- 题目数据确保队列可以被重建

方法一：从低到高考虑

将所有人先按照身高从低到高排序，然后遍历一次。由于重建队列只要求了第i个人前面比他高的人的数量，因此我们在遍历到 $[h,k]$ 这个人时，已经插入到队列中的人的身高都小于等于h，因此我们只需要在这个人前面预留 k-cnt 个位置就可以了，其中cnt表示已经插入到队列中身高等于h的人的数量。时间复杂度 $O(n^2)$ 。

方法二：从高到低考虑

将所有人先按照身高从高到低排序，然后遍历一次。由于先插入的是高个子的人，后插入的人对已经在队列中的人没有影响（除非身高相同）。因此，对于 $[h,k]$ 这个人，只需要将他插入队列，使得他前面恰好有k个人即可。复杂度 $O(n^2)$ 。需要注意的是，排序时对于身高相同的人，应该让k更小的人排在前面。



## 407.接雨水II

>给你一个 `m x n` 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
>
>- `m == heightMap.length`
>- `n == heightMap[i].length`
>- `1 <= m, n <= 200`
>- `0 <= heightMap[i][j] <= 2 * 10^4`

方法一：BFS

首先我们求出矩阵中最高的单元的高度，然后假设每个柱子都能储水到这个高度。那么显然水会沿着四个方向中较低的方向流走。

一开始，一定是处于边框的那些柱子的水流走。于是，每个柱子的水流走后，其四周柱子的水的高度一定会降低到当前柱子的水的高度。于是，可以用BFS循环处理水的流失过程，每个柱子的水有流失都要入队。最初状态就是处于边框的柱子在队列中。

由于每次流失都会降低水的高度，在最坏情况下，需要降低 $m\times n$ 次高度，每次有 $m\times n$ 个柱子降低高度。所以时间复杂度 $O(m^2n^2)$ 。

```c++
class Solution {
public:

    typedef pair<int, int> P;
    P directions[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};

    int trapRainWater(vector<vector<int>>& heightMap) {
        int n = heightMap.size();
        if(n==0) {
            return 0;
        }
        int m = heightMap[0].size();
        int top = 0;
        

        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                top = max(top, heightMap[i][j]);
            }
        }
    
        
        queue<P> que;
        vector<vector<int>> water(n, vector<int>(m, top));
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(i==0 || i==n-1 || j==0 || j==m-1) {
                    water[i][j] = heightMap[i][j];
                    que.push(P(i, j));            
                }
            }
        }
        
        while(!que.empty()) {
            P p = que.front();
            que.pop();
            int x = p.first;
            int y = p.second;
            for(int i=0; i<4; i++) {
                P direction = directions[i];
                int nx = x+direction.first;
                int ny = y+direction.second;
                if(nx<0 || nx>=n || ny<0 || ny>=m) {
                    continue;
                }
                if(water[nx][ny] > water[x][y]) {
                    water[nx][ny] = max(water[x][y], heightMap[nx][ny]);
                    que.push(P(nx, ny));
                }
            }
        }

        int res = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                res += water[i][j] - heightMap[i][j];
            }
        }

        return res;
    }
};
```

方法二：优先队列

其实，上面的BFS方法可以优化。我们可以假设，水要流失时全部是从最低处流走的，那么首先我们找到最外围中高度最低的柱子cur，那么该柱子周围的柱子的储水量最高为cur.height。因为如果cur周围的柱子的储水高度更高，则它们的水会从cur流走。因此，我们可以用一个优先队列维护当前与外界连通的高度最低的柱子，每次都可以确定它周围的柱子的储水量，并将周围柱子入队。为了避免柱子重复入队，可以使用一个vis数组记录访问情况。

时间复杂度 $O(mnlog(mn))$。

另外注意，在下面的代码中，我们要使用greater仿函数似的优先队列按照最小堆排序。虽然pair结构默认重载了< 运算符，可以作为 greater 的参数，但是 pair是先比较first，再比较second，我们的second是自定义结构体，所以要为这个结构体重载 < 运算符。

```c++
class Solution {
public:

    struct Pos {
        int x;
        int y;
        bool operator<(const Pos& a) const {
            return x<a.x;
        }
    };
    typedef pair<int, Pos> P;
    pair<int, int> directions[4] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};


    int trapRainWater(vector<vector<int>>& heightMap) {
        int n = heightMap.size();
        if(n==0) {
            return 0;
        }
        int m = heightMap[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        priority_queue<P, vector<P>, greater<P>> que;
        
        Pos pos; 
        int bottom = INT_MAX;
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(i==0 || i==n-1 || j==0 || j==m-1) {
                    pos.x = i;
                    pos.y = j;
                    que.push(P(heightMap[i][j], pos));
                    vis[i][j] = true;
                }
            }
        }

        int res = 0;
        while(!que.empty()) {
            P p = que.top();
            que.pop();
            int height = p.first;
            Pos pos = p.second;
            Pos npos;
            for(int i=0; i<4; i++) {
                npos.x = pos.x + directions[i].first;
                npos.y = pos.y + directions[i].second;
                if(npos.x < 0 || npos.x >=n || npos.y < 0 || npos.y>=m || vis[npos.x][npos.y]) {
                    continue;
                } 
                if(heightMap[npos.x][npos.y] < height) {
                    res += height - heightMap[npos.x][npos.y];
                }
                vis[npos.x][npos.y] = true;
                que.push(P(max(heightMap[npos.x][npos.y], height), npos));
            }
        }

        return res;
    }
};
```



 

## 409.最长回文串

>给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。
>
>在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。
>
>- `1 <= s.length <= 2000`
>- `s` 只由小写 **和/或** 大写英文字母组成

每两个一样的字符凑一对，然后最中心可以是单独一个字符。复杂度 $O(n)$ 。







## 410.分割数组的最大值

>给定一个非负整数数组 `nums` 和一个整数 `m` ，你需要将这个数组分成 `m` 个非空的连续子数组。
>
>设计一个算法使得这 `m` 个子数组各自和的最大值最小。
>
>- `1 <= nums.length <= 1000`
>- `0 <= nums[i] <= 10^6`
>- `1 <= m <= min(50, nums.length)`

方法一：二分查找+贪心

“使最大值尽可能小”是二分搜索题目常见的问法。

此题可以二分各数组各自和的最大值，上界为nums的和，下界为数组的最大值（也可以设置为上界/k）。当按照各数组各自和的最大值为mid来进行分割时，用贪心算法求出需要划分的组数，有以下几种情况：

+ 无法分割，即存在元素大于mid，那么令left=mid+1；
+ 组数大于k，即mid过小，导致组数太多，于是令left=mid+1;
+ 组数小于等于k，即可以按照mid划分，但不一定是满足条件的最小值，所以令right=mid。

复杂度 $O(nlog(sum-maxn))$ ，或者 $O(nlog(sum-sum/m))$ 。

方法二：DP

“将数组分割为 mm*m* 段，求……”是动态规划题目常见的问法。

定义DP数组：
$$
\begin{equation*}
dp[i][j]:=将数组的前 i 个数分割为 j 段所能得到的最大连续子数组和的最小值
\end{equation*}
$$
在进行状态转移时，我们可以考虑第 j 段的具体范围，即我们可以枚举 *k*，其中前 *k* 个数被分割为 *j-1* 段，而第 *k+1* 到第 *i* 个数为第*j* 段。那么就有递推式：
$$
\begin{equation*}
dp[i][j]=min_{k=0}^{i-1}\{max(dp[k][j-1],sub(k+1,i))\}
\end{equation*}
$$
由于我们不能分出空的子数组，因此合法的状态必须有 i≥j。对于不合法的状态，由于我们的目标是求出最小值，因此可以将这些状态全部初始化为一个很大的数。时间复杂度 $O(n^2m)$ 。





## 413.等差数列划分

>如果一个数列 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该数列为等差数列。
>
>- 例如，`[1,3,5,7,9]`、`[7,7,7,7]` 和 `[3,-1,-5,-9]` 都是等差数列。
>
>给你一个整数数组 `nums` ，返回数组 `nums` 中所有为等差数组的 **子数组** 个数。
>
>**子数组** 是数组中的一个连续序列。
>
>- `= nums.length <= 5000`
>- `-1000 <= nums[i] <= 1000`

动态规划。定义状态 $dp[i]:=以nums[i]结尾的等差数组的个数$ 。则有两种情况：

+ $nums[i]-nums[i-1]==nums[i-1]-nums[i-2]$ ，那么有 $dp[i]=dp[i-1]+1$ 。
+ 否则 $dp[i]=0$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int ret=0;
        int dp=0;
        for(int i=2; i<nums.size(); i++)
        {
            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])
                dp++;
            else
                dp=0;
            ret += dp;
        }
        return ret;
    }
};
```



## 415.字符串相加

>给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。
>
>你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。
>
>- `1 <= num1.length, num2.length <= 104`
>- `num1` 和`num2` 都只包含数字 `0-9`
>- `num1` 和`num2` 都不包含任何前导零

时间复杂度 $O(n+m)$ 。

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        int n = num1.size();
        int m = num2.size();
        vector<int> res(max(n, m)+1, 0);
        
        int idx1 = n-1;
        int idx2 = m-1;
        int maxnm = max(m, n);
        
        int nxt = 0;
        int a, b;
        int idx = 0;
        for(int i=0; i<maxnm; i++) {
            if(idx1>=0) 
                a = num1[idx1]-'0';
            else
                a = 0;
            if(idx2>=0)
                b = num2[idx2]-'0';
            else
                b = 0;
            res[idx++] = (a+b+nxt)%10;
            nxt = (a+b+nxt)/10;
            idx1--;
            idx2--;
        }
        if(nxt>0) {
            res[idx++] = nxt;
        }
        vector<char> ret(idx);
        for(int i=0; i<idx; i++) {
            ret[i] = '0'+res[idx-i-1];
        }
        return string(ret.begin(), ret.end());
        
    }
};
```





## 416.分割等和子集

>给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
>- `1 <= nums.length <= 200`
>- `1 <= nums[i] <= 100`

动态规划。此问题是01背包问题。设所有元素的和的一半为 $sum$ ，那么假设我们有容量为sum的背包，还有一些宝石需要放到背包中，每个宝石的价值和需要消耗的容量均为 $nums[i]$ 。如此一来，我们只需要最大化背包能装的宝石价值，最后判断其是否装满即可。需要注意的是，当元素和为奇数是，直接返回false即可。

时间复杂度 $O(n\Sigma(nums[i]))$ 。

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int i=0; i<nums.size(); i++)
            sum += nums[i];
        if(sum&1)
            return false;
        sum /= 2;
        vector<int> dp(sum+1);
        sort(nums.begin(), nums.end());
        for(int i=0; i<nums.size(); i++)
        {
            for(int j=sum; j>=nums[i]; j--)
            {
                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[sum]==sum;
    }
};
```





## 420.强密码检验器

>满足以下条件的密码被认为是强密码：
>
>- 由至少 `6` 个，至多 `20` 个字符组成。
>- 包含至少 **一个小写** 字母，至少 **一个大写** 字母，和至少 **一个数字** 。
>- 不包含连续三个重复字符 (比如 `"Baaabb0"` 是弱密码, 但是 `"Baaba0"` 是强密码)。
>
>给你一个字符串 `password` ，返回 *将 `password` 修改到满足强密码条件需要的最少修改步数。如果 `password` 已经是强密码，则返回 `0` 。*
>
>在一步修改操作中，你可以：
>
>- 插入一个字符到 `password` ，
>- 从 `password` 中删除一个字符，或
>- 用另一个字符来替换 `password` 中的某个字符。
>
>限制条件：
>
>- `1 <= password.length <= 50`
>- `password` 由字母、数字、点 `'.'` 或者感叹号 `'!'` 组成

此题是模拟题，同时需要分析。我们将给定的字符串分为3类：

1. 给定的字符串长度严格小于 6 。

    此时完全不需要删除字符，只需要修改或增加。因为我们删除一个字符的目的只可能是因为该字符连续出现了三次或以上，而且删除完之后为了保证字符数量还需要增加一个字符，这两步操作完全可以用修改字符来代替，且所需要的步骤更少。

    如果字符串中出现不超过 4 个连续相同的字符，替换一个字符的操作也是没有意义的，因为替换一个字符的目的只可能是将连续相同的字符中间的某个字符替换成不同的字符，而这个数量不超过 4 时，我们在中间的位置添加一个不同的字符，也可以达到同样（或者更好）的结果。

    如果字符串中出现了 5 个连续相同的字符，那么替换一个字符的操作同样也是没有意义的。因为此时字符的种类只有一种，至少需要两次操作才能达到字符种类的要求。而我们在中间字符的两侧分别添加一个不同种类的字符，即可满足要求，并且操作次数最少。

    因此，在这种情况下，只有添加一个字符的操作是有意义的。该操作的次数为 $6-n$ 。由于添加字符的同时可以使得字符种类增多，因此最终最少操作数为 $6-n$ 与$ 3-(字符种类)$ 中的较大值，即需要保证字符串长度和字符种类均满足要求。

2. 给定的字符串长度在 $[6,20]$ 的范围内。

    我们可以发现添加一个字符和删除一个字符的操作是没有意义的。使用替换总是能更快的满足强密码的要求。因此考虑所有重复字母构成的子串，假设有一个长度为k，那么为了消除它，我们需要替换其中 $\lfloor \frac{k}{3} \rfloor$ 个字符。因此最终最少操作数为所有 $\lfloor \frac{k}{3} \rfloor$ 的和与 $ 3-(字符种类)$ 中的较大值。

3. 给定的字符串长度大于20。

    可以发现添加一个字符的操作是没有意义的，但此时替换一个字符和删除一个字符这两种操作都是必不可少的。这是因为删除一个字符会起到调整（减少）字符串长度的作用，而当字符串长度满足要求，但仍然存在 3 个连续相同字符的时候，替换一个字符的操作在上一类讨论中被证明是比删除一个字符更优的。

    首先应该最大化利用删除一个字符的操作次数。我们将重复字母构成的子串按照长度分为3类：

    + k mod 3 = 0 。那么删除1个字符后，$\lfloor \frac{k}{3} \rfloor$ 的值就会减1，即之后替换操作就可以减1。
    + k mod 3 = 1 。那么删除2个字符后，$\lfloor \frac{k}{3} \rfloor$ 的值就会减1，即之后替换操作就可以减1。
    + k mod 3 = 2 。那么删除3个字符后，$\lfloor \frac{k}{3} \rfloor$ 的值就会减1，即之后替换操作就可以减1。

    由此可见，假设需要总共删除x个字符，那么应该尽可能先把每个 k mod 3 = 0 的串各删除1个字符，如果还有剩余的删除次数，再将每个 k mod 3 = 1的串各删除2个字符。最后还有剩余删除次数的话，对于所有的k，需要删除 $\lfloor \frac{k}{3} \rfloor \times 3$ 个字符。

    当把删除次数用完之后，就回到了第2中情况，计算替换的次数后加上删除的次数即可。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int strongPasswordChecker(string password) {
        int type[3]={0,0,0};

        int sz = password.size();
        for(int i=0; i<sz; i++)
        {
            if(islower(password[i]))
                type[0]=1;
            else if(isupper(password[i]))
                type[1]=1;
            else if(isdigit(password[i]))
                type[2]=1;
        }
        int typeCnt = type[0]+type[1]+type[2];
        int addTypeCnt = 3-typeCnt;

        vector<int> dup[3];
        char cur=password[0];
        int dupCnt = 1;
        for(int i=1; i<sz; i++)
        {
            if(password[i]==cur)
            {
                dupCnt++;
            }
            else if(dupCnt>=3)
            {
                dup[dupCnt%3].push_back(dupCnt);
                cur = password[i];
                dupCnt = 1;
            }
            else
            {
                cur = password[i];
                dupCnt = 1;
            }
        }
        if(dupCnt>=3)
            dup[dupCnt%3].push_back(dupCnt);

        if(sz<6)
        {
            int addCnt = 6-sz;
            return max(addCnt, addTypeCnt);
        } 
        else if(sz<=20)
        {
            int modifyCnt=0;
            for(int i=0; i<3; i++)
            {
                vector<int>& vec = dup[i];
                int vecsz = vec.size();
                for(int j=0; j<vecsz; j++)
                {
                    modifyCnt += vec[j]/3;
                }
            }
            return max(modifyCnt, addTypeCnt);
        }
        else 
        {   
            int removeCnt = sz-20;
            cout << removeCnt << endl;
            //先删除长度%3==0的连续串，每个串删除1个字符
            int remove1 = min((int)dup[0].size(), removeCnt);
            cout << remove1 << endl;
            removeCnt -= remove1;
            for(int i=0; i<remove1; i++)
            {
                if(dup[0].back()>=3)
                    dup[2].push_back(dup[0].back()-1);
                dup[0].pop_back();
            }
            //再删除长度%3==1的连续串，每个串需要删除2个字符
            int remove2 = min((int)dup[1].size()*2, removeCnt);
            cout << remove2 << endl;
            removeCnt -= remove2;
            remove2 /= 2;
            for(int i=0; i<remove2; i++)
            {
                if(dup[1].back()>=4)
                    dup[2].push_back(dup[1].back()-2);
                dup[1].pop_back();
            }
            //最后删除长度为%3==2的连续串，每个串需要删除到剩下2个字符
            for(int i=0; i<3; i++)
            {
                int dupsz = dup[i].size();
                for(int j=0; j<dupsz; j++)
                {
                    if(removeCnt==0)
                        break;
                    int duplength = dup[i].back();
                    dup[i].pop_back();
                    int remove3 = duplength; 

                    remove3 /= 3;
                    remove3 *= 3;
                    remove3 = min(removeCnt, remove3);
                    removeCnt -= remove3;
                    if(duplength-remove3>2)
                        dup[i].push_back(duplength-remove3);
                }
            }  
            int replaceCnt = 0;
        
            for(int i=0; i<3; i++)
                for(int j=0; j<dup[i].size(); j++)
                    replaceCnt += dup[i][j]/3;
            return max(replaceCnt, addTypeCnt)+sz-20;
        }
    }
};
```





## 435.无重叠区间

>给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
>
>- `1 <= intervals.length <= 10^5`
>- `intervals[i].length == 2`
>- `-5 * 10^4 <= starti < endi <= 5 * 10^4`

贪心算法。不妨假设最终留下的区间从左到右分别为 $[left_1,right_1],[left_2,right_2],\cdots$ 。那么intervals中，如果有一个区间 $[left_k,right_k]$ 满足 $right_k<=right_1$ ，那么完全可以把区间1还换成区间k。因此可以贪心的找到右边界最小的区间作为最终留下的第一个区间。

第一个区间固定后，剩下的问题与原问题相同，只不过规模变小了。现在去除与第一个区间有交集的区间，在剩下的区间中找到右边界最小的区间作为第二个留下的区间。以此类推可以找到所有留下的区间。

实现时，先将intervals按照右边界排序，即可以一次遍历找到所有留下的区间。时间复杂度  $O(n)$ 。

```c++
class Solution {
public:
    static const int INF = 0x3f3f3f3f;

    static bool cmp(vector<int>& a, vector<int>& b)
    {
        return a[1]<b[1];
    }

    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int sz = intervals.size();
        sort(intervals.begin(), intervals.end(), cmp);
        int selected = 0;
        int right=-INF;

        for(int i=0; i<sz; i++)
        {
            vector<int>& tmp = intervals[i];
            if(tmp[0]>=right)
            {
                right = tmp[1];
                selected++;
            }
        }
        return sz-selected;
    }
};
```



## 437.路径总和III

>给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
>**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
>- 二叉树的节点个数的范围是 `[0,1000]`
>- `-10^9 <= Node.val <= 10^9` 
>- `-1000 <= targetSum <= 1000` 

方法一：

遍历到节点cur时，枚举终点为cur的路径和。

时间复杂度 $O(n^2)$ 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    typedef long long int ll;
    int pathSum(TreeNode* root, ll target, vector<ll> vec) {
        int ret=0;
        int sz = vec.size();
        for(int i=0; i<sz; i++) {
            vec[i] += root->val;
            if(vec[i] == target) {
                ret++;
            }
        }
        vec.push_back(root->val);
        if(vec[sz]==target) {
            ret++;
        }
        if(root->left != nullptr) {
            ret += pathSum(root->left, target, vec);
        }
        if(root->right != nullptr) {
            ret += pathSum(root->right, target, vec);
        }
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) {
            return 0;
        }
        vector<ll> vec;
        return pathSum(root, targetSum, vec);
    }
};
```

方法二：

前缀和。

其实，在遍历到cur节点时，可以更加快速的查找以cur为终点且和为target的路径条数。假设cur到根节点的和为sum，那么要查找的路径的数量就等于和为sum-target的前缀的数量。因为每个和为sum-target的前缀的下一个节点为起点，cur为终点的路径的和就是target。为了保证去掉前缀后路径上至少有一个cur节点(否则就为空路径了)，我们定义遍历的cur节点时，所有前缀和不包括当前节点。

时间复杂度 $O(n)$ 。

注，这个方法可以应用到一维数组找和为target的子数组，或多叉树找和为target的路径等，只要可以通过前缀和+哈希表快速求路径和的都可以。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    typedef long long int ll;
    unordered_map<ll, int> mp;

    int dfs(TreeNode* node, ll sum, int targetSum) {
        if(node==nullptr) {
            return 0;
        }
        int ret = 0;
        sum += node->val;
        ret += mp[sum-targetSum];
        if(sum==targetSum) {
            ret++;
        }
        mp[sum]++;
        ret += dfs(node->left, sum, targetSum);
        ret += dfs(node->right, sum, targetSum);
        mp[sum]--;
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        return dfs(root, 0, targetSum);
    }
};
```





## 438.找到字符串中的所有字母异位词

>给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
>**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。
>
>- `1 <= s.length, p.length <= 3 * 10^4`
>- `s` 和 `p` 仅包含小写字母

滑动窗口。

遍历s中长度与p相同的子串，检查是否满足异位词。在遍历下一个子串时，每次都是增加一个字符，减少一个字符，因此我们只需要维护已经满足的异位字符的数量并及时更新它，就可以知道新的子串是否是异位词。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ret;
        int slen = s.size();
        int plen = p.size();
        if(slen<plen)
            return ret;
        int match = 0;
        unordered_map<int, int> mp;
        for(int i=0; i<plen; i++) {
            mp[p[i]]++;
        }
        unordered_map<int, int> cur;
        for(int i=0; i<plen; i++) {
            if(mp[s[i]]>0 && cur[s[i]]<mp[s[i]])
                match++;
            cur[s[i]]++;
        }
        if(match==plen)
            ret.push_back(0);
        for(int i=plen; i<slen; i++) {
            if(mp[s[i]]>0 && cur[s[i]]<mp[s[i]])
                match++;
            cur[s[i]]++;
            if(mp[s[i-plen]]>0 && cur[s[i-plen]]<=mp[s[i-plen]])
                match--;
            cur[s[i-plen]]--;
            if(match==plen)
                ret.push_back(i-plen+1);
        }
        return ret;
    }
};
```



## 440.字典序的第K小数字

>给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。
>
>- `1 <= k <= n <= 109`

字典树。

我们可以利用字典树的特性将所有小于等于 n 的数字按照字典序的方式进行重建。

<img src="440-1.png">

通过观察可以发现，前序遍历该字典树即可得到字典序从小到大的数字序列，遍历到第 *k* 个节点即为第 *k* 小的数字。

显然如果按照朴素的方式去遍历，肯定会超时。因此，在每个节点处，我们先计算出该节点下的子树总共含有多少个节点，计为cnt。假设我们现在要向后找第k个元素，如果 k <= cnt，那说明这个节点一定在该子树中，如果 k>cnt ，那么我们就跳过该子树。跳过该子树的方法就是直接将当前数字加一。

时间复杂度 $O(log^2n)$ 。每次计算子树下的节点数目的搜索深度最大为 $log⁡_{10}n$ ，最多搜索 $log_{10}n$ 次，每一层最多需要计算 10 次，最多需要时间 $O(10\times logn \times logn)$ 。

```c++
class Solution {
public:

    typedef long long ll;

    ll getNodesCnt(ll cur, ll n) {
        ll ret = 0;
        ll left = cur;
        ll right = cur;
        while(left<=n) {
            ret += min(right, n)-left+1;
            left = left*10;
            right = right*10+9;
        }
        return ret;
    }

    int findKthNumber(int n, int k) {
        ll cur = 1;
        while(k>1) {
            ll cnt = getNodesCnt(cur, n);
            if(cnt >= k) {
                cur = cur*10;
                k--;
            } else {
                cur++;
                k -= cnt;
            }
        }
        return cur;
    }
};
```





## 446.等差数列划分 II - 子序列

>给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。
>
>如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。
>
>题目数据保证答案是一个 **32-bit** 整数。
>
>- `1 <= nums.length <= 1000`
>- `-231 <= nums[i] <= 2^31 - 1`

动态规划。定义 $dp[i][j]:=以nums[i]结尾，j为公差的长度大于等于2的等差子序列的个数$ 。

则有 $dp[i][nums[i]-nums[j]]\  +=  dp[j][nums[i]-nums[j]]+1$ 。

由于最后dp数组中的子序列个数是长度大于等于2的，而题目要求长度大于等于3，因此需要在递推过程中维护答案。另外，由于公差的范围很大，所以dp数组的第二维可以使用哈希表代替。

时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    typedef long long int ll;
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n=nums.size();
        vector<unordered_map<ll, ll>> dp(n);
        ll ret=0;
        for(int i=1; i<n; i++)
        {
            for(int j=0; j<i; j++)
            {
                ll difference = (ll)nums[i] - (ll)nums[j];
                dp[i][difference] += dp[j][difference]+1;
                ret += dp[j][difference];
            }
        }
        
        return ret;
    }
};
```





## 452.用最少数量的箭引爆气球

>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
>
>一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
>给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。
>
>- `1 <= points.length <= 10^5`
>- `points[i].length == 2`
>- `-2^31 <= xstart < xend <= 2^31 - 1`

贪心算法。此题本质上与435题相同。由于要射爆所有的气球，考虑右边界最小的气球 $[start,end]$ ，第一支箭一定在这个范围内。那么如何让这支箭发挥最大的作用呢？为了让这支箭尽可能多射到气球，应该在end的位置射出。于是左边界小于等于end的气球全部被射爆。剩下的问题和原问题相同，找到下一个右边界最小的气球，在它的右边界射出第二支箭，以此类推。时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b)
    {
        return a[1]<b[1];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int sz = points.size();
        int right = points[0][1];
        int res=1;
        for(int i=1; i<sz; i++)
        {
            vector<int>& point = points[i];
            if(point[0]>right)
            {
                right = point[1];
                res++;
            }
        }
        return res;
    }
};
```



## 455.分发饼干

>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
>对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
>- `1 <= g.length <= 3 * 10^4`
>- `0 <= s.length <= 3 * 10^4`
>- `1 <= g[i], s[j] <= 2^31 - 1`

贪心算法。首先尽可能满足胃口小的孩子，然后尽可能先用尺寸小的饼干。时间复杂度 $O(n+m)$ 。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int gsz = g.size();
        int ssz = s.size();
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int sidx = 0;
        int satisfied = 0;
        for(int i=0; i<gsz; i++)
        {
            while(sidx<s.size() && s[sidx]<g[i])
                sidx++;
            if(sidx==s.size())
                break;
            else
            {
                satisfied++;
                sidx++;
            }
        }
        return satisfied;
    }
};
```





## 458.可怜的小猪

>有` buckets` 桶液体，其中 **正好有一桶** 含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 `minutesToTest` 分钟时间来确定哪桶液体是有毒的。
>
>喂猪的规则如下：
>
>1. 选择若干活猪进行喂养
>2. 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
>3. 小猪喝完水后，必须有 `minutesToDie` 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。
>4. 过了 `minutesToDie` 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。
>5. 重复这一过程，直到时间用完。
>
>给你桶的数目 `buckets` ，`minutesToDie` 和 `minutesToTest` ，返回 *在规定时间内判断哪个桶有毒所需的 **最小** 猪数* 。
>
>- `1 <= buckets <= 1000`
>- `1 <= minutesToDie <= minutesToTest <= 100`

进制法。由题目知道，我们可以进行 $times = \lfloor \frac{minutesToDie}{minutesToTest} \rfloor$ 轮实验。 $buckets$ 桶液体需要多少只小猪并不好计算，我们可以反过来计算有 n 只小猪时，$times$ 轮实验最多可以从多少桶液体中找出有毒的那桶。设 n 只小猪经过 $times$ 轮实验可以分别 $f(n)$ 桶液体，那我们只需要找到最小的 n ，满足 $f(n)≥buckets$ 即可。

现在由于一只猪最多可以喝 $times$ 轮（每一轮里可以喝若干桶液体）。考虑第一只猪，我们把所有液体分为 $times+1$ 等份，编号为0的那份不喝，然后每一轮实验让第一只猪喝一份，那么如果该猪在第k天死去，证明有毒液体在第k份中。这样来看，一只猪最多可以把目标范围缩小到原来的  $\frac{1}{times}$ 。这里要注意，第二只猪并不是在第一只猪做完所有实验才开始实验的（这样显然时间不够），假设第一只猪把所有液体分为了编号为 $0,1,\cdots,times$ 的若干等份，那么第二只猪可以将每一份都继续分为 $times+1$ 等份。如果总过用 n 只猪，那么为了让最终目标范围为1，一开始最多有 $(times+1)^n$ 桶液体。

上面的思路其实就是进制法。首先我们给所有液体编上号，在十进制下依次为 $0,1,2,3,\cdots$  。在 $times+1$ 进制下，每桶液体的编号可以表示为 $Digit_{n-1}Digit_{n-2}\cdots Digit_0$ 。那么每一只猪可以对应一位数字。设编号为k的猪对应$Digit_k$ ，那么在第x轮，它喝下所有编号满足 $Digit_k=x$ 的液体。这样如果该猪在第y轮死去，我们就可以通过该猪确定有毒液体的编号中 $Digit_k=y$ 。所以总过 n 只猪可以确定有毒液体的编号的 n 位，所以最多有 $(times+1)^n$ 种不同的编号。

时间复杂度 $O(log_{times}^n) = O(logn)$ 。 

```c++
class Solution {
public:
    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        if(buckets==1)
            return 0;
        int drinkTimes = minutesToTest/minutesToDie+1;
        int pigCnt = 1;
        int test = drinkTimes;
        while(test<buckets)
        {
            pigCnt++;
            test *= drinkTimes;
        }
        return pigCnt;
    }
};
```





## 464.我能赢吗

>在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过** 100 的玩家，即为胜者。
>
>如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？
>
>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。
>
>给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。
>
>- `1 <= maxChoosableInteger <= 20`
>- `0 <= desiredTotal <= 300`

博弈论+记忆化搜索。

由于每个状态中要维护各个数字是否已经被选，我们用一个int类型的变量表数字的被选情况，当该数字的第i位为1时，代表数字i已经被选了。每个状态不需要记录总共的数字和，因为被选的数字隐含了和的大小。为了避免重复搜索，我们使用哈希表记录搜索过的状态。

在游戏中途，假设已经被使用的数字的集合为 idx ，这些数字的和为 cur 。当某方行动时，如果他能在未选择的数字中选出一个 i ，使得 i+cur≥desiredTotal，则他能获胜。否则，需要继续通过搜索来判断获胜方。在剩下的数字中，如果他能选择一个 i ，使得对方在接下来的局面中无法获胜，则他会获胜。否则，他会失败。

注意，上面的情况无法判断平局。所以我们在最开始先算数字总和是否能达到目标，如果能达到，则不会出现平局。

时间复杂度 $O(n2^n)$ 。

```c++
class Solution {
public:
    static const int N=20;
    unordered_map<int, bool> memo;
    int base[21];
    bool nums[21];

    bool dfs(int idx, int total, int maxChoosableInteger, int desiredTotal)
    {
        if(memo.count(idx))
            return memo[idx];
        for(int i=1; i<=maxChoosableInteger; i++)
        {
            if(nums[i]==true)
                continue;
            nums[i] = true;
            int nxtTotal = total+i;
            int nxtIdx = idx+base[i];
            if(nxtTotal>=desiredTotal)
            {
                nums[i] = false;
                memo[idx] = true;
                return true;
            }
            else if(!dfs(nxtIdx, nxtTotal, maxChoosableInteger, desiredTotal))
            {
                nums[i] = false;
                memo[idx] = true;
                return true;
            }
            nums[i] = false;
        }
        memo[idx] = false;
        return false;
    }

    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        int baseNum = 1;
        for(int i=1; i<=maxChoosableInteger; i++)
        {
            base[i] = baseNum;
            baseNum <<= 1;
        }
        if( (1+maxChoosableInteger)*maxChoosableInteger/2<desiredTotal )
            return false;
        return dfs(0, 0, maxChoosableInteger, desiredTotal);
    }
};
```





## 466.统计重复个数

>定义 `str = [s, n]` 表示 `str` 由 `n` 个字符串 `s` 连接构成。
>
>- 例如，`str == ["abc", 3] =="abcabcabc"` 。
>
>如果可以从 `s2` 中删除某些字符使其变为 `s1`，则称字符串 `s1` 可以从字符串 `s2` 获得。
>
>- 例如，根据定义，`s1 = "abc"` 可以从 `s2 = "ab***dbe***c"` 获得，仅需要删除加粗且用斜体标识的字符。
>
>现在给你两个字符串 `s1` 和 `s2` 和两个整数 `n1` 和 `n2` 。由此构造得到两个字符串，其中 `str1 = [s1, n1]`、`str2 = [s2, n2]` 。
>
>请你找出一个最大整数 `m` ，以满足 `str = [str2, m]` 可以从 `str1` 获得。
>
>- `1 <= s1.length, s2.length <= 100`
>- `s1` 和 `s2` 由小写英文字母组成
>- `1 <= n1, n2 <= 10^6`

找循环节。由于题目中的 n1 和 n2 都很大，因此我们无法真正把 S1 = [s1, n1] 和 S2 = [s2, n2] 都显式地表示出来。由于这两个字符串都是不断循环的，因此我们可以考虑找出 S2 在 S1 中出现的循环节，如果我们找到了循环节，那么我们就可以很快算出 str2 在 str1 中出现了多少次了。

由于S1和S2都是不断循环的，所以总会出现一个循环节，其中有固定数量的S1和S2。而在这个循环节出现之前，开头可能还有若干S1，其中包含若干S2。因此，为了找到循环节，我们使用哈希表记录当前匹配到了S2的第idx个字符。我们每次多查找一个S1，如果有两次查找都匹配到了S2的第idx个字符，那么说明第一个循环节已经遍历完成。

当我们找出循环节后，我们即可知道str1中包含的循环节的数量，以及在开头和循环节中出现前的 S2 的数量，当然，str1的末尾可能会存在不是一个完整循环节的部分，这部分我们需要单独拿出来遍历处理统计。

时间复杂度  $O(|s_1|\times|s_2|)$ 。

```c++
class Solution {
public:
    typedef pair<int, int> P;
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        if(n1==0)
            return 0;
        int s1cnt = 0;
        int s2cnt = 0;
        int idx = 0;
        // recall 是我们用来找循环节的变量，它是一个哈希映射
        // 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 idx 个字符
        // 如果我们之前遍历了 s1cnt' 个 s1 时，匹配到的是第 s2cnt' 个 s2 中同样的第 idx 个字符，那么就有循环节了
        // 我们用 (s1cnt', s2cnt', idx) 和 (s1cnt, s2cnt, idx) 表示两次包含相同 idx 的匹配结果
        // 那么哈希映射中的键就是 idx，值就是 (s1cnt', s2cnt') 这个二元组
        // 循环节就是；
        //    - 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2
        //    - 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2
        // 那么还会剩下 (n1 - s1cnt') % (s1cnt - s1cnt') 个 s1, 我们对这些与 s2 进行暴力匹配
        // 注意 s2 要从第 idx 个字符开始匹配
        unordered_map<int, P> recall;
        P preCnt, loopCnt;
        while(true) 
        {
            // 多遍历一个 s1，看看能不能找到循环节
            s1cnt++;
            for(int i=0; i<s1.size(); i++)
            {
                if(s1[i]==s2[idx])
                {
                    idx++;
                    if(idx==s2.size())
                    {
                        s2cnt++;
                        idx = 0;
                    }
                }
            }

            // 还没有找到循环节，所有的 s1 就用完了
            if(s1cnt==n1)
                return s2cnt/n2;
        
            // 出现了之前的 idx，表示找到了循环节
            if(recall.count(idx))
            {
                // 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2
                preCnt = recall[idx];
                // 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2
                loopCnt = P(s1cnt-preCnt.first, s2cnt-preCnt.second);
                break;
            }
            else
            {
                recall[idx] = P(s1cnt, s2cnt);
            }
        }
        // ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 preCnt 和 loopCnt
        int ret = preCnt.second + (n1-preCnt.first)/loopCnt.first * loopCnt.second;
        // S1 的末尾还剩下一些 s1，我们暴力进行匹配
        int rest = (n1-preCnt.first) % loopCnt.first;
        for(int i=0; i<rest; i++)
        {
            for(int j=0; j<s1.size(); j++) 
            {
                if(s1[j] == s2[idx])
                {
                    idx++;
                    if(idx == s2.size())
                    {
                        ret++;
                        idx = 0;
                    }
                }
            }
        }
        // S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2
        ret /= n2;
        return ret;
    }
};
```





## 467.环绕字符串中唯一的子字符串

>定义字符串 `base` 为一个 `"abcdefghijklmnopqrstuvwxyz"` 无限环绕的字符串，所以 `base` 看起来是这样的：
>
>- `"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."`.
>
>给你一个字符串 `s` ，请你统计并返回 `s` 中有多少 **不同****非空子串** 也在 `base` 中出现。
>
>- `1 <= s.length <= 105`
>- s 由小写英文字母组成

动态规划。如果此题不要求子串非空，那么我们使用动态规划，维护以 s[i] 结尾且在base中的子串的数量即可。但此题要求不同的非空子串，那么我们就需要对子串进行去重。考虑到在base中出现的串有唯一顺序，那么只需要结尾字符和它的长度，我们就能唯一确定该串。因此，我们定义 $dp[i]:=以s[i]结尾且在base中的子串的长度最大值$ 。注意，这里 $dp[i]$ 代表的子串是在s中 s[i] 位置处的子串，而不是所有以字符 $s[i]$ 结尾的子串。为了去重，我们需要单独使用一个数组维护以各个字母结尾的子串的长度的最大值。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int findSubstringInWraproundString(string s) {
        if(s.size()==0)
            return 0;
        
        vector<int> dp(s.size());
        vector<int> maxLen(26, 0);
        dp[0] = 1;
        maxLen[s[0]-'a'] = 1;
        for(int i=1; i<s.size(); i++)
        {
            if(s[i]-'a' == (s[i-1]-'a'+1)%26)
                dp[i] = dp[i-1]+1;
            else
                dp[i] = 1;
            maxLen[s[i]-'a'] = max(maxLen[s[i]-'a'], dp[i]);
        }
        int ret=0;
        for(int i=0; i<26; i++)
            ret += maxLen[i];
        return ret;
    }
};
```

 

## 470.用Rand7()实现Rand10()

>给定方法 `rand7` 可生成 `[1,7]` 范围内的均匀随机整数，试写一个方法 `rand10` 生成 `[1,10]` 范围内的均匀随机整数。
>
>你只能调用 `rand7()` 且不能调用其他方法。请不要使用系统的 `Math.random()` 方法。
>
>每个测试用例将有一个内部参数 `n`，即你实现的函数 `rand10()` 在测试时将被调用的次数。请注意，这不是传递给 `rand10()` 的参数。
>
>- `1 <= n <= 10^5`

此题的本质是用1/7的概率生成1/10的概率。

我们可以用两次rand7生成一个7进制数，第一次生成十位(严格来讲此处叫7位)，第二次生成个位。由于rand7生成的是1-7，所以我们将rand7-1就可以生成0-6。生成的这个数在十进制中是在0-48均匀分布的。于是，我们可以取0～39这40个数，返回个位数字。

该方法的缺点是，如果随机数一直生成大于39的数，那么函数一直无法返回。

```c++
// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    int rand10() {
        int row, col, idx;
        do {
            row = rand7()-1;
            col = rand7()-1;
            idx = row*7 + col;
        } while (idx >= 40);
        return 1 + idx%10;
    }
};
```







## 472.连接词

>给你一个 **不含重复** 单词的字符串数组 `words` ，请你找出并返回 `words` 中的所有 **连接词** 。
>
>**连接词** 定义为：一个完全由给定数组中的至少两个较短单词（不一定是不同的两个单词）组成的字符串。
>
>- `1 <= words.length <= 10^4`
>- `1 <= words[i].length <= 30`
>- `words[i]` 仅由小写英文字母组成。
>- `words` 中的所有字符串都是 **唯一** 的。
>- `1 <= sum(words[i].length) <= 10^5`

字典树+记忆化搜索。

判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。

为了方便处理，首先将数组 words 按照字符串的长度递增的顺序排序，排序后可以确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。在将数组排序之后，遍历数组，跳过空字符串，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入结果数组，如果不是连接词则将该单词加入字典树。

判断一个单词是不是连接词的做法是在字典树中搜索。从该单词的第一个字符（即下标 0 处的字符）开始，在字典树中依次搜索每个字符对应的结点，可能有以下几种情况：

+ 如果一个字符对应的结点是单词的结尾，则找到了一个更短的单词，从该字符的后一个字符开始搜索下一个更短的单词；
+ 如果一个字符对应的结点在字典树中不存在，则当前的搜索结果失败，回到上一个单词的结尾继续搜索。

为了降低时间复杂度，需要使用记忆化搜索。对于每个单词，创建与单词相同长度的数组记录该单词的每一个下标是否被访问过，然后进行记忆化搜索。搜索过程中，如果一个下标已经被访问过，则从该下标到末尾的部分一定不是由给定数组中的一个或多个非空单词组成（否则上次访问时已经可以知道当前单词是连接词），只有尚未访问过的下标才需要进行搜索。

时间复杂度 $O(nlogn+\Sigma_{0≤i<n}l_i)$ ，其中 $l_i$ 为单词  $word[i]$ 的长度。

```c++
class Solution {
public:

    class Trie
    {
    private:
        Trie* nxt[26];
        bool isEnd;
    public:
        Trie()
        {
            isEnd = false;
            for(int i=0; i<26; i++)
                nxt[i] = nullptr;
        }

        void insert(string& word)
        {
            Trie* pTrie = this;
            for(int i=0; i<word.size(); i++)
            {
                int idx = word[i]-'a';
                if(pTrie->nxt[idx]==nullptr)
                    pTrie->nxt[idx] = new Trie();
                pTrie = pTrie->nxt[idx];
                if(i==word.size()-1)
                    pTrie->isEnd = true;
            }
        }

        bool dfs(string& word, int index, vector<bool>& vis)
        {
            if(index == word.size())
                return true;
            if(vis[index])
                return false;
            vis[index] = true;
            Trie* pTrie = this;
            for(int i=index; i<word.size(); i++)
            {
                int idx = word[i]-'a';
                if(pTrie->nxt[idx]==nullptr)
                    return false;
                pTrie = pTrie->nxt[idx];
                if(pTrie->isEnd && dfs(word, i+1, vis))
                    return true;
            }
            return false;
        }

    };

    static bool cmp(string& a, string& b)
    {
        return a.size()<b.size();
    }

    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        sort(words.begin(), words.end(), cmp);
        Trie trie;
        vector<string> ret;
        for(int i=0; i<words.size(); i++)
        {
            string& word = words[i];
            if(word.size()==0)
                continue;
            vector<bool> vis(word.size(), false);
            if(trie.dfs(word, 0, vis))
                ret.push_back(word);
            else
                trie.insert(word);
        }
        return ret;
    }
};
```





## 473.火柴拼正方形

>你将得到一个整数数组 `matchsticks` ，其中 `matchsticks[i]` 是第 `i` 个火柴棒的长度。你要用 **所有的火柴棍** 拼成一个正方形。你 **不能折断** 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 **使用一次** 。
>
>如果你能使这个正方形，则返回 `true` ，否则返回 `false` 。
>
>- `1 <= matchsticks.length <= 15`
>- `1 <= matchsticks[i] <= 10^8`

动态规划+状态压缩。

首先判断所有火柴长度和是否为4的倍数，如果不是的话，一定不能拼成正方形。假设总长度为 $total$ ，那么每条边的长度应该为 $\frac{total}{4}$ 。

现在我们给正方形四条边编上号，然后每次拿一根火柴，必须把一条边拼好后才能放入下一条边。这样的话，对于一个火柴的子集，使用该子集的全部火柴拼正方形，如果正好可以拼出x条边，第x+1条边拼了长度为y，那么x和y与这些火柴的具体拼法无关，因为该子集中火柴的长度和是固定的。又因为这些火柴最多只能拼出四条边，所以我们不用关心已经拼出了多少条边，只需要保证当前边的长度不会超出 $total/4$ ，然后每次达到 $total/4$ 就开启一条新边即可。另外，我们使用int类型的数字代表选取的子集。它的前n个比特位中，每个比特位代表一根火柴的选取。

定义 $dp[i]:=选取了数字i代表的火柴集合拼正方形，最后一条边的长度。如果不能正好拼出则为-1$ 。

这里我们遍历 $i$ 集合中为1的比特位 $j$ ，代表假如最后一根火柴是这一根，那么它能否从去掉该火柴的状态加入该火柴，来达到当前状态。只要某一个比特位满足条件，那么当前状态即可求出，就不用再遍历其他比特位。

时间复杂度 $O(n2^n)$ 。

```c++
class Solution {
public:
    bool makesquare(vector<int>& matchsticks) {
        int total = accumulate(matchsticks.begin(), matchsticks.end(), 0);
        if(total==0 || total%4!=0)
            return false;
        total /= 4;
        int n = matchsticks.size();
        vector<int> dp(1<<n, -1);
        dp[0] = 0;
        for(int i=0; i<(1<<n); i++)
        {
            int digit=1;
            for(int j=0; j<n; j++)
            {
                if(i&digit)
                {
                    if(dp[i-digit]>=0 && dp[i-digit]+matchsticks[j]<=total)
                    {
                        dp[i] = (dp[i-digit]+matchsticks[j])%total;
                        break;
                    }
                }
                digit <<= 1;
            }
        }
        return dp[(1<<n)-1]==0;
    }
};
```





## 474.一和零

>给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。
>
>请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1`。
>
>如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。
>
>- `1 <= strs.length <= 600`
>- `1 <= strs[i].length <= 100`
>- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
>- `1 <= m, n <= 100`

动态规划。这道题是01背包的扩展形式。每个物品的价值为1，而限制条件有两个，即0和1的个数。所以我们只需要增加一维的限制条件即可。

定义 $dp[k][i][j]:=在前k个字符串中，最多有i个0和j个1时，子集的最大长度$ 。

时间复杂度 $O(lmn+L)$ ，其中 $l$ 是数组 $strs$ 的长度，$L$ 是所有字符串长度的和。

```c++
class Solution {
public:
    
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        vector<pair<int, int>> pairs(strs.size());
        for(int i=0; i<strs.size(); i++)
        {
            pairs[i].first = 0;
            pairs[i].second = 0;
            for(int j=0; j<strs[i].size(); j++)
            {
                if(strs[i][j]=='0')
                    pairs[i].first++;
                else
                    pairs[i].second++;
            }
        }
        for(int k=0; k<pairs.size(); k++)
        {
            for(int i=m; i>=0; i--)
            {
                for(int j=n; j>=0; j--)
                {
                    if(pairs[k].first<=i && pairs[k].second<=j)
                        dp[i][j] = max(dp[i][j], dp[i-pairs[k].first][j-pairs[k].second]+1);
            
                }
            }
        }
        return dp[m][n];
    }
};
```





## 486.预测赢家

>给你一个整数数组 `nums` 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。
>
>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 `0` 。每一回合，玩家从数组的任意一端取一个数字（即，`nums[0]` 或 `nums[nums.length - 1]`），取到的数字将会从数组中移除（数组长度减 `1`）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。
>
>如果玩家 1 能成为赢家，返回 `true` 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 `true` 。你可以假设每个玩家的玩法都会使他的分数最大化。
>
>- `1 <= nums.length <= 20`
>- `0 <= nums[i] <= 10^7`

方法一：DFS+记忆化搜索。

按照得分来说游戏有三种结果，玩家1获胜，玩家2获胜和平局。题目认为得分相同时，玩家1获胜，那么就没有平局。但是递归搜索时，为了不区分两个玩家，我们按照有3种结果去搜索。在记忆状态时，需要记录当前分数和剩余数字的起始和结束坐标。DFS搜索在当前分数和剩余start到end数字的情况下，是否可以获胜。

每拿取一个数字，有从头和尾拿的两种选择。时间复杂度  $O(2^n)$ 。

```c++
class Solution {
public:
    
    static const int N=25;
    unordered_map<int, int> memo[N][N];
    int sumScore[N][N];
    int totalScore;


    int dfs(vector<int>& nums, int front, int back, int score)
    {
        if(front>back)
            return -1;

        if(memo[front][back].count(score))
            return memo[front][back][score];

        if((score+max(nums[front], nums[back]))*2>totalScore)
        {
            memo[front][back][score]=1;
            return 1;
        }
        if(front==back)
        {
            if((score+nums[front])*2<totalScore)
            {
                memo[front][back][score] = -1;
                return -1;
            }
            else
            {
                memo[front][back][score] = 0;
                return 0;
            }
        }
        if(dfs(nums, front+1, back, totalScore-sumScore[front][back]-score)<0
            || dfs(nums, front, back-1, totalScore-sumScore[front][back]-score)<0)
        {
            memo[front][back][score] = 1;
            return 1;
        }
        else if(dfs(nums, front+1, back, totalScore-sumScore[front][back]-score)==0
            || dfs(nums, front, back-1, totalScore-sumScore[front][back]-score)==0 )
        {
            memo[front][back][score] = 0;
            return 0;
        }
        else
        {
            memo[front][back][score] = -1;
            return -1;
        }
    }

    bool PredictTheWinner(vector<int>& nums) {
        totalScore = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        for(int i=0; i<n; i++)
        {
            sumScore[i][i] = nums[i];
            for(int j=i+1; j<n; j++)
                sumScore[i][j] = sumScore[i][j-1]+nums[j]; 
        }
        return dfs(nums, 0, n-1, 0)>=0;
    }
};
```

方法二：递归。

可以只维护一个变量，即玩家1的分数与玩家2的分数的差。在搜索过程中引入角色，玩家1选择的数字使得差变大，玩家2选择的数字使得差变小。

时间复杂度 $O(2^n)$ 。

```c++
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        return total(nums, 0, nums.size() - 1, 1) >= 0;
    }

    int total(vector<int>& nums, int start, int end, int turn)
    {
        if(start == end)
            return nums[start]*turn;
    
        int scoreStart = nums[start]*turn + total(nums, start+1, end, -turn);
        int scoreEnd = nums[end]*turn + total(nums, start, end-1, -turn);
        if(turn>0)
            return max(scoreStart, scoreEnd);
        else
            return min(scoreStart, scoreEnd);
    }
};
```

方法三：动态规划。

上面两个方法存在大量重复计算，因此时间复杂度很高。由于存在重复子问题，因此可以使用动态规划降低时间复杂度。

定义 $dp[i][j]:=当数组剩下的部分为下标 i 到下标 j 时，即在下标范围 [i,j] 中，当前玩家与另一个玩家的分数之差的最大值$ 。于是 $dp[i][j]=max(nums[i]-dp[i+1][j],nums[j]-dp[i]-j-1)$ 。 最后判断 $dp[0][n-1]$ 的值，如果大于或等于 0，则先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。

时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for(int i=0; i<n; i++)
            dp[i][i] = nums[i];
        
        for(int i=0; i<=n-1; i++)
        {
            for(int j=i-1; j>=0; j--)
                dp[j][i] = max(nums[j]-dp[j+1][i], nums[i]-dp[j][i-1]);
        }
        return dp[0][n-1] >= 0;
    }
};
```





## 488.祖玛游戏

>你正在参与祖玛游戏的一个变种。
>
>在这个祖玛游戏变体中，桌面上有 **一排** 彩球，每个球的颜色可能是：红色 `'R'`、黄色 `'Y'`、蓝色 `'B'`、绿色 `'G'` 或白色 `'W'` 。你的手中也有一些彩球。
>
>你的目标是 **清空** 桌面上所有的球。每一回合：
>
>- 从你手上的彩球中选出 **任意一颗** ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。
>- 接着，如果有出现三个或者三个以上且颜色相同的球相连的话，就把它们移除掉。
>    - 如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。
>- 如果桌面上所有球都被移除，则认为你赢得本场游戏。
>- 重复这个过程，直到你赢了游戏或者手中没有更多的球。
>
>给你一个字符串 `board` ，表示桌面上最开始的那排球。另给你一个字符串 `hand` ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 **最少** 球数。如果不能移除桌上所有的球，返回 `-1` 。
>
>- `1 <= board.length <= 16`
>- `1 <= hand.length <= 5`
>- `board` 和 `hand` 由字符 `'R'`、`'Y'`、`'B'`、`'G'` 和 `'W'` 组成
>- 桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球

BFS。

因为插入球的颜色和位置的选择是多样的，选择的影响也可能在多次消除操作之后才能体现出来，所以通过贪心方法根据当前情况很难做出全局最优的决策。实际每次插入一个新的小球时，并不保证插入后一定可以消除，因此我们需要搜索和遍历所有可能的插入方法。

我们不妨规定，每一种不同的桌面上球的情况和手中球的情况的组合都是一种不同的状态。对于相同的状态，其清空桌面上球所需的回合数总是相同的；而不同的插入球的顺序，也可能得到相同的状态。因此，如果使用深度优先搜索，则需要使用记忆化搜索，以避免重复计算相同的状态。因为只需要找出需要回合数最少的方案，因此使用广度优先搜索可以得到可以消除桌面上所有球的方案时就直接返回结果，而不需要继续遍历更多需要回合数更多的方案。

使用队列来维护需要处理的状态队列，使用哈希集合存储已经访问过的状态。每一次取出队列中的队头状态，考虑其中所有可以插入球的方案，如果新方案还没有被访问过，则将新方案添加到队列的队尾。

直接实现上面的BFS的话，时间复杂度很高。因此我们可以发现有许多的剪枝，具体在代码注释中分析。

不使用剪枝的时间复杂度 $O(nA_{m+n}^m)$ ，其中n为桌上的球的数量，m为手中的球的数量。对m个球总共有 $m!$ 种选择顺序，对每一种顺序，插入桌上的n个球，总共有 $C_{m+n}^m$ 种插入方法，所以总的状态数为 $m!\times C_{m+n}^m = A_{m+n}^m$ 。每种状态需要 $O(n)$ 的时间消除桌面上的球。

```c++
class Solution {
public:
    typedef pair<string, string> P;

    string eliminate(string& s)
    {
        vector<pair<char,int>> st;
        for(int i=0; i<s.size(); i++)
        {
            if(!st.empty())
            {
                if(st.back().first==s[i])
                    st.back().second++;
                else
                {
                    if(st.back().second>=3)
                        st.pop_back();
                    if(!st.empty() && st.back().first==s[i])
                        st.back().second++;
                    else
                        st.push_back(make_pair(s[i], 1));
                }
            }
            else
                st.push_back(make_pair(s[i], 1));
        }
        if(!st.empty() && st.back().second>=3)
            st.pop_back();
        string ret;
        for(int i=0; i<st.size(); i++)
        {
            for(int j=0; j<st[i].second; j++)
                ret.push_back(st[i].first);
        }
        return ret;
    }

    int findMinStep(string board, string hand) {
        sort(hand.begin(), hand.end());
        unordered_set<string> memo;
        queue<P> que;
        que.push(P(board, hand));
        int ret=0;
        while(!que.empty())
        {
            int sz = que.size();
            ret++;
            while(sz--)
            {
                P front = que.front();
                que.pop();
                string& curBoard = front.first;
                string& curHand = front.second;
                for(int i=0; i<curHand.size(); i++)
                {
                    //剪枝1:已经搜索过该颜色
                    if(i>0 && curHand[i]==curHand[i-1])
                        continue;
                    for(int j=0; j<=curBoard.size(); j++)
                    {
                        if(j==0) //当要插入的位置在开头
                        {
                            //剪枝2:，如果要插入的球与开头的球不同，该操作完全可以
                            //推迟到开头（或末尾）被消除后
                            if(curBoard[j]!=curHand[i])
                                continue;
                        }
                        else if( j>0 && j<curBoard.size() ) //当要插入的位置在中间
                        {
                            //当左侧的球与手里的球相同时，与插入位置在j-1是相同的，所以可以剪枝
                            if(curBoard[j-1]==curHand[i])
                                continue;
                            //现在左侧的球与手里的球不同
                            //当右侧的球与手里的球相同，可以继续往下搜
                            //当右侧的球与手里的球也不同，有两种情况：
                            //1.左右两侧的球相同，这样在中间插入一个球可以把两个颜色相同的球隔开，让他们分两次消去，可以继续搜
                            //2.左右两侧的球不同，这样插入的球无法改变消除顺序，可以剪枝
                            if(curBoard[j]!=curHand[i] && curBoard[j-1]!=curBoard[j])
                                continue;
                        }
                        else //当要插入的位置在末尾
                        {
                            //如果手里的球和末尾的球相同，那么与插入位置为j-1的情况是相同的，可以剪枝
                            //如果手里的球和末尾的球不同，那么当前操作可以推迟到末尾的球被消去后，所以当前操作可以剪枝
                            continue;
                        }

                        //现在插入手里的球
                        string nBoard = curBoard.substr(0, j)+curHand[i]+curBoard.substr(j);
                        nBoard = eliminate(nBoard);
                        //cout<<curBoard+"在"+to_string(j)+"插入"+curHand[i]+"="+nBoard<<endl;
                        if(nBoard.size()==0)
                            return ret;
                        string nHand = curHand.substr(0, i)+curHand.substr(i+1);
                        if(nHand.size()>0 && memo.count(nBoard+" "+nHand)==0)
                            que.push(P(nBoard, nHand));
                        memo.insert(nBoard+" "+nHand);
                    }
                }
            }
        }
        return -1;
    }
};
```





## 494.目标和

>给你一个整数数组 `nums` 和一个整数 `target` 。
>
>向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：
>
>- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1`之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
>
>返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。
>
>- `1 <= nums.length <= 20`
>- `0 <= nums[i] <= 1000`
>- `0 <= sum(nums[i]) <= 1000`
>- `-1000 <= target <= 1000`

方法一：回溯+记忆化搜索

使用回溯可以遍历所有的表达式。同时记录下后x个数字可以组合出y的方法数，以减少重复搜索。

时间复杂度 $O(2^n)$ 。

```c++
class Solution {
public:
    
    static const int N=21;
    unordered_map<int, int> memo[N];
    
    int dfs(vector<int>& nums, int cur, int idx, int target)
    {
        if(idx==nums.size())
        {
            if(cur==target)
                return 1;
            else
                return 0;
        }
        if(memo[idx].count(target-cur))
        {
            return memo[idx][target-cur];
        }
        int positive = dfs(nums, cur+nums[idx], idx+1, target);
        int negative = dfs(nums, cur-nums[idx], idx+1, target);
        if(positive>0 || negative>0)
        {
            memo[idx][target-cur] = positive+negative;
            return positive+negative;
        }
        else
        {
            memo[idx][target-cur] = 0;
            return 0;
        }
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        return dfs(nums, 0, 0, target);
    }
};
```

方法二：动态规划。

数组中每个数字的系数为-1或1，那么就有可能有负数，这在后面的递推中不好处理，因此我们可以将target加上数组的和sum，把系数变为0或2。所以问题就可以变成：

为nums数组中每个数配置系数为0或2，求使得最终的和为target+sum的方案数。

于是可以定义 $dp[i][j]:=前i个数组成j的方案数$ 。那么 $dp[i][j] = dp[i-1][j]+dp[i-1][j-2*nums[i]]$ 。

时间复杂度 $O(n\times (sum+target))$ 。

实现可以使用滚动数组。

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int bound = accumulate(nums.begin(), nums.end(), 0);
        if(abs(target)>bound)
            return 0;
        vector<int> dp(target+bound+1, 0);
        dp[0] = 1;
        if(nums[0]*2<=target+bound)
            dp[nums[0]*2]++;
        for(int i=1; i<nums.size(); i++)
        {
            for(int j=target+bound; j>=nums[i]*2; j--)
            {
                dp[j] += dp[j-nums[i]*2];
            }
        }
        return dp[target+bound];
    }
};
```

