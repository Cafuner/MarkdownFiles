# Leetcode 700-799

[TOC]



## 704.二分查找

>给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
>
>1. 你可以假设 `nums` 中的所有元素是不重复的。
>2. `n` 将在 `[1, 10000]`之间。
>3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

二分查找。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1;
        if(right<left) {
            return -1;
        }
        while(left<right) {
            int mid = (left+right)/2;
            if(nums[mid]<target) {
                left = mid+1;
            }
            else if(nums[mid]>target) {
                right = mid-1;
            } else {
                return mid;
            }
        }
        if(right<left) {
            return -1;
        }
        if(target==nums[left])
            return left;
        return -1;
    }
};
```





## 714.买卖股票的最佳时机含手续费

>给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。
>
>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
>返回获得利润的最大值。
>
>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>
>- `1 <= prices.length <= 5 * 10^4`
>- `1 <= prices[i] < 5 * 10^4`
>- `0 <= fee < 5 * 10^4`

方法一：动态规划

定义状态:


$$
\begin{equation*}
\begin{aligned}
&dp[i][0]:=第i天结束后，手中没有股票能获得的最大收益。\\
&dp[i][1]:=第i天结束后，手中有股票能获得的最大收益。
\end{aligned}
\end{equation*}
$$
于是有递推式：
$$
\begin{equation*}
\begin{aligned}
&dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i]-fee);\\
&dp[i][1]=max(dp[i-1][1], dp[i-1][0]-prices[i]);
\end{aligned}
\end{equation*}
$$
时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    static const int N=1e5+10;
    int dp[N][2];
    int maxProfit(vector<int>& prices, int fee) {
        int sz = prices.size();
        if(sz==0)
            return 0;
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i=1; i<sz; i++)
        {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]);
        }
        return dp[sz-1][0];
    }
};
```

方法二：贪心

维护两个变量：

+ $buy$ 表示在最大化收益的前提下，如果我们手上拥有一支股票，那么它的最低买入价格是多少。一开始，$buy$ 的值为 $prices[0]+fee$ 。
+ $profit$ 表示最大化的收益。

遍历股票价格，进行如下操作：

+ 如果 $prices[i]+fee<buy$ ，那我们肯定不会买股票，因为股价跌了。但此时可以更新 $buy$ ，因为之后如果某一天需要买股票，则可以假设买了当前这一支，花销为 $prices[i]+fee$ 。
+ 如果 $prices[i]>buy$ ，那么我们可以假设之前以 $buy$ 的价格（包含手续费）买入了一支股票，今天可以卖出，净收益为 $prices[i]-buy$ 。考虑到手续费的存在，按照当前的股价卖出股票并不一定最优，因此我们可以提供一个反悔操作，即我们此时没有卖出股票，但由于我们已经把利润计算了，所以返回后再买入一支股票的最低价格应当为 $buy$ 加上此次卖出的利润，即 $prices[i]$ 。
+ 对于其他情况，$prices[i]$ 在区间 $[buy-fee, buy]$ 内，它的价格没有低到我们放弃手上的股票去选择它，也没有高到我们可以通过卖出获得收益，因此我们不进行任何操作。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int sz = prices.size();
        int buy = prices[0]+fee;
        int profit = 0;
        for (int i=1; i<n; i++)
        {
            if(prices[i]+fee < buy)
                buy = prices[i]+fee;
            else if (prices[i] > buy) 
            {
                profit += prices[i]-buy;
                buy = prices[i];
            }
        }
        return profit;
    }
};
```



## 738.单调递增的数字

>当且仅当每个相邻位数上的数字 `x` 和 `y` ，满足 `x <= y` 时，我们称这个整数是**单调递增**的。
>
>给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。
>
>- `0 <= n <= 10^9`

此题题意不明确，题目想要表达的是x在y的左侧。

贪心算法。从左向右遍历这个数字的每一位，当遇到第一个数字减小的时候，先把 $x$ 减一，然后继续向左查找需要减小才能保证递增的数。找到最左边的修改过的数后，该数右侧的数全部置为9即可。

时间复杂度 $O(logn)$ 。

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        
        string s = to_string(n);
        int sz = s.size();
        int num = s[0];
        int idx = 1;
        while(idx<sz)
        {
            if(s[idx]<num)
            {
                idx--;
                s[idx]--;           
                while(idx>0 && s[idx]<s[idx-1])
                {
                    idx--;
                    s[idx]--;
                }
                idx++;
                while(idx<sz)
                {
                    s[idx] = '9';
                    idx++;
                }
            }
            else
            {
                num = s[idx];
                idx++;
            }
        }
        return stoi(s);
    }
};
```



## 739.每日温度

>给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0`来代替。
>
>- `1 <= temperatures.length <= 10^5`
>- `30 <= temperatures[i] <= 100`

单调栈。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    typedef pair<int, int> P;
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<P> st;
        int n = temperatures.size();
        vector<int> ret(n, 0);
        for(int i=0; i<n; i++) {
            while(!st.empty() && st.top().first<temperatures[i]) {
                P p = st.top();
                st.pop();
                ret[p.second] = i-p.second;
            }
            st.push(P(temperatures[i], i));
        }
        return ret;
    }
};
```



## 743.网络延迟时间

>有 `n` 个网络节点，标记为 `1` 到 `n`。
>
>给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。
>
>现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。
>
>- `1 <= k <= n <= 100`
>- `1 <= times.length <= 6000`
>- `times[i].length == 3`
>- `1 <= ui, vi <= n`
>- `ui != vi`
>- `0 <= wi <= 100`
>- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）

单源最短路。Dijkstra算法。

时间复杂度 $O(ElogV)$ 。

```c++
class Solution {
public:
    struct Edge {
        int to;
        int cost;
    };
    typedef pair<int, int> P;

    void dijkstra(vector<vector<Edge>>& G, int n, vector<int>& dis, int k) {
        for(int i=1; i<n+1; i++) {
            dis[i] = -1;
        }
        priority_queue<P, vector<P>, greater<P>> que;
        que.push(P(0, k));
        dis[k] = 0;
        while(!que.empty()) {
            P p = que.top();
            que.pop();
            if(dis[p.second] != -1 && dis[p.second] < p.first) {
                continue;
            }
            auto& edges = G[p.second];
            for(auto& edge : edges) {
                if(dis[edge.to]==-1 || dis[edge.to]>p.first + edge.cost) {
                    dis[edge.to] = p.first + edge.cost;
                    que.push({p.first+edge.cost, edge.to});
                }
            }
        }
    }

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<Edge>> G(n+1);
        for(auto& time : times) {
            int from = time[0];
            int to = time[1];
            int cost = time[2];
            G[from].push_back({to, cost});
        }
        vector<int> dis(n+1, 0);
        dijkstra(G, n, dis, k);
        int ret = -1;
        for(int i=1; i<n+1; i++) {
            if(dis[i] < 0) {
                return -1;
            }
            ret = max(ret, dis[i]);
        }
        return ret;
    }
};
```



## 753.破解保险箱

>有一个需要密码才能打开的保险箱。密码是 `n` 位数, 密码的每一位都是范围 `[0, k - 1]` 中的一个数字。
>
>保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 **最后 `n` 位输入** ，如果匹配，则能够打开保险箱。
>
>- 例如，正确的密码是
>
>    ```
>    "345"
>    ```
>
>    ，并且你输入的是
>
>    ```
>    "012345"
>    ```
>
>    - 输入 `0` 之后，最后 `3` 位输入是 `"0"` ，不正确。
>    - 输入 `1` 之后，最后 `3` 位输入是 `"01"` ，不正确。
>    - 输入 `2` 之后，最后 `3` 位输入是 `"012"` ，不正确。
>    - 输入 `3` 之后，最后 `3` 位输入是 `"123"` ，不正确。
>    - 输入 `4` 之后，最后 `3` 位输入是 `"234"` ，不正确。
>    - 输入 `5` 之后，最后 `3` 位输入是 `"345"` ，正确，打开保险箱。
>
>在只知道密码位数 `n` 和范围边界 `k` 的前提下，请你找出并返回确保在输入的 **某个时刻** 能够打开保险箱的任一 **最短** 密码序列 。
>
>- `1 <= n <= 4`
>- `1 <= k <= 10`
>- `1 <= k^n <= 4096`

Hierholzer算法。

一个可能的密码是n位，那么我们假设将n-1位的数字看作一个节点，将n位的数字看作一条边。构造这样一个图，每个节点的末尾加上0到k-1的一个数字，就会形成一条出边，每个节点的开头加上0到k-1的一个数字，就会形成一条入边。这样一来，这个连通图总共有 k^n-1 个节点，k^n条边。显然这是个有向欧拉图。每一个可能的密码就是图中的一条边，题目要求输出一个序列，使得一定能打开保险箱，就是要遍历所有的边。因此，我们找到一条欧拉回路，输出路径上的边即可。

需要注意下如果n=1要特殊判断。

时间复杂度 $O(k^n)$ 。

```c++
class Solution {
public:

    void hierholzer(string& ret, int cur, int k, unordered_set<int>& vis, int mod) {
        for(int i=0; i<k; i++) {
            int edge = cur*10+i;
            if(vis.count(edge)) {
                continue;
            }
            vis.insert(edge);
            int nxtNode = edge % mod;
            hierholzer(ret, nxtNode, k, vis, mod);
        }
        ret += '0' + cur % 10;
    }

    string crackSafe(int n, int k) {
        if(n == 1) {
            string ret;
            for(int i=0; i<k; i++) {
                ret += '0' + i;
            }
            return ret;
        }
        int mod = pow(10, n-1);
        unordered_set<int> vis;
        string ret;
        hierholzer(ret, 0, k, vis, mod);
        reverse(ret.begin(), ret.end());
        ret = string(n-2, '0') + ret;
        return ret;
    }
};
```





## 757.设置交集大小至少为2

>给你一个二维整数数组 `intervals` ，其中 `intervals[i] = [starti, endi]` 表示从 `starti` 到 `endi` 的所有整数，包括 `starti` 和 `endi` 。
>
>**包含集合** 是一个名为 `nums` 的数组，并满足 `intervals` 中的每个区间都 **至少** 有 **两个** 整数在 `nums` 中。
>
>- 例如，如果 `intervals = [[1,3], [3,7], [8,9]]` ，那么 `[1,2,4,7,8,9]` 和 `[2,3,4,8,9]` 都符合 **包含集合** 的定义。
>
>返回包含集合可能的最小大小。
>
>- `1 <= intervals.length <= 3000`
>- `intervals[i].length == 2`
>- `0 <= starti < endi <= 10^8`

贪心。此题本质上是 *452.用最少数量的箭引爆气球* 的扩展题。在452题中，每个区间只需要有一个数字即可，本题中每个区间需要2个数字。我们直接考虑每个区间需要有m个数字的推广形式，本题中m=2。假设每个区间的长度都大于等于m。

和452题思路相同，将所有区间按照end从小到大排序，那么一开始要从第一个区间中选择m个数，为了让这m个数尽可能落在后面的区间中，应该贪心地选择当前区间最右端的m个数。但是对于后面的区间，情况变得复杂了起来。

1. 首选遇到的问题是，后面的区间需要补充多少个新数字。即假如我们的结果集合中已经有x个数字落在了后一个区间内，那么遍历到后一个区间时只需要补充m-x个新元素。其实，我们只需要维护当前结果集合中最靠右的m个数字。由于这m个数字必然小于等于新区间的右端点，所以只需要知道这m个数字中有多少个大于等于新区间的左端点。因此，我们使用一个双端队列维护结果集合中最靠右的m个数字。队列内部数字是从小到大的。这样在遍历新区间时，如果队列头小于区间左端点，就可以不断弹出队列头。最后队列中剩余的数字数量就是上文提到的x。每次遍历新区间，最多弹出m次，复杂度 $O(m)$ 。
2. 此外，即使我们知道了需要补充m-x个新元素，这些元素也不是直接从区间最右端取的，因为该区间的最右端的部分元素可能已经在结果集合中，此时需要向左补充新元素。因此，我们使用一个哈希表记录已经加入到结果集合中的数字。从区间右端向左遍历，遇到没加入集合的数字就加入，直到加入m-x个新数字。另外，为了保证双端队列中元素的顺序，才向左遍历时，遇到已经在结果结合中的数字时，先把该数字从队列尾弹出，最后再向右遍历把这些数字按顺序入队。每次遍历新区间，最多向左找m次，每次向左是哈希表操作，常数时间，最后向右最多m次，复杂度 $O(m)$ 。

总共n个区间，每个区间要保证覆盖m个数，则复杂度为 $O(nlogn+nm)$ 。

```c++
class Solution {
public:

    static bool cmp(vector<int>& a, vector<int>& b)
    {
        return a[1]<b[1];
    }

    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        int m=2;
        sort(intervals.begin(), intervals.end(), cmp);
        int sz = intervals.size();
        unordered_set<int> res;
        deque<int> deq;
        for(int i=0; i<sz; i++)
        {
            while(!deq.empty() && deq.front()<intervals[i][0])
            {
                deq.pop_front();
            }
            int num = intervals[i][1];
            int k = m-deq.size();
            while(k)
            {
                if(res.count(num)==0)
                {
                    res.insert(num);
                    k--;
                }
                else
                {
                    deq.pop_back();
                }
                num--;
            }
            for(int j=num+1; j<=intervals[i][1]; j++)
                deq.push_back(j);
        }
        return res.size();
    }
};
```

另外，本题中问题1是如何区间新区间中有多少个数字已经在结果集合中，这是一个典型的可以用线段树解决的问题。但本题中数字的范围是1e8，线段树需要4e8的空间，并不能直接应用，而且线段树可以在logn时间内查询到结果，而使用队列的大小却是常数时间。





## 763.划分字母区间

>给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。
>
>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。
>
>返回一个表示每个字符串片段的长度的列表。
>
>- `1 <= s.length <= 500`
>- `s` 仅由小写英文字母组成

贪心。第一次遍历字符串记录每个字母最后一次出现的位置。第二次遍历字符串，维护当前片段中字母最后一次出现位置的最大值，直到遍历到最大位置，就可以划分为一片。

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        unordered_map<char, int> mp;
        int sz = s.size();
        for(int i=0; i<sz; i++)
        {
            mp[s[i]] = max(mp[s[i]], i);
        }
        vector<int> ret;
        for(int i=0; i<sz; i++)
        {
            int idx = i;
            int maxIdx = mp[s[idx]];
            while(idx<maxIdx)
            {
                idx++;
                maxIdx = max(maxIdx, mp[s[idx]]);
            }
            ret.push_back(idx-i+1);
            i = idx;
        }
        return ret;
    }
};
```



## 765.情侣牵手

>`n` 对情侣坐在连续排列的 `2n` 个座位上，想要牵到对方的手。
>
>人和座位由一个整数数组 `row` 表示，其中 `row[i]` 是坐在第 `i `个座位上的人的 **ID**。情侣们按顺序编号，第一对是 `(0, 1)`，第二对是 `(2, 3)`，以此类推，最后一对是 `(2n-2, 2n-1)`。
>
>返回 *最少交换座位的次数，以便每对情侣可以并肩坐在一起*。 *每次*交换可选择任意两人，让他们站起来交换座位。
>
>- `2n == row.length`
>- `2 <= n <= 30`
>- `n` 是偶数
>- `0 <= row[i] < 2n`
>- `row` 中所有元素均**无重复**

并查集。

首先，我们对情侣进行编号，我们将 **情侣两人的ID/2** 作为这对情侣的ID。显然情侣两人拥有共同的情侣ID。

由于所有情侣都是肩并肩，那么最终一定是(0, 1) (2, 3)这些位置是情侣。观察发现，如果存在没有坐在一起的情侣，假设是a和b，那么b的另一半目前肯定也和另一个陌生人坐在一起，这个陌生人如果不是a，那么他同理这个陌生人的另一半也和另一个陌生人坐在一起。以此类推，最终一定能找到a的另一半。那么这些首尾相连的情侣构成一个联通分量。设该联通分量包含n对情侣，那么需要n-1次交换座位。假设总共有s个联通分量，每个联通分量有$n_i$ 对情侣，那么总共需要交换次数：

$n_0-1+n_1-1+\cdots+n_s-1 = N - s$

因此，使用并查集计算总共的联通分量s，N-s就是答案。

具体的，初始状态有N个联通分量，每一次merge操作就是减少一个联通分量。所以答案就是merge的次数。

时间复杂度 $O(nlogn)$ 。

```c++
class Solution {
public:
    vector<int> par;

    int father(int x) {
        if(par[x]!=x) {
            par[x] = father(par[x]);
        }
        return par[x];
    }

    void merge(int a, int b) {
        int x = father(a);
        int y = father(b);
        par[x] = y;
    }

    int same(int a, int b) {
        return father(a) == father(b);
    }

    int minSwapsCouples(vector<int>& row) {
        int couple = row.size()/2;
        par.resize(couple);
        for(int i=0; i<couple; i++) {
            par[i] = i;
        }
        int ret = 0;
        for(int i=0; i<row.size(); i+=2) {
            int first = row[i]/2;
            int second = row[i+1]/2;
            if(!same(first, second)) {
                merge(first, second);
                ret++;
            }
        } 
        return ret;
    }
};
```















