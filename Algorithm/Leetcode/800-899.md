# Leetcode 800-899

[TOC]



## 802.找到最终的安全状态

>有一个有 `n` 个节点的有向图，节点按 `0` 到 `n - 1` 编号。图由一个 **索引从 0 开始** 的 2D 整数数组 `graph`表示， `graph[i]`是与节点 `i` 相邻的节点的整数数组，这意味着从节点 `i` 到 `graph[i]`中的每个节点都有一条边。
>
>如果一个节点没有连出的有向边，则该节点是 **终端节点** 。如果从该节点开始的所有可能路径都通向 **终端节点** ，则该节点为 **安全节点** 。
>
>返回一个由图中所有 **安全节点** 组成的数组作为答案。答案数组中的元素应当按 **升序** 排列。
>
>- `n == graph.length`
>- `1 <= n <= 104`
>- `0 <= graph[i].length <= n`
>- `0 <= graph[i][j] <= n - 1`
>- `graph[i]` 按严格递增顺序排列。
>- 图中可能包含自环。
>- 图中边的数目在范围 `[1, 4 * 104]` 内。

拓扑排序。如果把图中的所有边反向，那么所有入度为0的边都是安全节点。将这些安全节点从图中除去，那么子图中入读为0的节点在原图中所有路径都通向终端节点，所以也是安全节点。以此类推，就是拓扑排序，剩下在环上的节点。

时间复杂度 $O(n+m)$ 。

```c++
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<vector<int>> rg(n, vector<int>());
        vector<int> inDegree(n, 0);
        for(int i=0; i<n; i++) {
            for(int j=0; j<graph[i].size(); j++) {
                rg[graph[i][j]].push_back(i);
                inDegree[i]++;
            }
        }
        queue<int> que;
        for(int i=0; i<n; i++) {
            if(inDegree[i]==0) {
                que.push(i);
            }
        }
        while(!que.empty()) {
            int num = que.size();
            for(int i=0; i<num; i++) {
                int from = que.front();
                que.pop();
                for(int j=0; j<rg[from].size(); j++) {
                    inDegree[rg[from][j]]--;
                    if(inDegree[rg[from][j]]==0) {
                        que.push(rg[from][j]);
                    }
                }
            }
        }
        vector<int> ret;
        for(int i=0; i<n; i++) {
            if(inDegree[i]==0) {
                ret.push_back(i);
            }
        }
        return ret;
    }
};
```



## 841.钥匙和房间

>有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
>
>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
>
>给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。
>
>- `n == rooms.length`
>- `2 <= n <= 1000`
>- `0 <= rooms[i].length <= 1000`
>- `1 <= sum(rooms[i].length) <= 3000`
>- `0 <= rooms[i][j] < n`
>- 所有 `rooms[i]` 的值 **互不相同**

BFS。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<bool> vis(rooms.size(), false);
        queue<int> que;
        que.push(0);
        vis[0] = true;
        while(!que.empty()) {
            int cur = que.front();
            que.pop();
            auto& room = rooms[cur];
            for(auto& nxt : room) {
                if(!vis[nxt]) {
                    vis[nxt] = true;
                    que.push(nxt);
                }
            }
        }
        for(auto room : vis) {
            if(!room) {
                return false;
            }
        }
        return true;
    }
};
```











