# Leetcode 500-599

[TOC]



## 502.IPO

>假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。
>
>给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。
>
>最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
>
>总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。
>
>答案保证在 32 位有符号整数范围内。
>
>- `1 <= k <= 10^5`
>- `0 <= w <= 10^9`
>- `n == profits.length`
>- `n == capital.length`
>- `1 <= n <= 10^5`
>- `0 <= profits[i] <= 10^4`
>- `0 <= capital[i] <= 10^9`

贪心+最大堆。维护一个以纯利润为关键词的最大堆。先按照启动资本将所有项目从小到大排序，然后将所有启动资本小于等于当前资本的项目加入最大堆，完成堆顶的项目，更新当前资本和最大堆，直到做完k个项目或者没有项目可做。时间复杂度 $O((n+k)logn)$ ,其中排序复杂度为nlog，往堆中添加元素的复杂度的为nlogn，从堆中弹出堆顶的复杂度为klogn。

```c++
class Solution {
public:
 
    typedef pair<int, int> P;

    struct cmp
    {
        bool operator()(const P& a, const P& b)
        {
            return a.second<b.second;
        }
    };

    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        vector<P> projects;
        int n = profits.size();
        for(int i=0; i<n; i++)
        {
            projects.push_back(P(capital[i], profits[i]));
        }
        sort(projects.begin(), projects.end());

        int projectIdx = 0;
        int doneCnt = 0;
        int res = w;
        priority_queue<P, vector<P>, cmp> que;
        while(projectIdx<n)
        {
            while(projectIdx<n && projects[projectIdx].first<=res)
                que.push(projects[projectIdx++]);
            if(que.empty() || doneCnt==k)
                break;
            if(doneCnt<k)
            {
                doneCnt++;
                res += que.top().second;
                que.pop();
            }
        }
        while(doneCnt<k && !que.empty())
        {
            doneCnt++;
            res += que.top().second;
            que.pop();
        }
        return res;
    }
};
```



## 509.斐波那契数

>**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
>- `0 <= n <= 30`

矩阵快速幂。

时间复杂度 $O(logn)$ 。

```c++
class Solution {
public:
    static const int N=2;
    typedef long long int ll;
    struct Matrix
    {
        ll data[N][N];
        Matrix()
        {
            for(int i=0; i<N; i++)
            {
                for(int j=0; j<N; j++)
                {
                    data[i][j] = 0;
                }
            }
        }
    };
    
    Matrix mul(Matrix& a, Matrix& b)
    {
        Matrix c;
        for(int i=0; i<N; i++)
        {
            for(int j=0; j<N; j++)
            {
                for(int k=0; k<N; k++)
                {
                    c.data[i][j] += (a.data[i][k]*b.data[k][j])%INT_MAX;
                    c.data[i][i] %= INT_MAX;
                }
            }
        }
        return c;
    }

    Matrix pow(Matrix& a, int exp)
    {
        Matrix ret;
        for(int i=0; i<N; i++)
            ret.data[i][i] = 1; 
        Matrix tmp=a;
        while(exp)
        {
            if(exp&1)
                ret = mul(ret, tmp);
            tmp = mul(tmp, tmp);
            exp = exp>>1;
        }
        return ret;
    }

    int fib(int n) {
        if(n==0)
            return 0;
        else if(n==1)
            return 1;
        Matrix m;
        m.data[0][0] = 1;
        m.data[0][1] = 1;
        m.data[1][0] = 1;
        m.data[1][1] = 0;
        m = pow(m, n-1);
        return m.data[0][0];
    }
};
```





## 514.自由之路

>电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘，并使用表盘拼写特定关键词才能开门。
>
>给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。
>
>最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。
>
>旋转 ring 拼出 key 字符 key[i] 的阶段中：
>
>您可以将 ring 顺时针或逆时针旋转 一个位置 ，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
>
>- `1 <= ring.length, key.length <= 100`
>- `ring` 和 `key` 只包含小写英文字母
>- **保证** 字符串 `key` 一定可以由字符串  `ring` 旋转拼出

动态规划。

首先需要明确，无论顺时针还是逆时针转动，只要起点和终点相同，那么最终转盘的状态是一样的。

可以使用动态规划。定义 $dp[ch][j]:=在拼写key的过程中，到达当前字母ch的最小步数，其中j代表转盘上j个相同的字母 ch$ 。

在遍历过程中，我们使用滚动数组。对于当前要拼写的字母 $key[i]$ ，因为转盘上的字母可能重复，我们需要计算到达转盘上每个 $key[i]$ 字母的最小步数。对于每个字母，它可以从转盘上所有的字母 $key[i-1]$ 出发到达，因此我们需要计算从每个 $key[i-1]$ 到 $key[i]$ 的路径。

时间复杂度 $O(nm^2)$ 。其中m为ring的长度，n为key的长度。需要转n次转盘，每次需要计算两个字母之间的所有路径，最坏情况是这两个字母平分转盘，那么需要m*m/4次计算。所以总共的时间复杂度 $O(nm^2)$ 。

```c++
class Solution {
public:
    int minStep(int start, int to, int length)
    {
        int dis;
        if(start>=to)
            dis = start-to;
        else
            dis = to-start;
        return min(dis, length-dis);
    }

    int findRotateSteps(string ring, string key) {
        vector<int> idxMap[26];
        vector<int> dp[26];
        int ringSize = ring.size();
        for(int i=0; i<ringSize; i++)
        {
            idxMap[ring[i]-'a'].push_back(i);
            dp[ring[i]-'a'].push_back(0);
        }

        for(int i=0; i<idxMap[key[0]-'a'].size(); i++)
        {
            int toIdx = idxMap[key[0]-'a'][i];
            dp[key[0]-'a'][i] = minStep(0, toIdx, ringSize);
        }
        for(int i=1; i<key.size(); i++)
        {
            if(key[i-1]!=key[i])
            {
                vector<int>& lastVec = idxMap[key[i-1]-'a'];
                vector<int>& curVec = idxMap[key[i]-'a'];
                for(int j=0; j<curVec.size(); j++)
                {
                    int step = INT_MAX;
                    for(int k=0; k<lastVec.size(); k++)
                    {
                        step = min(step, dp[key[i-1]-'a'][k]+minStep(lastVec[k], curVec[j], ringSize));
                    }
                    dp[key[i]-'a'][j] = step;
                }
            }
        }
        vector<int>& lastVec = dp[key.back()-'a'];
        return *min_element(lastVec.begin(), lastVec.end())+key.size();

    }
};
```







## 517.超级洗衣机

>假设有 `n` 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。
>
>在每一步操作中，你可以选择任意 `m` (`1 <= m <= n`) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。
>
>给定一个整数数组 `machines` 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 **最少的操作步数** 。如果不能使每台洗衣机中衣物的数量相等，则返回 `-1` 。
>
>- `n == machines.length`
>- `1 <= n <= 10^4`
>- `0 <= machines[i] <= 10^5`

贪心算法。首先计算最终目标每台洗衣机中有target件衣服，如果总衣服数量不能整除洗衣机数，那么就返回-1。

然后计算每台洗衣机的净衣服含量，即 $machines[i]-target$，如果该值为正，代表它要向外移动衣服的数量，如果该值为负，绝对值代表它要接收衣服的数量。

此时可以遍历数组，计算每个洗衣机移动衣服的操作步数，维护步数最大值即可。对于第i个洗衣机，如果前i-1个洗衣机的净含量为 $curMoveCnt$ ，则加上第i个洗衣机后净含量变为 $updateMoveCnt=curMoveCnt+machines[i]-target$ 。则有4种情况：

1. $curMoveCnt≥0 \ \ \and \ \  updateMoveCnt≥0$

    第i个洗衣机要接受前面洗衣机的 $curMoveCnt$ 件衣服，还要向后移动 $updateMoveCnt$ 件衣服，两中操作可以同时进行，所以该洗衣机的移动步数为 $max(curMoveCnt, updateMoveCnt)$ 。

2. $curMoveCnt<0 \ \ \and \ \  updateMoveCnt<0$

    第i个洗衣机要向前面的洗衣机移动 $-curMoveCnt$ 件衣服，还要接受后面的洗衣机向它移动的 $-updateMoveCnt$ 件衣服，两中操作可以同时进行，所以该洗衣机的移动步数为 $max(-curMoveCnt, -updateMoveCnt)$ 。

3. $ curMoveCnt<0 \ \ \and \ \  updateMoveCnt≥0 $ 

    此种情况说明第i个洗衣机要向前移动 $-curMoveCnt$ 件衣服，而且移动完自己还多余 $updateMoveCnt$件衣服，多余的要向后移动，因此该洗衣机的移动步数为 $-curMoveCnt+updateMoveCnt$ 。

4. $curMoveCnt≥0 \ \ \and \ \  updateMoveCnt<0$

    此种情况说明第i个洗衣机要接受前面洗衣机向它移动的 $curMoveCnt$ 件衣服，移动完自己还缺$-updateMoveCnt$ 件衣服，要从后面的洗衣机向它移动。由于这台洗衣机可以同时接收来自左和右洗衣机移动来的衣服，因此该洗衣机的移动步数为 $max(curMoveCnt, -updateMoveCnt)$ 。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int findMinMoves(vector<int>& machines) {
        int sz = machines.size();
        int sumClothes = 0;
        for(int i=0; i<sz ; i++)
            sumClothes += machines[i];
        if(sumClothes%sz!=0)
            return -1;
        int targetClothes = sumClothes/sz;
        int res = 0;
        int curMoveCnt = 0;
        for(int i=0; i<sz; i++)
        {
            int updateMoveCnt = curMoveCnt + machines[i]-targetClothes;
            if(curMoveCnt>=0 && updateMoveCnt>0)
                res = max(res, max(curMoveCnt, updateMoveCnt));
            else if(curMoveCnt<0 && updateMoveCnt<0)
                res = max(res, max(-curMoveCnt, -updateMoveCnt));
            else if(curMoveCnt<0 && updateMoveCnt>=0)
                res = max(res, -curMoveCnt+updateMoveCnt);
            else if(curMoveCnt>=0 && updateMoveCnt<0)
                res = max({res, curMoveCnt, -updateMoveCnt});
            curMoveCnt = updateMoveCnt;
        }
        return res;
    }
};
```





## 518.零钱兑换II

>给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
>
>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
>
>假设每一种面额的硬币有无限个。 
>
>题目数据保证结果符合 32 位带符号整数。
>
>- `1 <= coins.length <= 300`
>- `1 <= coins[i] <= 5000`
>- `coins` 中的所有值 **互不相同**
>- `0 <= amount <= 5000`

动态规划。定义 $dp[i][j]:=前i个硬币可以组合出j的方案数$ 。由于每一种硬币的数量无限，所以递推的时候第二维应该从小到大。

时间复杂度 $O(mn)$ ，其中m是硬币的种类数，n是总金额。

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1);
        dp[0] = 1;
        for(int i=0; i<coins.size(); i++)
            for(int j=coins[i]; j<=amount; j++)
                dp[j] += dp[j-coins[i]];
        return dp[amount];
    }
};
```





## 526.优美的排列

>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 `perm`（**下标从 1 开始**），只要满足下述条件 **之一** ，该数组就是一个 **优美的排列** ：
>
>- `perm[i]` 能够被 `i` 整除
>- `i` 能够被 `perm[i]` 整除
>
>给你一个整数 `n` ，返回可以构造的 **优美排列** 的 **数量** 。
>
>- `1 <= n <= 15`

方法一：回溯+状态压缩+记忆化搜索

具体地，我们定义函数 $dfs(candidate, idx, flag)$ ，表示尝试向位置 idx 放入数。在当前函数中，我们首先找到一个符合条件的未被使用过的数，然后递归地执行 $dfs(candidate, idx+1, newFlag)$ 。当该函数执行完毕，回溯到当前层，我们再尝试下一个符合条件的未被使用过的数即可。

回溯过程中，我们可以用 vis 数组标记哪些数被使用过。

特别地，为了优化回溯效率，我们可以预处理每个位置的符合条件的数有哪些，用二维数组candidate保存。当我们尝试向位置 idx 放入数时，我们只需要遍历 cadidate[idx] 即可。

另外，为了减少对重复状态的搜索，我们使用状态压缩的int类型数字flag表示搜索状态。flag的第i位为1则代表已经选了数字i。我们将搜索过的状态与该状态最终的结果数记录下来以备使用。

时间复杂度 $O(n2^n)$ 。经过记忆化搜索，对不同的状态只会搜索一次，总共有 $2^n$ 种状态。每种状态最多搜索n个数。

```c++
class Solution {
public:
    vector<bool> vis = vector<bool>(16, false);
    unordered_map<int, int> memo;
    int dfs(vector<vector<int>>& candidate, int idx, int flag)
    {
        if(idx==candidate.size())
            return 1;
        if(memo.count(flag))
            return memo[flag];

        int ret=0;
        for(int i=0; i<candidate[idx].size(); i++)
        {
            if(vis[candidate[idx][i]])
                continue;
            vis[candidate[idx][i]] = true;
            ret += dfs(candidate, idx+1, flag|(1<<candidate[idx][i]));
            vis[candidate[idx][i]] = false;
        }
        memo[flag] = ret;
        return ret;
    }

    int countArrangement(int n) {
        vector<vector<int>> candidate(n+1, vector<int>());
        for(int i=1; i<=n; i++)
        {
            for(int j=1; j<=n; j++)
            {
                if(i%j==0 || j%i==0)
                    candidate[i].push_back(j);
            }
                
        }
        return dfs(candidate, 1, 0);

    }
};
```

方法二：状态压缩+动态规划

我们可以用一个位数为 n 的二进制数 mask 表示排列中的数被选取的情况。若 mask 中的第 i 位为 1（从 0 开始编号），则数 i+1 已经被选取，否则就还未被选取。我们可以利用这样的二进制数表示选取数的过程的状态。令 $f(mask)$ 表示状态 mask 时的可行方案总数，那么最终结果就是 $f(2^n-1)$ 。

如果从小到大遍历该二进制数，那么当计算 $f(mask)$ ，所有的 $f(mask')(其中mask'<mask)$ 都已经被计算完成。因此，我们可以枚举mask中的每一个为1的二进制位，计算把它代表的数字放在最后一位的方案数，最后把枚举的结果加起来即可。

时间复杂度 $O(n2^n)$ 。

```c++
class Solution {
public:
    int countArrangement(int n) {
        vector<int> dp(1<<n);
        dp[0] = 1;
        for (int mask=1; mask<(1<<n); mask++) 
        {
            int num = __builtin_popcount(mask);
            for(int i=0; i<n; i++) 
            {
                if(mask&(1<<i))
                {
                    if(num%(i+1) == 0 || (i+1)%num == 0)
                        dp[mask] += dp[mask^(1<<i)];
                } 
            }
        }
        return dp[(1<<n)-1];
    }
};

```



 

## 542.01矩阵

>给定一个由 `0` 和 `1` 组成的矩阵 `mat` ，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。
>
>两个相邻元素间的距离为 `1` 。
>
>- `m == mat.length`
>- `n == mat[i].length`
>- `1 <= m, n <= 10^4`
>- `1 <= m * n <= 10^4`
>- `mat[i][j] is either 0 or 1.`
>- `mat` 中至少有一个 `0 `

方法一：动态规划。

我们把从第一行到最后一行、第一列到最后一列的遍历顺序称为自然顺序。定义 $dp[i][j]:=距离位置i，j最近的0的距离$。那么显然位置 $i,j$ 处最近的0，有3种情况：

+ 该位置本身就是0，那么距离就是0。
+ 最近的0在自然顺序中排在当前位置的前面。此时 $dp[i][j]=min(dp[i-1][j], dp[i][j-1])$ 。
+ 最近的0在自然顺序中排在当前位置的后面。此时 $d[i][j]=min(dp[i+1][j],dp[i][j+1])$ 。

于是我们可以两次遍历矩阵。第一次更新自然顺序，第二次更新逆自然顺序。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> ret(m, vector<int>(n, 0x3e3e3e3e));

        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(mat[i][j]==0)
                    ret[i][j] = 0;
                else
                {
                    if(i>0)
                        ret[i][j] = min(ret[i][j], ret[i-1][j]+1);
                    if(j>0)
                        ret[i][j] = min(ret[i][j], ret[i][j-1]+1);
                }
            }
        }
        for(int i=m-1; i>=0; i--)
        {
            for(int j=n-1; j>=0; j--)
            {
                if(i<m-1)
                    ret[i][j] = min(ret[i][j], ret[i+1][j]+1);
                if(j<n-1)
                    ret[i][j] = min(ret[i][j], ret[i][j+1]+1);
            }
        }
        return ret;
    }
};
```

方法二：BFS。

我们不妨从一个简化版本的问题开始考虑起。假设这个矩阵中恰好只有一个 0，我们应该怎么做？由于矩阵中只有一个 0，那么对于每一个 1，离它最近的 0 就是那个唯一的 0。我们当然可以计算每个1到唯一的0到距离，但这种方法显然不可应用到多个0的情况。更合理的方法是BFS，先将这个0入队，然后每次将与当前元素距离为1且尚未入队的元素入队。如果有多个0，那么我们只需要将多个0先入队，然后再开始搜索即可。

时间复杂度 $O(mn)$ 。



## 543.二叉树的直径

>给你一棵二叉树的根节点，返回该树的 **直径** 。
>
>二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。
>
>两节点之间路径的 **长度** 由它们之间边数表示。
>
>- 树中节点数目在范围 `[1, 10^4]` 内
>- `-100 <= Node.val <= 100`

与普通的图用两次BFS求直径不同，本题给出的二叉树中每个节点只有指向子节点的指针。可以发现，最终最长的路径的两端一定都是叶子节点（或根节点）。因此，我们可以在每一个节点处求左右两颗子树的高度，则经过该点的最长路径的长度就是两个子树的高度和。

时间复杂度 $O(n)$ 。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameter = 0;

    int func(TreeNode* root) {
        if(root==nullptr) {
            return 0;
        }
        int left=0;
        int right=0;
        if(root->left!=nullptr) {
            left = func(root->left);
        }
        if(root->right!=nullptr) {
            right = func(root->right);
        }
        diameter = max(diameter, left+right);
        return max(left, right)+1;
    }

    int diameterOfBinaryTree(TreeNode* root) {
        func(root);
        return diameter;
    }
};
```





## 546.移除盒子

>给出一些不同颜色的盒子 `boxes` ，盒子的颜色由不同的正数表示。
>
>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 `k` 个盒子（`k >= 1`），这样一轮之后你将得到 `k * k` 个积分。
>
>返回 *你能获得的最大积分和* 。
>
>- `1 <= boxes.length <= 100`
>- `1 <= boxes[i] <= 100`

动态规划。

首先我们自然的想到这种状态定义方式 $dp[i][j]:=从boxes[i]到boxes[j]能获得的最大分数$ 。

现在扩展一个新盒子 $boxes[i]$ ，此时对于 $dp[0][i-1]$ 以及该区间内的状态我们都已经完成计算，那么该如何计算 $dp[0][i]$ 呢？

考虑将这i+1个盒子的消去方式按照最后一个新加入的盒子分类：

1. 最后一个盒子独自消去，那么有 $dp[0][i] = dp[0][i-1]+1$ 。
2. 最后一个盒子和 $0到i-1$ 之间的某个相同的盒子 $boxes[j]$ 一起消去。此时问题出现了。这时总共需要计算两个部分的得分:
    + 一部分是盒子 $boxes[j+1]到boxes[i-1]$ 之间的得分，这一部分的得分可以简单的通过 $dp[j+1][i-1]$ 获得；
    + 另一部分是从 $boxes[0]到boxes[j]$ 再加上 $boxes[i]$ 的得分，这一部分的得分不是任何之前定义的状态。

重点来了，解决这一问题的办法是，我们在定义的状态里增加一个维度。能否只给每个状态增加一个一一对应的新状态，该新状态表示在串后再添加一个末尾盒子时能得到的最大分数？答案是只增加这个状态是不够的。因为当我们需要计算这个新状态时，旧末尾和新末尾肯定是一起消去的，那么我们就需要考虑旧末尾的消去方式，即考虑它和串前面的某个相同的盒子 $boxes[j]$ 一起消去，此时需要 $boxes[0]到boxes[j]$ 再加上两个 $boxes[i]$ 的得分。于是我们发现，最多需要定义n个新状态与原状态对应。所以有：

$dp[i][j][k]:=从boxes[i]到boxes[j]组成的盒子串，在其末尾再添加k个boxes[j]得到的串，经过消去能获得的最大分数$ 。

于是有递推式：
$$
\begin{equation*}
\begin{aligned}
dp[left][right][k] = &max(dp[left][right-1][0]+(k+1)^2, \\
&max_{i=right-1}^{lefrt}\{[dp[left][i][k+1]+dp[i+1][right-1][0]]\times\epsilon(a_i=a_r) \})
\end{aligned}
\end{equation*}
$$
另一个状态是，本题中的k从小到大递推的话，会搜到很多无用的状态。因此，我们使用从顶向下的动态规划。对于没访问过的状态设置为0，如果访问时发现已经计算过该状态即可直接返回。

时间复杂度 $O(n^4)$ 。最坏情况下，共计算 $n^3$ 种状态，每次状态转移需要 O(n) 的时间。

```c++
class Solution {
public:
    static const int N=105;
    int dp[N][N][N];

    int removeBoxes(vector<int>& boxes) {
        return dfs(boxes, 0, boxes.size()-1, 0);
    }

    int dfs(vector<int>& boxes, int left, int right, int k) 
    {
        if(left>right) 
            return 0;
        if(dp[left][right][k]!=0)
            return dp[left][right][k];
        dp[left][right][k] = dfs(boxes, left, right-1, 0) + (k+1)*(k+1);
        for(int i=right-1; i>=left; i--)
        {
            if(boxes[i]==boxes[right])
            {
                dp[left][right][k] = max(dp[left][right][k], dfs(boxes, left, i, k+1)+dfs(boxes, i+1, right-1, 0));
            }
        }
        return dp[left][right][k];
    }
};
```



## 547.省份数量

>有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。
>
>**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
>给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。
>
>返回矩阵中 **省份** 的数量。
>
>- `1 <= n <= 200`
>- `n == isConnected.length`
>- `n == isConnected[i].length`
>- `isConnected[i][j]` 为 `1` 或 `0`
>- `isConnected[i][i] == 1`
>- `isConnected[i][j] == isConnected[j][i]`

DFS。时间复杂度 $O(n^2)$ 。

```c++
class Solution {
public:

    void dfs(int s, int n, vector<bool>& vis, vector<vector<int>>& isConnected) {
        vis[s] = true;
        for(int i=0; i<n; i++) {
            if(isConnected[s][i] && !vis[i]) {
                dfs(i, n, vis, isConnected);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        if(n<=1) {
            return n;
        }
        vector<bool> vis(n, false);
        int ret = 0;
        for(int i=0; i<n; i++) {
            if(!vis[i]) {
                ret++;
                dfs(i, n, vis, isConnected);
            }
        }
        return ret;
    }
};
```





## 552.学生出勤记录II

>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
>
>- `'A'`：Absent，缺勤
>- `'L'`：Late，迟到
>- `'P'`：Present，到场
>
>如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：
>
>- 按 **总出勤** 计，学生缺勤（`'A'`）**严格** 少于两天。
>- 学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（`'L'`）记录。
>
>给你一个整数 `n` ，表示出勤记录的长度（次数）。请你返回记录长度为 `n` 时，可能获得出勤奖励的记录情况 **数量** 。答案可能很大，所以返回对 `109 + 7` **取余** 的结果。
>
>- `1 <= n <= 10^5`

方法一：动态规划

首先考虑简单的题目，假设出勤情况只有迟到和到场两种，那么可以定义 $dpP[i]:总共i+1天时，最后一天为P的可能情况数$ , $dpL[i]:=总共i+1天时，最后一天为L的可能情况数$ 。

于是有 $dpL[i] = dpP[i-1]+dpP[i-2] , dpP[i] = dpP[i-1]+dpL[i-1]$ 。

现在加上缺勤的情况。由于最多缺勤一次，所以我们可以枚举第i天缺勤的情况，然后把每种枚举的结果数量加起来，就是缺勤一天的所有情况数。对于第i天缺勤，它把总共n天分割成了缺勤前和缺勤后的两端，每一段的情况数量我们已经在无缺勤时计算完成，因此将两段的情况数相乘即可。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    static const int MOD=1e9+7;
    typedef long long int ll;
    int checkRecord(int n) {
        if(n==1)
            return 3;
        vector<ll> dpL(n, 0);
        vector<ll> dpP(n, 0);
        dpP[0] = dpL[0] = 1;
        dpP[1] = dpL[1] = 2;
        for(int i=2; i<n; i++)
        {        
            dpL[i] = (dpP[i-1]+dpP[i-2])%MOD;
            dpP[i] = (dpP[i-1]+dpL[i-1])%MOD;
        }
        ll ret=(dpP[n-1]+dpL[n-1])%MOD;
        //A在第一位和最后一位
        ret += (dpP[n-2]+dpL[n-2])*2;
        ret = ret%MOD;
        //A在中间
        for(int i=1; i<n-1; i++)
        {
            ret += (dpP[i-1]+dpL[i-1])*(dpP[n-i-2]+dpL[n-i-2])%MOD;
        }
        return ret%MOD;
    }
};
```

方法二：动态规划

使用方法一的动态规划有一个条件，那就是缺勤次数只能严格小于2，否则枚举在第几天缺勤的时间复杂度将会巨大。因此考虑下面这种动态规划。

定义 $dp[i][j][k]:=总共i天，其中有j天缺勤，且最后以连续k天迟到结尾的情况数$ 。

于是，分类讨论第i天的出勤记录：

+ 第i天是到场"P":那么与第i-1天相比，A的数量不变，结尾L的数量清零。

    $dp[i][0][0] += dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2]$

    $dp[i][1][0] += dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2]$

+ 第i天是迟到"L":那么与第i天相比，A的数量不变， 结尾L的数量加一。

    $dp[i][0][1] += dp[i-1][0][0]$

    $dp[i][0][2] += dp[i-1][0][1]$

    $dp[i][1][1] += dp[i-1][1][0]$

    $dp[i][1][2] += dp[i-1][1][1]$

+ 第i天是缺勤"A":那么与第i天相比，A数量加一，结尾L的数量清零。

    $dp[i][1][0] += dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2]$

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    static const int MOD = 1e9+7;
    static const int N=1e5+5;
    int dp[N][2][3];
    int checkRecord(int n) {
        dp[0][0][0] = 1;
        for (int i=1; i<=n; i++) 
        {
            // 以 P 结尾的数量
            for(int j=0; j<=1; j++) 
                for(int k=0; k<=2; k++)
                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k])%MOD;
            
            // 以 A 结尾的数量
            for (int k=0; k<=2; k++)
                dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][k])%MOD;
        
            // 以 L 结尾的数量
            for (int j=0; j<=1; j++)
                for (int k=1; k<=2; k++) 
                    dp[i][j][k] = (dp[i][j][k] + dp[i-1][j][k-1])%MOD;
        }
        int ret=0;
        for (int j=0; j<=1; j++)
            for (int k=0; k<=2; k++)
                ret = (ret + dp[n][j][k]) % MOD;
        return ret;
    }
};
```

方法三：矩阵快速幂

为了使用矩阵快速幂，需要将方法二的动态规划表示中的 j 和 k 合并到一个维度，即动态规划的状态为：
$dp[i][j\times 3+k]$ 表示前 i 天有 j 个A且结尾有连续 k 个L的可奖励的出勤记录的数量

在新的动态规划状态定义下，状态转移方程如下：
$$
\begin{equation*}
\left\{
\begin{aligned}
&dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] \\
&dp[i][1] = dp[i-1][0] \\
&dp[i][2] = dp[i-1][1] \\
&dp[i][3] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5] \\
&dp[i][4] = dp[i-1][3] \\
&dp[i][5] = dp[i-1][4] \\
\end{aligned}
\right.
\end{equation*}
$$

令 $dp[n]$ 是包含6个元素的列向量，于是可以构造出矩阵：
$$
\begin{equation*}
\begin{bmatrix}
1 & 1 & 1 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}
\times dp[n-1]=dp[n]
\end{equation*}
$$
于是有：
$$
\begin{equation*}
\begin{bmatrix}
1 & 1 & 1 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix} ^n
\times dp[0]=dp[n]
\end{equation*}
$$
时间复杂度 $O(logn)$ 。

```c++
class Solution {
public:
    static const int MOD=1e9+7;
    typedef long long int ll;
    vector<vector<ll>> E={ {1,0,0,0,0,0},
                           {0,1,0,0,0,0},
                           {0,0,1,0,0,0},
                           {0,0,0,1,0,0},
                           {0,0,0,0,1,0},
                           {0,0,0,0,0,1}};
    vector<vector<ll>> pow(vector<vector<ll>> mat, int n) {
        vector<vector<ll>> ret = E;
        while(n>0)
        {
            if(n&1)
                ret = multiply(ret, mat);
            mat = multiply(mat, mat);
            n >>= 1;
        }
        return ret;
    }

    vector<vector<ll>> multiply(vector<vector<ll>> a, vector<vector<ll>> b) 
    {
        int rows = a.size(), columns = b[0].size(), temp = b.size();
        vector<vector<ll>> c(rows, vector<ll>(columns));
        for(int i=0; i<rows; i++)
            for (int j=0; j<columns; j++)
                for (int k=0; k<temp; k++) 
                    c[i][j] = (c[i][j]+a[i][k]*b[k][j])%MOD;
        return c;
    }

    int checkRecord(int n) {
        vector<vector<ll>> mat = {{1, 1, 1, 0, 0, 0},
                                  {1, 0, 0, 0, 0, 0}, 
                                  {0, 1, 0, 0, 0, 0}, 
                                  {1, 1, 1, 1, 1, 1}, 
                                  {0, 0, 0, 1, 0, 0}, 
                                  {0, 0, 0, 0, 1, 0}};
        vector<vector<ll>> res = pow(mat, n);
        ll ret=0;
        vector<int> dp={1,0,0,0,0,0};
        for(int i=0; i<6; i++)
            for(int j=0; j<6; j++)
                ret = (ret+res[i][j]*dp[j])%MOD;
        return ret;
    }
};
```





## 553.最优除法

>给定一正整数数组 `nums`**，**`nums` 中的相邻整数将进行浮点除法。例如， [2,3,4] -> 2 / 3 / 4 。
>
>- 例如，`nums = [2,3,4]`，我们将求表达式的值 `"2/3/4"`。
>
>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。
>
>以字符串格式返回具有最大值的对应表达式。
>
>**注意：**你的表达式不应该包含多余的括号。
>
>- `1 <= nums.length <= 10`
>- `2 <= nums[i] <= 1000`
>- 对于给定的输入只有一种最优除法。

方法一：动态规划。

定义 $dpmax[i][j]:=从nums[i]到nums[j]能计算出的最大结果，相应的，dpmin为最小结果$ 。

于是可以枚举长度从1到n，对于每个长度length，计算所有长度为length的子串的dpmax和dpmin，同时记录分割位置即可。

时间复杂度 $O(n^3)$ 。

```c++
class Solution {
public:
    static const int N=11;
    double dpmax[N][N];
    int dpmaxIdx[N][N];
    double dpmin[N][N];
    int dpminIdx[N][N];

    string wrapMax(vector<int>& nums, int start, int end)
    {
        if(start==end)
            return to_string(nums[start]);
        else if(start+1==end)
            return to_string(nums[start])+"/"+to_string(nums[end]);
        int idx = dpmaxIdx[start][end];
        string left = wrapMax(nums, start, idx);
        string right = wrapMin(nums, idx+1, end);
        if(end-idx>=2)
            right = "("+right+")";
        return left+"/"+right;
    }

    string wrapMin(vector<int>& nums, int start, int end)
    {
        if(start==end)
            return to_string(nums[start]);
        else if(start+1==end)
            return to_string(nums[start])+"/"+to_string(nums[end]);
        int idx = dpminIdx[start][end];
        string left = wrapMin(nums, start, idx);
        string right = wrapMax(nums, idx+1, end);
        if(end-idx>=2)
            right = "("+right+")";
        return left+"/"+right;
    }


    string optimalDivision(vector<int>& nums) {
        int n=nums.size();
        for(int i=0; i<n; i++)
        {
            dpmax[i][i] = nums[i];
            dpmin[i][i] = nums[i];
        }
        for(int length=2; length<=n; length++)
        {
            for(int start=0; start<n; start++)
            {
                int end=start+length-1;
                if(end>=n)
                    break;
                double maxSplit = dpmax[start][start]/dpmin[start+1][end];
                int maxSplitIdx = start;
                double minSplit = dpmin[start][start]/dpmax[start+1][end];
                int minSplitIdx = start;
                for(int k=start+1; k<end; k++)
                {
                    double tmpMax = dpmax[start][k]/dpmin[k+1][end];
                    if(tmpMax>maxSplit)
                    {
                        maxSplit = tmpMax;
                        maxSplitIdx = k;
                    }
                    double tmpMin = dpmin[start][k]/dpmax[k+1][end];
                    if(tmpMin<minSplit)
                    {
                        minSplit = tmpMin;
                        minSplitIdx = k;
                    }
                }
                dpmax[start][end] = maxSplit;
                dpmaxIdx[start][end] = maxSplitIdx;
                dpmin[start][end] = minSplit;
                dpminIdx[start][end] = minSplitIdx;
            }
        }
        string ret;
        ret += wrapMax(nums, 0, n-1);
        return ret;

    }
};
```

方法二：数学

显然，为了使分子尽可能大，分母尽可能小，最优分割方法就是，第一个数字当分子，剩下的数字逐个做除法当分母。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    string optimalDivision(vector<int>& nums) {
        int n=nums.size();        
        if(n==1)
            return to_string(nums[0]);
        if(n==2)
            return to_string(nums[0]) + "/" + to_string(nums[1]);
        string res = to_string(nums[0]) + "/(" + to_string(nums[1]);
        for(int i = 2; i < n; i++)
            res.append("/" + to_string(nums[i]));
        res.append(")");
        return res;
    }
};
```



## 560.和为k的子数组

>给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。
>
>子数组是数组中元素的连续非空序列。
>
>- `1 <= nums.length <= 2 * 10^4`
>- `-1000 <= nums[i] <= 1000`
>- `-10^7 <= k <= 10^7`

动态规划。

最简单的枚举子串起点和终点的算法肯定会超时。考虑动态规划，我们是否能快速求出以 $nums[i]$ 为结尾的和为k的子数组的个数呢？即当我们遍历到 $nums[i]$ 时，我们要求的子串数量就等于字符串 $nums[0]$ 到 $nums[i-1]$ 的和为 $k-nums[i]$ 的后缀的数量。假设当前字符串 $nums[0]$ 到 $nums[i-1]$ 的和为 $sum$ ，那么问题就变成了求该字符串中和为 $sum-(k-nums[i])$ 的前缀的数量。于是，我们可以维护一个哈希表，记录每种前缀和的个数，并随着遍历更新这个哈希表即可。

时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        int n = nums.size();
        int ret = 0;
        int sum = 0;
        mp[0] = 1;
        for(int i=0; i<n; i++) {
            ret += mp[sum+nums[i]-k)];
            sum += nums[i];
            mp[sum]++;
        }
        return ret;
    }
};
```






## 561.数组拆分

>给定长度为 `2n` 的整数数组 `nums` ，你的任务是将这些数分成 `n` 对, 例如 `(a1, b1), (a2, b2), ..., (an, bn)` ，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。
>
>返回该 **最大总和** 。
>
>- `1 <= n <= 104`
>- `nums.length == 2 * n`
>- `-10^4 <= nums[i] <= 10^4`

贪心算法。每一对都只能取较小的数加和，那么等价于从数组中去掉n个数，使得这n个数的和尽可能小。而每次去掉一个数都要求有另一个比它更小的数留在数组中。因此直接将数组从小到大排序，每两个数一组即可。复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        int sz = nums.size();
        int res = 0;
        sort(nums.begin(), nums.end());
        for(int i=0; i<sz; i+=2)
            res += nums[i];
        return res;
    }
};
```



## 576.出界的路径数

>给你一个大小为 `m x n` 的网格和一个球。球的起始坐标为 `[startRow, startColumn]` 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 **最多** 可以移动 `maxMove` 次球。
>
>给你五个整数 `m`、`n`、`maxMove`、`startRow` 以及 `startColumn` ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 `10^9 + 7` **取余** 后的结果。
>
>- `1 <= m, n <= 50`
>- `0 <= maxMove <= 50`
>- `0 <= startRow < m`
>- `0 <= startColumn < n`

BFS+动态规划。

定义 $dp[k][i][j]:=移动k次后到达第i行第j列的路径数量$ 。我们从起点开始使用BFS遍历节点即可。由于在同一轮中，一个位置可能从不同的位置到达，为了避免同一个位置重复入队，使用一个vis数组记录新位置是否已经加入队列，这样每一轮开始前队列中最多有m×n个位置。当遍历到的位置出界时，将方案数加到结果中即可。另外，可以使用滚动dp数组。

时间复杂度 $O(maxMove\times m \times n)$ 。

```c++
class Solution {
public:
    typedef pair<int, int> P;
    static const int MOD=1e9+7;
    static const int N=55;
    int dp[2][N][N];
    int vis[N][N];
    P directions[4] = {P(-1, 0), P(0, -1), P(0, 1), P(1, 0)};

    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        queue<P> que;
        que.push(P(startRow, startColumn));
        dp[0][startRow][startColumn] = 1;
        int res=0;
        for(int i=1; i<=maxMove; i++)
        {
            int sz = que.size();
            while(sz--)
            { 
                P cur = que.front();
                que.pop();
                for(int j=0; j<4; j++)
                {
                    int nx = cur.first + directions[j].first;
                    int ny = cur.second + directions[j].second;
                    if(nx<0 || nx>=m || ny<0 || ny>=n)
                        res = (res+dp[(i-1)&1][cur.first][cur.second])%MOD;
                    else
                    {
                        if(vis[nx][ny]<i)
                        {
                            dp[i&1][nx][ny] = dp[(i-1)&1][cur.first][cur.second];
                            que.push(P(nx, ny));
                        }
                        else
                            dp[i&1][nx][ny] = (dp[i&1][nx][ny]+dp[(i-1)&1][cur.first][cur.second])%MOD;
                        vis[nx][ny] = i;
                    }
                }
            }
        }
        return res;
    }
};
```





## 581.最短无序连续子数组

>给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
>
>请你找出符合题意的 **最短** 子数组，并输出它的长度。
>
>- `1 <= nums.length <= 10^4`
>- `-10^5 <= nums[i] <= 10^5`

方法一：

复制一份数组，然后将复制后的数组排序，与原数组进行对比，即可知道无序连续子数组的起点和终点。时间复杂度 $O(n^2)$ 。

方法二：

假设最终要找的子数组为 $[left,right]$ ，我们可以分别考虑left和right。

对于左边界，显然 $[0,left-1]$ 之中的数全部小于 $[left, nums.size-1]$ 之中的数，且left位置的数大于 $[left+1, nums.size-1]$ 之中的最小值，否则就没有必要包括left。因此我们可以从数组的最后向前遍历，维护遍历到的最小值，最后一个满足 $nums[i]>min$ 的i即为left。同理可求right。时间复杂度 $O(n)$ 。

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int sz = nums.size();
        int left=sz;
        int right=-1;
        int curmin=INT_MAX;
        int curmax=INT_MIN;
        for(int i=sz-1; i>=0; i--)
        {
            if(nums[i]>curmin)
                left = i;
            else
                curmin = nums[i];
        }
        for(int i=0; i<sz; i++)
        {
            if(nums[i]<curmax)
                right = i;
            else
                curmax = nums[i];
        }
        if(left==sz)
            return 0;
        else
            return right-left+1;
    }
};
```





## 583.两个字符串的删除操作

>给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。
>
>**每步** 可以删除任意一个字符串中的一个字符。
>
>- `1 <= word1.length, word2.length <= 500`
>- `word1` 和 `word2` 只包含小写英文字母

动态规划。

此题其实就是求两个字符串的最长公共子序列(LCS)。因为要使得总步数最小，最终剩下的字符串一定是两个字符串的LCS。

时间复杂度 $O(mn)$ 。

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();
        if(len1==0 || len2==0)
            return len1+len2;
        vector<vector<int>> dp(len1, vector<int>(len2, 0));
        for(int i=0; i<len2; i++)
        {
            if(word1[0]==word2[i])
            {
                for(int j=i; j<len2; j++)
                    dp[0][j] = 1;
                break;
            }
        }
        for(int i=0; i<len1; i++)
        {
            if(word1[i]==word2[0])
            {
                for(int j=i; j<len1; j++)
                    dp[j][0] = 1;
                break;
            }
        }
        for(int i=1; i<len1; i++)
        {
            for(int j=1; j<len2; j++)
            {
                if(word1[i]==word2[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return len1+len2-2*dp[len1-1][len2-1];
    }
};
```

