# 拓扑排序

给定一个包含 *n* 个节点的有向图 *G*，我们给出它的节点编号的一种排列，如果满足：

> 对于图 *G* 中的任意一条有向边 (*u*,*v*)，*u* 在排列中都出现在 *v* 的前面。

那么称该排列是图 *G* 的拓扑排序。

根据上述的定义，我们可以得出两个结论：

+ 如果图 *G* 中存在环（即图 *G* 不是有向无环图），那么图 *G* 不存在拓扑排序。
+ 如果图 *G* 是有向无环图，那么它的拓扑排序可能不止一种。

下面介绍两种求解拓扑排序的算法：

## 1.DFS

对于一个DAG我们要按顺序输出图中的顶点，显然第一个输出的顶点一定是入度为0的顶点，即在上面的分析中所指的叶子节点。考虑将这个顶点输出后从图中删除，那么有可能有两种结果：

1. 删除的顶点的邻居顶点变成了新的入度为0的顶点。这种情况我们可以接着输出这个邻居，并将其从图中删除。
2. 删除顶点后没有产生新的入度为0的顶点。这种情况表明在图中当前访问的分支与其他分支汇合了，因此它的邻居还有其他先驱节点，此时还不能删除。

于是可以得到如下算法：

1. 将所有入度为0的顶点进栈。
2. 栈非空时，输出栈顶元素 Vj ；在邻接表中查找 Vj 的直接后继 Vk，把 Vk 的入度减1；若 Vk 的入度为 0 则进栈。
3. 重复上述操作直至栈空为止。
4. 若栈空时输出的顶点个数不是 n，则有向图有环；否则，拓扑排序完毕。



## 2.BFS

上面的算法会优先输出一条路径下的节点。而使用BFS则可以优先输出每条路径的起点。可以使用队列来存放入读为0的顶点，同样每次输出队列头，将它的邻居节点入读减1，如果入度减为0则将邻居入队。重复操作直到队列为空，若最终输出的顶点个数不是n，则有向图有环。







































