# 5. 继承

[TOC]

## 5.1 类、超类和子类

"is-a"关系是继承的一个明显特征。

### 5.1.1 定义子类

关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为**超类**（super class）、**基类**（base class）或**父类**（parent class）。新类称为**子类**（subclass）、派生类（derived class）或**孩子类**（child class）。

通过extends定义子类的时候，只需要指出子类与超类的不同之处。如继承Employee类的子类Manager，新增了私有字段bonus。



### 5.1.2 覆盖方法

在子类中覆盖超类的方法时，有时候需要调用超类的同名方法，可以使用super关键字。

```java
public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary+bonus;
}
```



### 5.1.3 子类构造器

```java
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day);
    bonus = 0;
}
```

由于Manager类的构造器不能访问Employee类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的super语法。使用super调用构造器的语句必须是子类构造器的第一条语句。如果没显示调用，则编译器默认调用超类的无参数构造器。

超类的引用可以引用子类。调用方法时，如果子类实现了，则调用子类的方法，否则向超类查询。

一个对象可以指示多种实际类型的现象称为**多态**（polymorphsim）。在运行时能够自动选择适当的方法，称为**动态绑定**（dynamic binding）



### 5.1.4 继承层次

由一个公共超类派生出来的所有类的集合称为**继承层次**（inheritance hierarchy）。

Java不支持多重继承。



### 5.1.5 多态

每个子类的对象也是超类的对象，例如，每个经理都是员工。在Java中，对象变量时多态的。一个Employee类型的变量既可以引用Employee类型的对象，也可以引用Employee的子类的对象。

在Java中，子类引用的数组可以转换成超类引用的数组，而不需要强制类型转换。

```java
Manager[] managers = new Manager[10];
Employee[] staff = managers;
```



### 5.1.6 理解方法调用

方法的调用过程：

1.   编译器查看对象的申明类型和方法名，列举当前类中所有名为f的方法以及超类中可访问的方法。

2.   **重载解析**：在所有名为f的方法中，选择参数类型最为匹配的方法。

     >当子类定义了一个方法的签名与超类的相同，则子类的方法将覆盖超类的方法。返回类型不是签名的一部分，不过在覆盖一个方法时，要保证返回类型的兼容性。允许子类将覆盖方法的返回类型改为原方法的返回类型的子类型。
     >
     >假设Employee类有以下方法：
     >
     >```java
     >public Employee getBuddy();
     >```
     >
     >则在子类Manager方法中，可以如下覆盖这个方法：
     >
     >```java
     >public Manager getBuddy();
     >```

3.   如果是private、static、final方法或者构造器，那么编译器就可以准确知道应该调用哪个方法，这称为**静态绑定**（static binding）。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时动态绑定。
4.   程序运行并且采用动态绑定调用方法时，虚拟机必须调用所引用对象的实际类型对应的方法，如果没有则在其超类中寻找。

每次调用方法都要完成该搜索，时间开销巨大。因此，虚拟机预先为每个类计算了一个**方法表**（method table），其中列出了所有方法的签名和要调用的实际方法。实际调用时，虚拟机仅查找这个表即可。

>在覆盖一个方法时，子类方法不能低于超类方法的可见性。如超类中方法时public，则子类中不能为private。



### 5.1.7 阻止继承：final类和方法

有时候，我们可能希望阻止人们利用某个类定义子类。不允许扩展的类称为final类。要定义final类，只需要在声明这个类时使用final修饰符。

类中的某个方法也可以被声明为final，表示子类不能覆盖这个方法。final类中的所有方法自动成为final方法（不包括字段）。

将方法或类声明为final的主要原因是：确保它们不会在子类中改变语意。

在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化，称为**内联**（inlining）。例如，内联调用e.getname()将被替换为访问字段e.name。然而，如果getName在另外一个类中被覆盖，那么编译器就无法进行内联了。幸运的事是，虚拟机中的即时编译器比传统的编译器处理能力强的多，它可以准确知道类之间的继承关系，并能够检测出是否有类覆盖了给定的方法，并对可以内联的方法进行内联优化。



### 5.1.8 强制类型转换

有时候需要将某个类的对象引用转换成另一个类的对象引用。

```java
Manager boss = (Manager)staff[0];
```

将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量时，就承诺过多了，必须进行强制类型转换，这样才能通过运行时检查。

进行强制类型转换的唯一原因是：要在暂时忽视对象的实际类型之后使用对象的全部功能。例如，Manager类是Employee类的子类。staff数组中有些元素是员工，所以必须是Employee类型的，但该数组中staff[0]引用了一个经理对象，所以之后再次使用经理对象时，需要先讲该对象复原为Manager类。

若是在继承链上进行向下的强制类型转换，并且谎报对象包含的内容，Java运行时系统会注意到你的承诺不符，并产生一个ClassCastException异常。如果没有捕获这个异常，那么程序就会终止。因此，应该养成一个良好的习惯：在进行强制类型转换之前，先使用instanceof操作符检查是否能够转换成功。

```java
if(staff[1] instanceof Manager)
{
    boss = (Manager) staff[1];
}
```

最后，如果这个强制类型转换不可能成功，那么编译器将编译失败。

```java
String c = (String)staff[1];
```

这将会产生编译错误，因为String不是Employee的子类。

>如果x为null，下面的测试不会产生异常。
>
>```java
>x instanceof C
>```



### 5.1.9 抽象类

有些祖先类很抽象，人们只将它作为派生其他类的基类，而不是用来构造特定的实例，这样的类称为**抽象类**。

等待子类继承并实现的方法称为抽象方法，使用abstract方法进行声明。

```java
public abstract String getDescription();
```

抽象方法不需要实现。此外，包含抽象方法的类必须声明为抽象类，抽象类不能实例化。

抽象类可以包含字段和具体方法。

```java
public abstract class Person
{
    private String name;
    
    public Person(String name)
    {
        this.name = name;
    }
    
    public abstract String getDescription();
    
    public String getName()
    {
        return name;
    }
}
```

抽象方法充当着占位方法的角色。在子类中，可以实现部分抽象方法，则子类仍未抽象类，也可以全部实现，则子类就不是抽象的了。

即使不包含抽象方法，也可以将类声明为抽象类，也可以定义一个抽象类的对象变量，但只能引用非抽象子类的对象。

>*C++注释*：在C++中，定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为**纯虚函数**（pure virtual function），才代表函数没有被实现，纯虚函数要在末尾用=0标记。
>
>```c++
>class Person
>{
>    public:
>    	virtual string getDescription()=0; 
>}
>```
>
>如果至少有一个纯虚函数，这个C++类就是抽象类。在C++中没有表示抽象类的特殊关键字。



### 5.1.10 受保护访问

有些时候，你可能希望限制超类中某个方法的部分使用权。使用protected字段，则只有本包中的类或该类的子类可以访问该字段。

>*C++注释*: 事实上，Java中的protected字段对所有子类和同一个包中的所有其他类可见，这与C++中的保护机制不同。

下面对Java中的4个访问控制修饰符做个小结：

1. private：仅对本类可见；
2. public： 对外部完全可见；
3. protected： 对本包和所有子类可见；
4. 默认（无修饰符）：对本包可见。



## 5.2 Object：所有类的超类

java中的所有类都扩展了Object类，但并不需要在声明时写  "extends Object"。如果没有明确指出超类，Object就被认为是这个类的超类。



### 5.2.1 Object类型的变量

Object类型的变量可以引用任何对象，但若要对其内容进行具体操作，还需要将其强制转换为其原始的类型。

在Java中，只有基本类型不是对象，包括数值、字符和布尔类型。

所有的数组类型，都扩展了Object类。

```java
Employee[] staff = new Employee[10];
obj = staff; //ok
obj = new int[10]; //ok
```

>*C++注释*： C++中没有所有类的根类，但是每个指针都可以转换为void*指针。



### 5.2.2 equals方法

Object类中的equals方法用于检测一个对象是否等于另外一个对象。Object类中实现的equals方法比较两个对象引用是否引用了同一个对象。

在子类中定义equals方法时，首先调用超类的equals，如果超类相等，再比较子类中的实例字段。

```java
public class Manager extends Employee
{
 	public boolean equals(Object otherObject)
    {
        if( !super.equals(otherObject) )
        	return false;
	    Manager other = (Manager)otherObject;
    	return bonus = other.bonus;
    }
}
```



### 5.2.3 相等测试与继承

Java要求equals方法具有下面的特性：

1. 自反性；
2. 对称性；
3. 传递性；
4. 一致性：如果x和y引用的对象没有发生变化，反复调用 *x.equals(y)* 的结果应该一致；
5. 对于任意非空引用x, x.equals(null) 应该返回false。

关于对象的相等性，有两种情况。

1. 子类可以有自己的相等性概念，对称性需求将强制使用getClass检测。例如Manager类的equals方法。只有两个对象的getClass方法的返回值相同，才能进一步比较它们的字段。
2. 由超类决定相等性概念，那么就可以使用instanceof检测，这样可以在不同子类对象之间进行相等性比较。例如AbstractSet类的equals方法，它将检测两个集合是否具有相同的元素。AbstractSet类有两个具体的子类：TreeSet和HashSet，它们分别使用不同的算法查找集合元素，但无论集合采用何种方式实现，equals方法应能比较它们的元素是否相同。应该将AbstractSet.equals方法声明为final，因为没有子类需要重新定义集合相等的语义。

下面给出一个完美的equals方法的建议：

1. 显式参数命名为otherOject，稍后转换为名外other的变量。

2. 检测this指针与otherOject是否相等。

    ```java
    if( this == otherOject) return true;
    ```

3. 检测otherObject是否为null，如果是，则返回false。

    ```java
    if( otherObject == null ) return false;
    ```

4. 比较this与otherObject的类。

    + 如果子类可以有自己的相等性概念，使用getClass检测。

        ```java
        if( getClass() != otherObject.getClass() ) return false;
        ```

    + 如果所有子类都使用相同的相等性语义，那么可以使用instanceof检测。

        ```java
        if( !(otherObject instanceof ClassName) ) return false;
        ```

5. 将otherObject强制类型转换为相应类的变。

    ```java
    ClassName other = (ClassName) otherObject;
    ```

6. 根据相等性的概念逐一比较字段。基本类型使用==，对象字段使用Objects.equals。

7. 如果在子类中重新定义equals，就要在其中包含一个super.equals(other)调用。

    >注意，这里调用super.equals是为了比较两个对象的超类部分的字段是否相等。虽然使用了超类的比较函数，但是这个方法的隐式参数this仍然为子类对象，所以超类的equals函数在比较两个对象的类型时是相等的，然后该函数会比较超类部分的字段。



### 5.2.4 hashCode方法

**散列码**（hash code）是由对象导出的一个整型值。如果x和y是两个不同的对象，则他们的散列码基本不会相同。

由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值由对象的存储地址得出。

字符串String类的散列码是由内容导出的。

如果重新定义了equals方法，就必须为用户可能插入散列表的对象重新定义hashCode方法。hashCode方法应该返回一个整数（也可以是负数）。要合理组合实例的各个字段的散列码，以使得不同对象的hashCode分布更加均匀。

```java
// 例如，下面是Employee类的hashCode方法
public class Employee
{
    public int hashCode()
    {
        return 7*name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode();
    }
}

//不过，可以使用null安全的Objects.hashCode方法。如果其参数为null，这个方法会返回0，否则返回对参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象
public int hashCode()
{
    return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);
}

//更好的做法是，使用Objects.hash方法，并提供这些参数，它会对各个参数调用Objects.hashCode，并组合这些散列值
public int hashCode()
{
    return Objects.hash(name, salary, hireDay);
}
```

equals与hashCode的定义必须相容：如果x.equals(y) 返回true，那么x.hashCod()就必须与y.hashCode()返回相同的值。



### 5.2.5 toString方法

Objects中还有一个重要的方法，toString方法，它会返回表示对象值的一个字符串。大多数toString方法遵循这样的格式：类的名字，随后是一对方括号扩起来的字段值。

```java
public String toString()
{
    return getClass().getName() + "[name=" + name + ",salary=" + salary + ",hireDay=" + hireDay + "]";
}
```

随处可见toString方法的原因是，只要对象与一个字符串通过操作符"+"连接起来，Java编译器就会自动调用toString方法来获得这个对象的字符串描述。

Object类定义了toString方法，可以打印对象的类名和散列码。

```java
System.out.println(System.out); // java.io.PrintStream@2f6684
```

>注意，数组继承了Object类的toString方法。
>
>补救的方法是调用静态方法Arrays.toString，如果是多维数组，则调用Arrays.deepToString。

```java
import java.lang.Object
//返回包含对象信息的类对象
Class getClass();

import java.lang.Class
//返回这个类的名字
String getName();
//以Class对象的形式返回这个类的超类
Class getSuperclass();
```



## 5.3 泛型数组列表

**ArrayList**是一个有**类型参数**（type parameter）的**范型类**（generic class），需要将列表保存的元素对象的类名用一对尖括号括起来。例如，ArrayList\<Employee\>。ArrayList类类似于数组，但是在添加或删除元素时，它能够自动调整数组容量。



### 5.3.1 声明数组列表

声明和构造一个保存Employee对象的数组列表：

```java
ArrayList<Employee> staff = new ArrayList<Employee>();
```

在Java10中，可以使用var关键字：

```java
var staff = new ArrayList<Employee>();
```

如果没有使用var关键字，可以省去右边的参数类型：

```java
ArrayList<Employee> staff = new ArrayList<>();
```

这称为“菱形”语法，可以结合new操作符使用。如果赋值给一个变量，或传递给某个方法，或者从某个方法返回，编译器会检查这个变量、参数或方法的泛型类型，并将这个类型放在<>中。

>*C++注释*： ArrayList类似于C++中的vector模版。但是Java没有运算符重载功能，所以ArrayList无法按照[]运算符访问。此外，vector是按值类型拷贝，而ArrayList将拷贝引用。

```java
import java.util.ArrayList;
//构造一个空数组列表
ArrayList<E>();

//用指定容量构造一个空数组列表
ArrayList<E>(int initialCapacity);

//在数组列表末尾追加一个元素，永远返回true
boolean add(E obj);

//返回当前存储在数组列表中的元素个数
int size();

//确保数组列表的容量至少为capacity
void ensureCapacity(int capacity);

//将数组列表的存储容量消减到当前大小
void trimToSize();
```



### 5.3.2 访问数组列表元素

Java没有运算符重载，因此需要使用get和set方法访问数组列表元素。

>警告：只有当数组列表存储的元素数大于i时，才能调用list.set(i, x)。

可以使用for each循环遍历数组列表。

```java
for(Employee e : staff)
    do something with e
```

```java
import java.util.ArrayList;

//将obj放在数组列表的指定索引位置，返回之前的内容
E set(int index, E obj);

//得到指定索引位置存储的值
E get(int index);

//在数组列表的位置i处插入一个元素,效率很低
boolean add(int i, E obj);

//将数组列表位置i处的元素移除，后面的元素前移，效率很低
boolean remove(int i);
```



### 5.3.3 类型化与原始数组列表的兼容性

Java5以前的版本没有提供泛型类，而是有一个保存Object类型元素的ArrayList类，它是一个自适应大小的集合。有时候为了处理遗留代码，不得不与使用原始ArrayList的代码交互。

可以将一个类型化的数组列表赋值给一个原始类型的数组列表，而不会得到警告。相反，将一个原始类型的数组列表赋值给一个类型化的数组列表会得到一个警告（即使使用强制类型转换）。

出于兼容性考虑，编译器检查没有发现违反规则的现象后，就将所有的类型化数组列表转换成原始的ArrayList对象。在程序运行时，所有的数组列表都是一样的，即虚拟机中没有类型参数。



## 5.4 对象包装器与自动装箱

所有的基本类型都有一个与之对应的类，这些类称为**包装器**（wrapper）：**Integer**、 **Long**、 **Float**、 **Double**、 **Shor**、 **Byte**、 **Character** 和 **Boolean**（前6个派生于超类Number）。

包装器类是不可变的，不允许更改包装在其中的值。同时，包装器类是final类。

假设想要定义一个整形数组列表，但尖括号中又必须是类名，因此可以使用Integer类。

```java
var list = new ArrayList<Integer>();
```

利用**自动装箱**（autoboxing），可以很容易地向ArrayList\<Integer\>添加int类型的元素。

```java
list.add(3);
//将自动变换成：
list.add(Integer.valueOf(3));
```

相反，将一个Integer对象赋值给一个int值时，会**自动拆箱**。

```java
int n = list.get(i);
//将自动变换成：
int n = list.get(i).intValue();
```

自动装箱和自动拆箱也适用于算数表达式，例如对Integer对象使用自增运算，编译器会自动先拆箱，自增后再装箱。

关于自动装箱，还有几点需要说明：

1. 由于包装器类引用可以为null，因此自动装箱可能抛出NullPointerException异常。
2. 如果在一个条件表达式中混用Integer和Double类型，Integer类型就会拆箱，提升为double，再装箱为Double。
3. 装箱和拆箱是编译器做的工作，而不是虚拟机。
4. 使用包装器的另一个原因是，可以在包装器中是实现一些基本方法，如Integer的静态方法parseInt。

```java
import java.lang.Integer
    
int intValue();
static String toString(int i);
//返回数值i基于radix参数指定进制的表示
static String toString(int i, int radix);
static int parseInt(String s);
//指定字符串是一个radix进制的数
static int parseInt(String s, int radix);
static Integer valueOf(String s);
static Integer valueOf(String s, int radix);
```



## 5.5 参数数量可变的方法

可以定义有可变参数数量的方法。

```java
public static double max(double... values)
{
    double large = Double.NEGATIVE_INFINITY;
    for( double v : values)
        if(v > large)
            largest = v;
    return largest;
}
```

其中，在参数类型后的三个点表示可以接受任意数量的对象（或基本数据），称为“变参”varargs。

varargs只能是参数列表的最后一项。

允许将数组作为最后一个参数传递给varargs。

```java
//主函数可以声明为以下形式：
public static void main(String... args);
```



## 5.6 枚举类

我们在第 3 章已经看到如何定义枚举类型。下面是一个典型的例子：

```java
public enum Size = {SMALL, MEDIUM, LARGE, EXTRA_LARGE};
```

实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，不可能构造新的对象。因此，在比较两个枚举类型的值时，并不需要调用 equals，直接使用“==”就可以了。如果需要的话，可以为枚举类型增加构造器、方法和字段。当然，构造器只是在构造枚举常量的时候调用。下面是一个示例：

```java
public enum Size
{
	SMALL ("S"), MEDIUM ("M"), LARGE ("L"), EXTRA LARGE ("XL");

	private String abbreviation;

	private Size(String abbreviation) { this.abbreviation = abbreviation;} 
    public String getAbbreviation () { return abbreviation;}
}
```

枚举的构造器总是私有的。

所有的枚举类都是Enum类的子类，继承了它的toString方法，这个方法会返回常量名。例如Size.SMALL.toString()将返回字符串"SMALL"。

toString方法的逆方法是静态方法valueOf。例如Size s = Enum.valueOf(Size.class, "SMALL");

每个枚举类都有一个静态方法values，它将返回一个包含全部枚举值的数组。



## 5.7 反射

**反射库**（reflection library）提供了一个精巧的工具集，可以用来编写能够动态操纵Java代码的程序。

能够分析类能力的程序称为反射。反射机制的功能：

+ 在运行时分析类的能力。
+ 在运行时检查对象，例如编写一个适用于所有类的toString方法。
+ 实现泛型数组操作代码。
+ 利用Method对象，这个对象很像C++中的函数指针。



### 5.7.1 class类

在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识。这个标识会跟踪每个对象所属的类。虚拟机根据运行时类型信息选择要执行的正确的方法。

可以使用一个特殊的Java类访问这些信息，Class类。Object类中的getClass方法会返回一个Class类型的实例。

Class对象会描述一个特定类的属性。如getName方法可以返回类的名字。还可以使用forName获得类名对应的Class对象。

```java
Employee e;
Class cl = e.getClass();

String className = "java.util.Random";
Class cl = Class.forName(className);
```

获得Class类对象的第三种方法是，如果T是任意的Java类型，T.class将代表匹配的类对象。

```java
Class cl1 = Random.class;
Class cl2 = int.class;
Class cl3 = Double[].class
```

如果有一个Class类型的对象，可以用它来构造实例。调用getConstructor方法将得到一个Constructor类型的对象，然后用newInstance方法构造一个实例。

```java
var classname = "java.util.Random";
Class cl = Class.forName(className);
object obj = cl.getConstructor().newInstance();
```



### 5.7.2 声明异常入门

异常有两种，非检查型（unchecked）异常和检查型（checked）异常。编译器会要求程序员必须对检查型异常进行捕获。

如果一个函数包含一条可能抛出检查型异常的语句，则在方法名上增加一个throws子句。调用这个方法的任何方法也要提供一个throws子句。

```java
public static void doSomethingWithClass(String name) throws ReflectiveOperationException 
{
    Class cl = Class.forName(name) ; // might throw exception 
    // do something with cl 
}
```



### 5.7.3 资源

类通常有一些关联的数据文件，如图像、文本等。将这些文件放在JAR文件中是很方便的。例如：

```shell
javac resource/ResourceTest.java 
jar cvfe ResourceTest.jar resources.ResourceTest resources/*.class resources/*.gif resources/data/*.txt corejava/*.txt
java -jar ResourceTest.jar
```

访问被打包到JAR文件中的资源的步骤：

1. 获得拥有资源的类Class对象。
2. 有些方法接收描述资源位置的URL，则要调用URL url=cl.getResource(about.gif);
3. 否则，使用getResourceAsStream方法得到一个输入流来读取文件。

```java
package resources; 
import java.io.*;
import java.net.*;
import java.nio.charset.*;
import javax.swing.*;

public class ResourceTest
{
    public static void main(String[] args) throws IOException 
    {
        Class cl = ResourceTest.class;
        URL aboutURL = cl.getResource ("about.gif");
        var icon = new ImageIcon(aboutURL);
        
        InputStream stream = cl.getResourceAsStream("data/about.txt");
        var about = new String(stream.readAllBytes (), "UTF-8");
        
        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String (stream2. readAllBytes(), StandardCharsets.UTF_8).trim(); 			JOptionPane.showMessageDialog (null, about, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }
}
```

```java
#import java.lang.Class
// 找到与类位于同一位置的资源，返回一个URl或者输入流，如果没找到资源，返回null，不会抛出异常或者IO错误
URL getResource(String name);
InputStream getResourceAsStream(String name);
```



### 5.7.4 利用反射分析类的能力

反射机制最重要的内容：检查类的结构。

在java.lang.reflect包中有三个类，Field，Method，Constructor分别用于描述类的字段、方法和构造器。这三个类都有一个getName方法，用来返回名称。他们都有一个getModifiers方法，返回一个整数，用不用的0/1位描述所使用的修饰符，如public和static。

Class类中的getFields，getMethods，getConstructor方法将分别返回这个类支持的公共字段，方法和构造器的数组，其中包括超类的公共成员。Class类的getDeclaredFields，getDeclaredMethods，getDeclaredConstructors方法将分别返回类中声明的全部字段、方法和构造器的数组，但不包括超类的成员。

如下面的代码，输入一个类名，程序将输出类中所有的实例字段、方法和构造器的签名。

```java
package reflection;

import java.util.*;
import java.lang.reflect.*;

public class ReflectionTest
{
    public static void main(String[] args) throws ReflectiveOperationException
    {
        //read class name
        var in = new Scanner(System.in);
        name = in.next();
        
        Class cl = Class.forName(name);
        Class supercl = cl.getSuperclass();
        String modifiers = Modifier.toString(cl.getModifiers());
        if(modifiers.length()>0)
        {
            System.out.print(modifiers+" ");
        }
        System.out.print("class "+name);
        if(supercl != null && supercl != Object.class)
            System.out.print(" extends "+supercl.getName());
        System.out.print("\n{\n");
        printConsturctors(cl);
        System.out.print("\n");
        printMethods(cl);
        System.out.print("\n");
        printFields(cl);
        System.out.print("\n}\n");
    }
    
    public static void printConstructors(class cl)
    {
        Constructors[] constructors = cl.getDeclaredConstructors();
        for( c : constructors)
        {
        	String name = c.getName();
         	System.out.print("   ");
         	String modifiers = Modifier.toString(c.getModifiers());
         	if (modifiers.length() > 0) 
                System.out.print(modifiers + " ");         
         	System.out.print(name + "(");

         	// print parameter types
         	Class[] paramTypes = c.getParameterTypes();
         	for (int j = 0; j < paramTypes.length; j++)
         	{
            	if (j > 0) 
                    System.out.print(", ");
            	System.out.print(paramTypes[j].getName());
         	}
         	System.out.println(");");
        }
    }
    
    public static void printMethods(Class cl)
    {
    	Method[] methods = cl.getDeclaredMethods();

      	for (Method m : methods)
      	{
        	Class retType = m.getReturnType();
         	String name = m.getName();

	        System.out.print("   ");
         	// print modifiers, return type and method name
         	String modifiers = Modifier.toString(m.getModifiers());
         	if (modifiers.length() > 0)
                System.out.print(modifiers + " ");         
         	System.out.print(retType.getName() + " " + name + "(");

	        // print parameter types
         	Class[] paramTypes = m.getParameterTypes();
         	for (int j = 0; j < paramTypes.length; j++)
         	{
            	if (j > 0) System.out.print(", ");
            	System.out.print(paramTypes[j].getName());
         	}
         	System.out.println(");");
      	}
    }
    
    public static void printFields(Class cl)
    {
        Field[] fields = cl.getDeclaredFields();
        for (Field f : fields)
        {
            Class type = f.getType();
            String name = f.getName();
            System.out.print("   ");
            String modifiers = Modifier.toString(f.getModifiers());
            if (modifiers.length() > 0) 
                System.out.print(modifiers + " ");   
            System.out.println(type.getName() + " " + name + ";");
        }
    }
}
```



### 5.7.5 使用反射在运行时分析对象

在上一节中，我们已经知道如何查看任意对象数据字段的名字和类型：

1. 获得对应的Class对象。
2. 在这个Class对象上调用getDeclaredFields。

在编写程序时，想要查看对象中指定字段的内容是一件很容易的事，而利用反射机制可以查看在编译阶段还不知道的对象字段。

如果f是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj是某个包含f字段的类的对象，则f.get(obj)将返回一个对象，其值为obj的当前字段值。

```java
var harry = new Employee("Harry Hacker", 50000, 10, 1, 1989);
Class cl = harry.getClass();
Field f = cl.getDeclaredField("name");
Object v = f.get(harry);
```

当然，也可以调用f.set(obj, value)把对象obj的f字段设置为value。实际上，上面的代码有个问题。由于name是私有字段，所以get和set方法都会抛出IllegalAccessException。反射机制默认受限于Java的访问控制。不过可以调用setAccessible方法覆盖Java的访问控制。

```java
f.setAccessible(true); // now ok to call f.get(harry)
```

setAccessible是AccessibleObject类的方法，它是Field，Method，Constructor类的超类。



### 5.7.6 使用反射编写泛型数组代码

考虑要编写Array类的copyOf方法。

```java
public static Object[] badCopy0f(Object[] a, int newLength) // not useful
{
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math. min(a. length, newLength));
    return newArray;
}
```

这段代码在创建新数组时有一个问题。Java数组会记住每个元素的类型，即创建数组时new表达式中使用的元素类型。将一个Employee[]临时转换成Object[]数组，然后再把它转换回来是可以的，但从一开始就是Object[]的数组却不能转换为Employee[]。因此，这段代码复制出的数组并不能使用。

为了编写通用的数组代码，需要能创建于原数组类型相同的新数组。为此，需要java.lang.reflect包中Array类的静态方法newInstance，这个方法可以构造一个新数组，需要两个参数，一个是数组的元素类型，另一个是数组的长度。

可以通过Array.getLength(a)获得数组的长度。

可以通过以下步骤获得数组的元素类型：

1. 获得a数组的类对象
2. 确认它是一个数组
3. 使用Class类的getComponentType方法确定数组元素类型

```java
public static Object goodCopy0f(Object a, int newLength)
{
    Class cl = a. getClass();
    if (!cl.isArray ()) 
        return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
    return newArray;
}
```



### 5.7.7 调用任意方法和构造器

回想一下，可以用Field类的get方法查看一个对象的字段。与之类似，Method类有一个invoke方法。

```java
Object invoke(Object obj, Object... args);
```

第一个参数是隐式参数（静态方法可设置为null），其余的对象提供了显式参数。如果返回类型是基本类型，invoke方法会返回其包装器类型。

例如，假设用m1表示Employee类的getName方法。

```java
String n = (String)m1.invoke(harry);
```

可以使用getDeclaredMethods方法返回对象的所有方法并搜索，也可以使用geMethod方法获得指定方法。

```java
Method getMethod(String name, Class... parameterTypes);
```

例如，获得Employee对象的getName方法和raiseSalary方法。

```java
Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);
```

可以使用类似的方法使用构造器，将构造器的参数类型提供给Class.getConstructor方法，并将参数值提供给Constructor.newInstance方法。

```java
Class cl = Random.class //或者其他构造器使用长整型参数的类
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(42L);
```



## 5.8 继承设计的技巧

1. 将公共操作和字段放在超类中
2. 不要使用受保护的字段
3. 使用继承实现"is-a"关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而不要使用类型信息
7. 不要滥用反射







