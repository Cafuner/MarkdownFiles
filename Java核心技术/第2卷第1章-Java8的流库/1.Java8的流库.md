# 1.Java8的流库

[TOC]



与集合相比，流提供了一种可以让我们在更高的概念级别上指定计算任务的数据视图。通过使用流，我们可以说明想要完成什么任务，而不是说明如何去实现它。我们将操作的调度留给具体实现去解决。例如，假设我们想要计算某个属性的平均值，那么我们就可以指定数据源和该属性，然后，流库就可以对计算进行优化，例如，使用多线程来计算总和与个数，并将结果合并。

在本章中，你将会学习如何使用 Java 的流库，它是在 Java 8中引入的，用来以“做什么而非怎么做”的方式处理集合。

## 1.1 从迭代到流的操作

假设我们有一个存储单词的list，现在要对其中长度大于12的单词进行计数。使用迭代的代码如下：

```java
int count = 0;
for (String w: words){
	if(w.length()>12) count++;
}
```

而使用流的代码如下：

```java
Long count = words.stream()
	.filter(w->w.length()>12)
	.count();

Long count = words.parallelStream() // 让流库以并行方式执行过滤和计数
	.filter(w->w.length()>12)
	.count();
```

现在我们不必扫描整个代码去查找过滤和计数操作，方法名就可以直接告诉我们其代码意欲何为。而且，循环需要非常详细地指定操作的顺序，而流却能够以其想要的任何方式来调度这些操作，只要结果是正确的即可。

流表面上看起来和集合很类似，都可以让我们转换和获取数据。但是，它们之间存在着显著的差异：

1. 流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。
2. 流的操作不会修改其数据源。例如，filter方法不会从流中移除元素，而是会生成一个新的流，其中不包含被过滤掉的元素。

3. 流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。例如，如果我们只想查找前5个长单词而不是所有长单词，那么filter 方法就会在匹配到第5个单词后停止过滤。因此，我们甚至可以操作无限流。

上面这个工作流是操作流时的典型流程。我们建立了一个包含三个阶段的操作管道：

1. 创建一个流。
2. 指定将初始流转换为其他流的中间操作，可能包含多个步骤。

3. 应用终止操作，从而产生结果。这个操作会强制执行之前的惰性操作。从此之后，这个流就再也不能用了。

下一节将介绍如何创建流，后续3节将介绍流的转换，再后面5节将介绍终止操作。

```java
java.util.stream.Stream<T>

// 产生一个流，其中包含当前流中满足p的所有元素    
Stream<T> filter(Predicate<? super T> p)

// 产生当前流中元素的数量。这是一个终止操作。
long count()
    
java.util.Collection<E>

//产生当前集合中所有元素的顺序流或并行流。
default Stream<E> stream()
default Stream<E> parallelStream()
```



## 1.2 流的创建

Collection 接口具有方法 stream。因此你可以在任何集合上调用 stream 方法将其转换为一个流。如果是一个数组，可以使用静态方法 Stream.of。

```java
Stream<String> words = Stream.of(contents.split("\\PL+"));
```

of 方法具有可变长参数：

```java
Stream<String> song = Stream.of("gently", "down", "the", "stream");
```

还可以使用 Arrays 的静态方法 Arrays.stream(array, from, to) 将数组的一部分元素创建为一个流。

如果要创建不包含元素的流，可以使用静态方法 Stream.empty：

```java
Stream<String> silence = Stream.empty();
// 泛型String可以自动推导。上面的代码与 Stream.<String>empty() 作用相同。
```

Strean 接口有两个用于创建无限流的静态方法。

1. generate 方法会接受一个不包含任何引元的函数（或者从技术上讲，是一个 SupplierT>接口的对象）。无论何时，只要需要一个流类型的值，该函数就会被调用以产生一个这样的值。我们可以像下面这样获得一个常量值的流：

    ```java
    Stream<String> echos = Stream.generate(()->"Echo");
    ```



2. 如果要产生像123…这样的序列，可以使用 iterate 方法。它会接受一个“种子” 以及一个函数（从技术上讲，是一个 `UnaryOperation<T>`)，并且会反复地将该函数应用到之前的结果上。例如：

    ```java
    Stream<BigInteger> integers
        = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger. ONE));
    ```

    如果要产生一个有限序列，则需要添加一个谓词来描述迭代应该如何结束：

    ```java
    var limit = new BigInteger("100000");
    Stream<BigInteger> integers
         = Stream.iterate(BigInteger.ZERO, 
                          n->n.compareTo(limit)<0,
                          n->n.add(BigInteger.ONE));
    ```

>注释：如果我们持有的 Iterable 对象不是集合，那么可以通过下面的调用将其转换为一个流：
>```java
>StreamSupport.stream(iterable.spliterator(), false);
>```
>
>如果我们持有的是 Iterator 对象，并且希望得到一个由它的结果构成的流，那么可以使用下面的语句：
>```java
>StreamSupport.stream(Spliterators.spliteratorUnknownSize(
>	iterator, Spliterator.ORDERED), false);
>```

> 警告：在执行流的操作时，我们并没有修改流背后的集合。记住，流并没有收集其数据，数据一直存储在单独的集合中。如果修改了该集合，那么流操作的结果就会变成未定义的。JDK 文档称这种要求为不干涉性。



## 1.3 filter、map 和 flatMap方法

流的转换会产生一个新的流，它的元素派生自另一个流中的元素。

### 1.3.1 filter

filter 转换会产生一个新流，它的元素与某种条件相匹配。下面，我们将一个字符串流转换为只包含长单词的另一个流：

```java
List<String> words = ...;
Stream<String> longWords = words.stream().filter(w->w.length()>12);
```

filter 的引元是`Predicate<T>` ，即从 T 到 boolean 的函数。 filter 的功能就是产生一个新流，其中的元素都使得这个 Predicate 函数式接口的 test 方法返回 true。

### 1.3.2 map

通常，我们想要按照某种方式来转换流中的值，此时，可以使用 map 方法并传递执行该转换的函数。例如，我们可以像下面这样将所有单词都转换为小写：
```java
Stream<String> LowercaseWords = words.stream().map(String::toLowerCase);
```

下面的示例展示的方法会将字符串转换为字符串流，即一个个的编码点。这个方法可以正确地处理需要用两个 char 值来表示的 Unicode 字符。

```java
public static Stream<String> codePoints(String s)
{
    var result = new ArrayList<String>();
    int i=0;
    while(i<s.length())
    {
        int j = s.offsetByCodePoints(i, 1); // 返回从位置i开始，偏移1个码点后的位置
        result.add(s.substring(i,j));
        i = j;
    }
    return result.stream();
}
```



### 1.3.3 flatMap

假设我们将 codePoints 方法映射到一个字符串流上：

```java
Strean<Stream<String>> result = words.stream().map(w -> codePoints(w));
```

那么会得到一个包含流的流，就像[…["y","o","u","r"],["b","o","a","t"],……]。为了将其摊平为单个流，可以使用 flatMap 方法而不是 map 方法：

```java
Stream<String> flatResult = words.stream().flatMap(w -> codePoints(w));
// Calls codePoints on each word and flattens the results
```



```java
java.util.stream.Stream
    
Strean<T> filter(Predicatex？ super T> predicate)
//产生一个流，它包含当前流中所有满足谓词条件的元素。

<R> Stream<R> map(Function<? super T, ? extends R> mapper)
//产生一个流，它包含将 mapper 应用于当前流中所有元素所产生的结果。

<R> Stream<R> flatMap (Function<? super T,? extends Stream<? extends R>> mapper)
// 产生一个流，它是通过将 mapper 应用于当前流中所有元素所产生的结果连接到一起而获得的。（注意，这里的每个结果都是一个流。）
```



## 1.4 抽取子流和组合流

### 1.4.1 limit 方法

```java
Stream<T> limit(long maxSize) 
```

stream.limit(n)调用会返回一个新的流，它在n个元素之后结束。（如果原来的流比n短，那么就会在该流结束时结束）。这个方法对于裁剪无限流的尺寸特别有用。

```java
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
```

### 1.4.2 skip 方法

```java
Stream<T> skip(long n)
```

调用 stream.skip(n) 正好相反：它会丢弃前n个元素。

### 1.4.3 takeWhile 方法

```java
Stream<T> takeWhile(Predicate<? super T> predicate)
```

stream.takewhile(predicate) 调用会在谓词为真时获取流中的元素，直到遇到第一个使得谓词为假的元素。

### 1.4.4 dropWhile 方法

```java
Stream<T> dropWhile(Predicate<? super T> predicate)
```

dropwhile(predicate) 方法的做法正好相反，它会在条件为真时丢弃元素，并产生一个由第一个使该条件为假的字符开始的所有元素构成的流。

### 1.4.5 concat 方法

```java
static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
```

我们可以用 Stream 类的静态 concat 方法将两个流连接起来：

```java
Stream<String> combined = Stream.concat(
	codePoints("Hello"), codePoints("World"));
// Yields the stream ["H","e", "l", "l", "o", "W", "o"，"r", "l", "d"]
```


当然，第一个流不应该是无限的，否则第二个流永远都不会有机会处理。



## 1.5 其他的流转换

### 1.5.1 distinct 方法

```java
Stream<T> distinct()
```

distinct 方法会返回一个流，它的元素是从原有流中产生的，即原来的元素按照同样的顺序剔除重复元素后产生的。这些重复元素并不一定是相邻的。

```java
Stream<String> uniqueWords 
    = Stream.of("merrily","merrily","merrily","gently","merrily").distinct(); 
// Only first "merrily" is retained
```

### 1.5.2 sorted 方法

```java
Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)
```

对于流的排序，有多种 sorted 方法的变体可用。其中一种用于操作 Comparable 元素的流，而另一种可以接受一个 Comparator。下面，我们字符串排序，使得最长的字符串排在最前面：

```java
Stream<String> LongestFirst
    = words.stream().sorted(Comparator.comparing(String::length).reversed());
```

当然，我们在对集合排序时可以不使用流。但是，当排序处理是流管道的一部分时，sorted 方法就会显得很有用。

### 1.5.3 peek 方法

```java
Stream<T> peek(Consumer<? super T> action)
```

peek 方法会产生另一个流，它的元素与原来流中的元素相同，但是在每次获取一个元素时，都会调用一个函数。这对于调试来说很方便：
```java
Object[] powers = Stream.iterate(1.0, p -> p * 2)
    .peek(e -> System.out.println("Fetching " + e))
    .limit(20).toArray();
```


当实际访问一个元素时，就会打印出来一条消息。通过这种方式，你可以验证 iterate 返回的无限流是被情性处理的。



## 1.6 简单约简

本节所讨论的方法被称为约简。约简是一种**终结操作(terminal operation)**。它们会将流约简为可以在程序中使用的非流值。

### 1.6.1 count、min 和 max

你已经看到过一种简单约简：count 方法会返回流中元素的数量。其他的简单约简还有 max 和 min，它们分别返回最大值和最小值。这里要稍作解释，这些方法返回的是一个类型 `Optional<T>` 的值，它要么在其中包装了答案，要么表示没有任何值(因为流碰巧为空)。在过去，碰到这种情况返回 null 是很常见的，但是这样做会导致在未做完备测试的程序中产生空指针异常。Optional 类型是一种表示缺少返回值的更好的方式。我们将在下一节中详细讨论 Optional 类型。下面展示了如何获得流中的最大值：

```java
Optional<String> largest = words.max(String::compareToIgnoreCase);
System.out.printLn("largest:" + largest.orElse(""));
```

### 1.6.2 findFirst 和 findAny

findFirst 返回的是非空集合中的第一个值。它通常在与 filter 组合使用时很有用。如果不强调使用第一个匹配，而是使用任意的匹配都可以，那么就可以使用 findAny 方法。这个方法在并行处理流时很有效，因为流可以报告任何它找到的匹配而不是被限制为必须报告第一个匹配。

```java
Optional<String> startsWithQ
    = words.filter(s->s.startsWith("Q")).findFirst();
Optional<String> startsWithQ
    = words.parallel().filter(s->s.startsWith("Q")).findAny();
```

### 1.6.3 anyMatch、allMatch 和 noneMatch 

这三个方法返回boolean值，分别在流中存在元素匹配谓词、流中全部元素匹配谓词和流中没有元素匹配谓词时返回 true。



## 1.7 Optional 类型

`Optional<T>` 对象是一种包装器对象，要么包装了类型T的对象，要么没有包装任何对象。对于第一种情况，我们称这种值是存在的。`Optional<T>`类型被当作一种更安全的方式，用来替代类型T的引用，这种引用要么引用某个对象，要么为 null。但是，它只有在正确使用的情况下才会更安全，接下来的三个小节我们将讨论如何正确使用。

### 1.7.1 获取 Optional 值

有3个方法可以获取Optional的值，它们的统一策略是，如果值存在则返回值，否则采取不同的措施。

#### 1.7.1.1 orElse

```java
T orElse(T other)
// 产生这个 Optional 的值，或者在该 Optional 为空时，产生 other。

String result = optionalString.orELse("");
// The wrapped string, or "" if none
```

#### 1.7.1.2 orElseGet

```java
T orElseGet(Supplier<? extends T> other)
// 产生这个 Optional 的值，或者在该 Optional 为空时，产生调用 other 的结果。

String result = optionalString.orElseGet(
    () -> System.getProperty("myapp.default"));
// The function is only called when needed
```

#### 1.7.1.3 orElseThrow

```java
<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)
// 产生这个 Optional 的值，或者在该 Optional 为空时，抛出调用 exceptionSupplier 的结果。
        
String result = optionalString.orElseThrow(IllegalStateException::new);
// Supply a method that yields an exception object
```



### 1.7.2 消费 Optional 值

在上一小节，我们看到了如何在不存在任何值的情况下产生相应的替代物。另一条使用可选值的策略是只有在其存在的情况下才消费该值。

```java
void ifPresent (Consumer<? super T> action)
// 如果该 Optional 不为空，就将它的值传递给 action。

void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)
// 如果该 Optional 不为空，就将它的值传递给 action，否则调用 emptyAction。
```

#### 1.7.2.1 ifPresent

ifPresent 方法会接受一个函数。如果可选值存在，那么它会被传递给该函数。否则，不会发生任何事情。

例如，如果在该值存在的情况下想要将其添加到某个集中，那么就可以如下调用：
```java
optionalValue.ifPresent(v -> results.add(v));
// 或者直接调用 optionalValue.ifPresent(results::add)；
```

#### 1.7.2.2 ifPresentOrElse

如果想要在可选值存在时执行一种动作，在可选值不存在时执行另一种动作，可以使用ifPresentOrElse。

```java
optionalValue.ifPresentorElse(
    v -> System.out.println("Found" + V),
	()-> logger.warning ("No match"));
```



### 1.7.3 管道化 Optional 值

在上一节中我们介绍了如何从 Optional 对象获取值。另一种有用的策略是使用 map 方法来转换 Optional 内部的值：

```java
Optional<String> transformed = optionalString.map(String::toUpperCase);
```

如果 optionalString 为空，那么 transformed 也为空。

下面是另一个例子，我们将一个结果添加到列表中，如果它存在的话：

```java
optionalValue.map(results::add);
```


如果 optionalValue 为空，则什么也不会发生。

>这个map 方法与1.3节中描述的 Stream 接口的 map 方法类似。你可以直接将可选值想象成尺寸为0或1的流。结果的尺寸也是0或1，并且在后一种情况中，函数会应用于其上。

类似地，可以使用 filter 方法来只处理那些在转换它之前或之后满足某种特定属性的 Optional 值。如果不满足该属性，那么管道会产生空的结果：

```java
Optional<String> transformed = optionalString
    .filter(s-> s.length() >= 8)
    .map(String::toUpperCase);
```


也可以用 or 方法将空 Optional 替换为一个可替代的 Optional。这个可替代值将以惰性方式计算。

```java
Optional<String> result = optionalString.or(() -> // Supply an Optional
	alternatives.stream().findFirst());
```

如果 optionalString 的值存在，那么 result 为 optionalString。如果值不存在，那么就会计算 lambda 表达式，并使用计算出来的结果。



```java
java.util.Optional
<U> Optional<U> map(Function<? super T, ? extends U> mapper)
// 产生一个 Optional，如果当前的 Optional 的值存在，那么所产生的 Optional 的值是通过将给定的函数应用于当前的 Optional 的值而得到的；否则，产生一个空的 Optional。
    
Optional<T> filter(Predicate<? super T> predicate)
// 产生一个 Optional，如果当前的 Optional 的值满足给定的谓词条件，那么所产生的 Optional 的值就是当前 Optional 的值；否则，产生一个空 Optional。
    
Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)
// 如果当前 Optional 不为空，则产生当前的 Optional；否则由 supplier 产生一个 Optional。
```



### 1.7.4 不适合使用 Optional 值的方式

如果没有正确地使用 Optional 值，那么相比以往得到某对象或null 的方式，这种方式并没有得到任何好处。

get 方法会在 Optional 值存在的情况下获得其中包裝的元素，或者在不存在的情况下抛出一个 NoSuchELementException 异常。因此，下面的两种方式的安全性没什么区别：

```java
Optional<T> optionalValue = ...;
optionalValue.get().someMethod();
// 与下面的代码相同，都会抛出异常
T value = ...;
value.someMethod();
```

ifPresent 方法可以检测一个 `Optional<T>` 对象是否具有值，但是这种检测和直接检测value是否为null没有什么本质区别。

因此，合理的使用 Optional 值应该是这样：

1. Optional 类型的变量永远都不应该为 null。
2. 不要使用 Optional 类型的域。因为其代价是额外多出来一个对象。在类的内部，使用 null 表示缺失的域更易于操作。
3. 不要在集合中放置 Optional 对象，并且不要将它们用作 map 的键。应该直接收集其中的值。



### 1.7.5 创建 Optional 值

到目前为止，我们已经讨论了如何使用其他人创建的 Optional 对象。如果想要编写方法来创建 Optional 对象，可以使用 Optional.of(result) 和 Optional.empty()，它们分别创建值为 result 和空的 Optional 对象。例如：

```java
public static Optional<Double> inverse(Double x)
{
	return x == 0 ? Optional.empty() : Optional.of(1 / x);
}
```

ofNullable 方法被用来作为可能出现的 null 值和可选值之间的桥梁。Optional.ofNullable(obj) 会在 obj 不为 null 的情况下返回 Optional.of(obj)，否则会返回 Optional.empty()。



### 1.7.6 用 flatMap 构建 Optional 值的函数

假设你有一个可以产生 `Optional<T>` 对象的方法f，并且目标类型 T 具有一个可以产生 `Optiona<U>` 对象的方法 g。如果它们都是普通的方法，那么我们希望通过调用 s.f().g() 来将它们组合起来。但是这种组合无法工作，因为 s.f() 的类型为 `Optional<T>`，而不是T。因此，需要进行如下调用：
```java
Optional<U> result = s.f().flatMap(T::g);
```

如果 s.f() 的值存在，那么 g 就可以应用到它上面。否则，就会返回一个空 `Optional<U>`。显然，如果有更多可以产生 Optional 值的方法或 lambda 表达式，那么就可以重复此过程。于是，可以直接将对 flatMap 的调用链接起来，从而构建由这些步骤构成的管道，只有所有步骤都成功，该管道才会成功。

>我们在 Stream 接口中看到过 flatMap 方法（参见1.3.3 节)，当时这个方法被用来将产生流的两个方法组合起来，其实现方式是摊平由流构成的流。如果将Optional看作具有0个或1个元素的流，那么Optional.flatMap 方法与流的flatMap方法的工作原理是一样的。

例如，考虑前一节中安全的 inverse 方法，假设我们还有一个安全的平方根：

```java
public static Optional<Double> squareRoot(Double x)
{
    return x<0 ? Optional.empty() : Optional.of(Math.sqrt(x));
}
```

那么我们可以这样计算一个数的倒数的平方根：

```java
Optional<Double> result = inverse(x).flatMap(MyMath::squareRoot);
```

```java
<U> Optional<U> flatMap(Function<? super T, ? extends Optional<？ extends U>> mapper)
// 如果 Optional 存在，产生将 mapper 应用于当前 Optional 值所产生的结果，或者在当前 Optional 为空时，返回一个空 Optional。
```



### 1.7.7 将 Optional 转换为流

stream 方法会将一个 `Optional<T>` 对象转换为一个具有0个或1个元素的 `Stream<T>` 对象。这种做法看起来很自然，但是我们为什么希望这么做呢？原因是这会使返回 Optional 结果的方法变更灵活。假设我们有一个用户 ID 流和下面的方法：

```java
Optional<User> lookup(String id)
```

怎样才能在获取用户流时，跳过那些无效的ID呢？ 下面是一种方法：

```java
Stream<String> ids = ...;
Stream<User> users = ids.map(Users::lookup)
	.filter(Optional::isPresent)
	.map(Optional::get);
```

但是这样就需要使用我们之前警告过要慎用的 isPresent 和 get 方法。

实际上，Optional 可以转换为具有0/1个元素的流。下面的调用显得更优雅：

```java
Stream<User> users = ids.map(Users::lookup)
    .flatMap(Optional::stream);
```

每一个对 stream 的调用都会返回一个具有0个或1个元素的流。flatMap 方法将这些方法组合在一起，这意味着不存在的用户会直接被丢弃。



## 1.8 收集结果

当处理完流之后，通常会想要查看其结果。下面介绍几种收集结果的方法。

### 1.8.1 iterator

在流对象上调用 iterator 方法可以生成一个旧式风格的迭代器，可以用来逐个访问流中的元素。

但是，要注意，Java流并没有实现 Iterable 接口。原因是 Iterable 接口的含义是集合可以重复迭代，而 Stream 的 iterator 方法是终结方法，只能使用一次。

### 1.8.2 forEach

可以调用 forEach 方法，将某个函数应用于每个元素。在并行流上，forEach 方法会以任意顺序遍历各个元素。如果想要按照流中的顺序来处理它们，可以调用 forEachOrdered 方法。当然，这个方法会丧失并行处理的部分甚至全部优势。
```java
stream.forEach(System.out::println);
```

### 1.8.3 toArray

但是，更常见的情况是，我们想要将结果收集到数据结构中。此时，可以调用 toArray，获得由流的元素构成的数组。

因为无法在运行时创建泛型数组，所以表达式 stream.toArray() 会返回一个 `Object[]` 数组。如果想要让数组具有正确的类型，可以将该类型的new方法作为toArray方法的参数。

```java
String[] result = stream.toArray(String[]::new); 
// stream.toArray() has type Object[]
```

>这里你可能会疑惑为什么 String[]::new 可以作为 toArray 的参数。其实，String[]::new 是一个函数，可以理解为lambda函数 size -> new String[size] 。每次调用该方法都会返回一个新申请的数组。

### 1.8.4 collect

针对将流中的元素收集到另一个目标中，有一个便捷方法 collect 可用，它会接受一个 Collector 接口的实例。Collector 接口的实例称为收集器。收集器是一种收集众多元素并产生单一结果的对象，Collectors 类提供了大量用于生成常见收集器的工厂方法。

```java
// 将流中元素收集到一个列表中，使用 Collectors.toList() 方法产生的收集器
List<String> result = stream.collect(Collectors.toList());

// 类似地，下面的代码展示了如何将流的元素收集到一个集中：
Set<String> result = stream.collect(Collectors.toSet());

// 如果想要设置获得的集的具体种类，那么可以将具体类的new方法作为参数，使用下面的调用：
TreeSet<String> result = stream.collect(Collectors.toCollection(TreeSet::new));

// 假设想要通过连接操作来收集流中的所有字符串。我们可以调用
String result = stream.collect(Collectors.joining());

// 如果想要在元素之间增加分隔符，可以将分隔符传递给 joining 方法：
String result = stream.collect(Collectors.joining(","));

//如果流中包含除字符串以外的其他对象，那么我们需要先将其转换为字符串
String result = stream.map(Object::toString).collect(Collectors.joining(","));
```

### 1.8.5 summarizing

如果想要将流的结果约简为总和、数量、平均值、最大值或最小值，可以使用 sumarizing(Int/Long/Double) 方法中的某一个。这些方法会接受一个将流对象映射为数值的函数，产生类型为(Int/Long/Double)Summarystatistics 的结果，同时计算总和、数量、平均值、最大值和最小值。

```java
IntSunaryStatistics sunmary =
    stream.collect(Collectors.summarizingInt(String::length));
double averageWordLength = summary.getAverage();
double maxWordLength = summary.getMax();
```



## 1.9 收集到映射表中

假设我们有一个 `Stream<Person>`，并且想要将其元素收集到一个映射表中，这样后续就可以通过它们的ID 来查找人员了。Collectors.toMap 方法有两个函数引元，它们用来产生映射表的键和值。

```java
Map<Integer, String> idToName = people.collect(
    Collectors.toMap(Person::getId, Person::getName));
```

通常，值应该是实际的元素，因此第二个函数可以使用 Function.identity()。

```java
Map<Integer, Person> idToPerson = people.collect(
	Collectors.toMap(Person::getId, Function. identity()));
```

>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。
>
>Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如 t -> t 的Lambda表达式。

如果有多个元素具有相同的键，就会存在冲突，收集器将会抛出一个 IllegalStateException 异常。可以通过提供第3个函数引元来覆盖这种行为，该函数的参数是重复的键的旧值和新值，返回的结果是最终设置该键的值。通常这个函数返回己有值、新值或它们的组合。

在下面的代码中，我们构建了一个映射表，存储了所有可用 locale 中的语言，其中每种语言在默认 locale 中的名字（例如"German"）为键，而其本地化的名字（例如"Deutsch"）为值：

```java
Stream<Locale> locales = Stream.of(Locale.getAvailablelocales()); 
Map<String, String> LanguageNames = Locales.collect(
	Collectors.toMap(
        Locale::getDisplayLanguage,
        Loc -> Loc.getDisplayLanguage(Loc),
        (existingValue, newalue) -> existingValue)); // 解决冲突
```

现在，假设我们想要了解给定国家的所有语言，这样我们就需要一个 `Map<String,Set<String>>`。例如，"Switzerland"的值是集 [French, German, Italian]。首先，我们为每种语言都存储一个单例集。无论何时，只要找到了给定国家的新语言，我们就会对已有集和新集进行并操作。

```java
Map<String, Set<String>> countryLanguageSets = locales.collect(
    Collectors.toMap(
        Locale::getDisplayCountry,
        l -> Collections.singleton(L.getDisplayLanguage()),
        (a, b) -> { // Union of a and b
            var union = new HashSet<String> (a); 
            union. addAll(b);
            return union; ));
```

如果想要得到 TreeMap，那么可以将构造器作为第4个引元来提供（必须提供一种合并函数）。下面是本节一开始所列举的示例之一，现在它会产生一个 TreeMap:

```java
Map<Integer, Person> idToPerson = people.collect(
	Collectors.toMap(
		Person::getId,
		Function.identity(),
		(existingValue, newlalue) -> { throw new IllegalStateException();},
		TreeMap::new));
```



## 1.10 群组和分区

在上一节中，你看到了如何收集给定国家的所有语言，但是其处理显得有些冗长。你必须为每个映射表的值都生成单例集，然后指定如何将旧集合与新集合合并。

实际上，将具有相同特性的值群聚成组是非常常见的。groupingBy 方法直接就支持它，它支持产生一个映射表，映射的每个值都是一个列表。在下面的代码中，函数 Locale::getCountry 是群组的分类函数，你现在可以查找给定国家代码对应的所有地点了。

```java
Map<String, List<Locale>> countryToLocales = locales.collect(
    Collectors.groupingBy(Locale::getCountry));
List<Locale> SwissLocales = countryToLocales.get("CH");
// Yields Locales de CH, fr CH, it CH and maybe more
```

当分类函数是断言函数（即返回 boolean 值的函数）时，流的元素可以分为两个列表：该函数返回 true 的元素和其他的元素。在这种情况下，使用 partitioningBy 比使用 groupingBy 更高效。

例如，在下面的代码中，我们将所有 locale 分成了使用英语和使用所有其他语言的两类。

```java
Map<Boolean, List<Locale>> engLishAndOtherLocales = Locales.collect(
    Collectors.partitioningBy(l -> l.getLanguage().equals("en")));
List<Locale> englishLocales = engLishAndotherLocales.get(true);
```



## 1.11 下游收集器

groupingBy 方法会产生一个映射表，它的每个值都是一个列表。如果想要以某种方式来处理这些列表，可以给groupingBy 方法提供一个"下游收集器"。例如，如果想要获得集而不是列表，那么可以使用上一节中介绍到的 Collectors. toSet 收集器：

```java
Map<String, Set<Locale>> countryToLocaleSet = locales.collect(
    Collectors.groupingBy(Locale::getCountry, Collectors.toSet()));
```

下面的代码静态导入了 java.util.stream.Collectors.* ，以方便阅读。

Java 提供了多种可以将收集到的元素约简为数字的收集器。

### 1.11.1 counting

counting 会产生收集到的元素的个数。下面的代码可以对每个国家有多少个 locale 进行计数。

```java
Map<String, Long> countryToLocaleCounts = locales.collect(
    groupingBy(Locale::getCountry, counting()));
```

### 1.11.2 summing

summing(Int/Long/Double) 会接受一个函数作为引元，将该函数应用到下游元素中，并产生它们的和。例如下面的代码可以计算城市流中每个州的人口总和。

```java
Map<String, Integer> stateToCityPopulation = cities.collect(
    groupingBy(City::getState, summingInt(City::getPopulation)));
```

### 1.11.3 maxBy 和 minBy

maxBy 和 minBy 会接受一个比较器，并分别产生下游元素中的最大值和最小值。
```java
Map<String, Optional<City>> stateToLargestCity = cities.collect(
    groupingBy(City::getState, maxBy(Comparator.comparing(City::getPopulation))));
```

### 1.11.4 collectingAndThen

collectingAndThen 收集器在收集器后面添加了一个最终处理步骤。例如，如果我们想要知道有多少不同的结果，那么就可以将它们收集到一个集中，然后计算其尺寸：

```java
Map<Character, Integer> stringCountsByStartingLetter = strings.collect(
    groupingBy(s -> s.charAt(0), collectingAndThen(toSet(), Set::size)));
```

### 1.11.5 mapping

mapping 收集器会将一个函数应用于收集到的每个元素，并将结果传递给下游收集器。
```java
Map<Character, Set<Integer>> stringLengthsByStartingLetter = strings.collect(
    groupingBy(s -> s.charAt(0), mapping(String::length, toset()))); 
```

这里，我们按照首字符对字符串进行了分组。在每个组内部，我们会计算字符串的长度，然后将这些长度收集到一个集中。

mapping 方法还针对上一节中的问题，即把某国所有的语言收集到一个集中，产生了一种更佳的解决方案。

```java
Map<String, Set<String>> countryToLanguages = Locales.collect(
    groupingBy(Locale::getDisplayCountry, 
    	mapping(Locale::getDisplayLanguage,toSet())));
```

### 1.11.6 filtering

filtering 收集器会将一个过滤器应用到每个组上，例如：

```java
Map<String, Set<City>> largecitiesBystate = cities.collect(
    groupingBy (City::getstate,
    	filtering(c -> c.getPopulation() > 500000，
                  toSet())));// States without Large cities have empty sets
```



## 1.13 约简操作

reduce 方法是一种用于从流中计算某个值的通用机制，其最简单的形式将接受一个二元函数，并从前两个元素开始持续应用它。更一般地，我们可以使用任何约简操作将部分结果 x 与下一个值 y 组合起来以产生新的部分结果。

例如，可以使用约简操作计算流中元素的和：

```java
List<Integer> values
Optional<Integer> sum = values.stream().reduce((x, y) -> x + y);
// 也可以写成 reduce(Integer::sum)
```

如果要用并行流来约简，那么这项约简操作必须是可结合的，即组合元素时使用的顺序不会产生任何影响。在数学标记法中，(x op y) op z 必须等于xop (y op z)。减法是一个不可结合操作的例子。

通常，会有一个幺元值。使得 e op x=x，可以使用这个元素作为计算的起点。如果流为空，则会返回么元值，你就再也不需要处理 Optional 类了。例如，0是加法的幺元值。由此，我们可以使用第2种形式的 reduce。

```java
List<Integer> values = ...;
Integer sum = values.stream().reduce(0, (x，y)>x+y);
```

现在，假设你有一个对象流，并且想要对某些属性求和，例如字符串流中所有字符串的长度，那么你就不能使用简单形式的 reduce。因为上面介绍的reduce需要 (T,T)->T 这样的函数，即引元和结果的类型相同的函数。但是在这种情况下，你有两种类型：流的元素具有 String 类型，而累积结果是整数。有一种形式的 reduce 可以处理这种情况。首先，你需要提供一个“累积器”函数（total，word) -> total + word.Length()。这个函数会被反复调用，产生累积的总和。但是，当计算被并行化时，会有多个这种类型的计算，你需要将它们的结果合并。因此，你需要提供第二个函数来执行此处理。完整的调用如下：

```java
int result = words.reduce(0,
	(total, word) -> total + word.Length(),
    (total1, total2) -> total1 + total2);
```



## 1.13 基本类型流

到目前为止，我们都是将整数收集到 `Stream<Integer>` 中，尽管很明显，但是将每个整数都包装到包装器对象中却是很低效的。对其他基本类型来说，情况也是一样，这些基本类型是 double、 float、 Long、 short、char、byte 和 boolean。

### 1.13.1 Int/Long/DoubleStream

流库中具有专门的类型 IntStream、 LongStream 和 DoubleStream，用来直接存储基本类型值，而无须使用包装器。如果想要存储 short、 char、byte 和 boolean，可以使用 IntStream；而对于 float 可以使用 DoubleStream。

可以使用 IntStream.of 和 Arrays.stream 方法创建 IntStream。

```java
IntStream stream = IntStream.of(1,1,2,3,5);
stream = Arrays.stream(values, from, to); // values is an int[] array
```

与对象流一样，我们还可以使用静态的 generate 和 iterate 方法（见1.2节）。

此外，IntStream 和 LongStream 有静态方法 range 和 rangeclosed，可以生成步长为1的整数范围：
```java
IntStream zeroToNinetyNine = IntStream.range(0, 100); // Upper bound is excluded
IntStrean zeroToHundred = IntStream.rangeClosed(0, 100); // Upper bound is included
```

### 1.13.2 CharSequence 生成 IntStream

CharSequence 接口拥有 codePoints 和 chars 方法，可以生成由字符的 Unicode 码或由 UTF-16 代码单元构成的 IntStream。
```java
String sentence = "\uD835\uDD46 is the set of octonions.";
IntStream codes = sentence.codePoints();
// The stream with hex values 1D546 20 69 73 20...
```

### 1.13.3 基本类型流与对象流的转换

当你有一个对象流时，可以用 mapToInt、 mapToLong 或 mapToDouble 将其转换为基本类型流。转换时，需要提供一个函数，用以完成转换操作。例如，有一个字符串流，我们要获得由字符串长度构成的基本类型流：
```java
Stream<String> words = ...;
IntStream Lengths = words.mapToInt(String::length);
```

为了将基本类型流转换为对象流，需要使用 boxed 方法：

```java
Stream<Integer> integers = IntStream.range(0, 100).boxed();
```

### 1.13.4 基本类型流与对象流的差异

通常，基本类型流上的方法与对象流上的方法类似。下面是主要的差异：

+ toArray 方法会返回基本类型数组。
+ 产生可选结果的方法会返回一个 OptionalInt、 OptionalLong 或 OptionalDouble。这些类与
    Optional 类类似，但是具有 getAsInt 、 getAsLong 和 getAsDouble 方法，而不是 get 方法。
+ 具有分别返回总和、平均值、最大值和最小值的 sum、average、max 和 min 方法。对象
    流没有定义这些方法。
+ summaryStatistics 方法会产生一个类型为 IntSummaryStatistics、 LongSummaryStatistics 或
    DoubleSummarystatistics 的对象，它们可以同时报告流的总和、数量、平均值、最大值和最小值。

>注释：Random 类具有 ints、 Longs 和 doubles 方法，它们会返回由随机数构成的基本类型流。如果需要的是并行流中的随机数，那么需要使用 SplittableRandom 类。



## 1.14 并行流

### 1.14.1 获取并行流

流使并行处理块操作变得很容易。这个过程几乎是自动的，但是需要遵守一些规则。首先，必须有一个并行流。可以用 Collection 接口的 parallelStream() 方法从任何集合中获取一个并行流：

```java
Stream<String> parallelWords = words.parallelStream();
```

而且，parallel 方法可以将任意的顺序流转换为并行流。

```java
Stream<string> parallelWords = Stream.of(wordArray).parallel();
```


由于终结方法是延迟执行的，所以只要在终结方法执行时流处于并行模式，所有的中间流操作就都将被并行化。

### 1.14.2 并行流的使用时机

当流操作并行运行时，我们需要保证其返回结果与顺序执行时返回的结果相同。这意味着流操作是无状态的，并且可以以任意顺序执行。

考虑对字符串流中的所有短单词计数的任务，如果按照下面的方式使用并行流，将会导致错误。原因是传递给 forEach 的函数会在多个并发线程中运行，每个都会更新共享的数组，这是典型的竞争情况。

```java
var shortWords = new int [12];
words.parallelStream().forEach(
	s -> { if(s.length() < 12) shortwords[s.length()]++;});
// ERROR- -race condition!
```

正确的做法是，可以用长度将字符串分组，然后分别对它们进行计数，那么就可以安全地并行化这项计算。

```java
Map<Integer, Long> shortWordCounts
    = words.parallelStream()
		.filter(s -> s.length() < 12)
    	.collect( groupingBy(
            String::length,
			counting()));
```

默认情况下，从有序集合（数组和列表)、范围、生成器和迭代器产生的流，或者通过调 Stream.sorted 产生的流，都是有序的。它们的结果是按照原来元素的顺序累积的，因此是完全可预知的。如果运行相同的操作两次，将会得到完全相同的结果。

不要指望通过将所有的流都转换为并行流就能够加速操作，要牢记下面几条：

+ 并行化会导致大量的开销，只有面对非常大的数据集才划算。
+ 只有在底层的数据源可以被有效地分割为多个部分时，将流并行化才有意义。
+ 并行流使用的线程池可能会因诸如文件V/O 或网络访问这样的操作被阻塞而饿死。

























